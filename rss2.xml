<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Namgung Jong Min</title>
    <link>https://NamgungJongMin.github.io/</link>
    
    <atom:link href="https://namgungjongmin.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Fri, 07 Feb 2025 15:41:42 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>WEGO ) 테스트 코드로 더 안정적인 프로젝트 만들기: Jest를 활용한 실전 테스트 적용</title>
      <link>https://namgungjongmin.github.io/2025/01/08/project/wego/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BD%94%EB%93%9C/</link>
      <guid>https://namgungjongmin.github.io/2025/01/08/project/wego/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BD%94%EB%93%9C/</guid>
      <pubDate>Wed, 08 Jan 2025 12:42:24 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/921dd816-acad-468d-b160-8e912a3d9f5f/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;프로젝트를 진행하면서 가장</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/921dd816-acad-468d-b160-8e912a3d9f5f/image.png"></p><blockquote><p>프로젝트를 진행하면서 가장 중요하게 생각했던 것 중 하나는 코드의 안정성이었습니다. 특히 여행 관련 서비스를 개발하면서, 사용자 경험에 직접적인 영향을 미치는 UI 컴포넌트들의 안정성은 매우 중요했습니다.</p></blockquote><h1 id="▪︎-테스트-코드의-필요성"><a href="#▪︎-테스트-코드의-필요성" class="headerlink" title="▪︎ 테스트 코드의 필요성"></a>▪︎ <strong>테스트 코드의 필요성</strong></h1><h2 id="▫︎-복잡한-UI-상태-관리"><a href="#▫︎-복잡한-UI-상태-관리" class="headerlink" title="▫︎ 복잡한 UI 상태 관리"></a>▫︎ <strong>복잡한 UI 상태 관리</strong></h2><p>여행 서비스의 특성상 다양한 상태를 가진 컴포넌트들이 많았습니다. 예를 들어 리뷰 카드의 경우 아래와 같은 복잡한 상태들을 수동으로 테스트하는 것은 비효율적이며, 실수하기 쉬웠습니다.</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;리뷰 카드 컴포넌트&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> props = &#123;</span><br><span class="line">    <span class="attr">reviewId</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">profileImage</span>: <span class="string">&#x27;/user.jpg&#x27;</span>,</span><br><span class="line">    <span class="attr">reviewImage</span>: <span class="string">&#x27;/test.png&#x27;</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;테스트 리뷰&#x27;</span>,</span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;이것은 테스트 리뷰 내용입니다.&#x27;</span>,</span><br><span class="line">    <span class="attr">starRating</span>: <span class="number">4.5</span>,</span><br><span class="line">    <span class="attr">travelLocation</span>: <span class="string">&#x27;서울&#x27;</span>,</span><br><span class="line">    <span class="attr">createdAt</span>: <span class="string">&#x27;2023-10-10&#x27;</span>,</span><br><span class="line">    <span class="attr">likesFlag</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;리뷰 카드가 올바르게 렌더링되어야 합니다 (리뷰 페이지)&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">renderWithQueryClient</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ReviewCard</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">nickname</span>=<span class="string">&quot;테스터&quot;</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(screen.<span class="title function_">getByText</span>(<span class="string">&#x27;테스트 리뷰&#x27;</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">    <span class="title function_">expect</span>(</span><br><span class="line">      screen.<span class="title function_">getByText</span>(<span class="string">&#x27;이것은 테스트 리뷰 내용입니다.&#x27;</span>),</span><br><span class="line">    ).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">    <span class="title function_">expect</span>(screen.<span class="title function_">getByText</span>(<span class="string">&#x27;테스터&#x27;</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">    <span class="title function_">expect</span>(screen.<span class="title function_">getByText</span>(<span class="string">&#x27;4.5&#x27;</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;리뷰 카드가 올바르게 렌더링되어야 합니다 (마이페이지)&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">renderWithQueryClient</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ReviewCard</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(screen.<span class="title function_">getByText</span>(<span class="string">&#x27;테스트 리뷰&#x27;</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">    <span class="title function_">expect</span>(</span><br><span class="line">      screen.<span class="title function_">getByText</span>(<span class="string">&#x27;이것은 테스트 리뷰 내용입니다.&#x27;</span>),</span><br><span class="line">    ).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">    <span class="title function_">expect</span>(screen.<span class="title function_">getByText</span>(<span class="string">&#x27;4.5&#x27;</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">    <span class="title function_">expect</span>(screen.<span class="title function_">getByText</span>(<span class="string">&#x27;서울&#x27;</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;이미지가 올바르게 표시되어야 합니다&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">renderWithQueryClient</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ReviewCard</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> image = screen.<span class="title function_">getByAltText</span>(<span class="string">&#x27;테스트 리뷰&#x27;</span>);</span><br><span class="line">    <span class="title function_">expect</span>(image).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="▫︎-비동기-데이터-처리의-안정성"><a href="#▫︎-비동기-데이터-처리의-안정성" class="headerlink" title="▫︎ 비동기 데이터 처리의 안정성"></a>▫︎ <strong>비동기 데이터 처리의 안정성</strong></h2><p>API 호출과 같은 비동기 작업이 많은 서비스 특성상, 데이터 로딩, 에러 상태 등 다양한 상황에 대한 테스트가 필요했습니다.</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&quot;로딩 중일 때 스켈레톤 UI를 표시한다&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  (useReview <span class="keyword">as</span> jest.<span class="property">Mock</span>).<span class="title function_">mockReturnValue</span>(&#123;</span><br><span class="line">    <span class="attr">isLoading</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; container &#125; = <span class="title function_">renderWithQueryClient</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ReviewContents</span> /&gt;</span></span>);</span><br><span class="line">  <span class="comment">// 스켈레톤 UI의 특정 클래스명을 기준으로 요소를 찾습니다.</span></span><br><span class="line">  <span class="keyword">const</span> skeletonElements = container.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.skeleton-style&quot;</span>);</span><br><span class="line">  <span class="title function_">expect</span>(skeletonElements.<span class="property">length</span>).<span class="title function_">toBeGreaterThan</span>(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">it</span>(<span class="string">&quot;리뷰 데이터가 있을 때 리뷰 카드가 렌더링된다&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  (useReview <span class="keyword">as</span> jest.<span class="property">Mock</span>).<span class="title function_">mockReturnValue</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">pages</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="attr">content</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">nickname</span>: <span class="string">&quot;사용자1&quot;</span>,</span><br><span class="line">                <span class="attr">profileImage</span>: <span class="string">&quot;https://example.com/profile1.jpg&quot;</span>,</span><br><span class="line">                <span class="attr">reviewImage</span>: <span class="string">&quot;https://example.com/review1.jpg&quot;</span>,</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&quot;리뷰 제목 1&quot;</span>,</span><br><span class="line">                <span class="attr">content</span>: <span class="string">&quot;리뷰 내용 1&quot;</span>,</span><br><span class="line">                <span class="attr">starRating</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="attr">travelLocation</span>: <span class="string">&quot;서울&quot;</span>,</span><br><span class="line">                <span class="attr">createdAt</span>: <span class="string">&quot;2023-10-01&quot;</span>,</span><br><span class="line">                <span class="attr">isLiked</span>: <span class="literal">true</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">isLoading</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">isError</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">hasNextPage</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">fetchNextPage</span>: jest.<span class="title function_">fn</span>(),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; getByText &#125; = <span class="title function_">renderWithQueryClient</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ReviewContents</span> /&gt;</span></span>);</span><br><span class="line">  <span class="title function_">expect</span>(<span class="title function_">getByText</span>(<span class="string">&quot;리뷰 제목 1&quot;</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">  <span class="title function_">expect</span>(<span class="title function_">getByText</span>(<span class="string">&quot;리뷰 내용 1&quot;</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">it</span>(<span class="string">&quot;리뷰 데이터가 없을 때 아무것도 렌더링하지 않는다&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  (useReview <span class="keyword">as</span> jest.<span class="property">Mock</span>).<span class="title function_">mockReturnValue</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">pages</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="attr">content</span>: [],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">isLoading</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">isError</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">hasNextPage</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">fetchNextPage</span>: jest.<span class="title function_">fn</span>(),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; queryByText &#125; = <span class="title function_">renderWithQueryClient</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ReviewContents</span> /&gt;</span></span>);</span><br><span class="line">  <span class="title function_">expect</span>(<span class="title function_">queryByText</span>(<span class="regexp">/리뷰 제목 1/i</span>)).<span class="property">not</span>.<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="▪︎-테스트-코드-작성-전략"><a href="#▪︎-테스트-코드-작성-전략" class="headerlink" title="▪︎ 테스트 코드 작성 전략"></a>▪︎ 테스트 코드 작성 전략</h1><h2 id="▫︎-테스트-시나리오-구성"><a href="#▫︎-테스트-시나리오-구성" class="headerlink" title="▫︎ 테스트 시나리오 구성"></a>▫︎ <strong>테스트 시나리오 구성</strong></h2><p>테스트 코드는 크게 세 가지 관점에서 작성했습니다.</p><h3 id="1-기본-렌더링-테스트"><a href="#1-기본-렌더링-테스트" class="headerlink" title="1. 기본 렌더링 테스트"></a>1. 기본 렌더링 테스트</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;ReviewComment&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&quot;리뷰 작성칸을 렌더링합니다&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ReviewComment</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(screen.<span class="title function_">getByText</span>(<span class="string">&quot;여행에 대한 후기를 남겨주세요!&quot;</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">    <span class="title function_">expect</span>(screen.<span class="title function_">getByLabelText</span>(<span class="string">&quot;최대 20자 입력 가능 textarea&quot;</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">    <span class="title function_">expect</span>(screen.<span class="title function_">getByPlaceholderText</span>(<span class="string">&quot;여행 제목을 입력해 주세요.&quot;</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">    <span class="title function_">expect</span>(screen.<span class="title function_">getByLabelText</span>(<span class="string">&quot;최대 100자 입력 가능 textarea&quot;</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">    <span class="title function_">expect</span>(screen.<span class="title function_">getByPlaceholderText</span>(<span class="string">&quot;여행에 대한 다양한 후기를 공유해 주세요!&quot;</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-사용자-인터렉션-테스트"><a href="#2-사용자-인터렉션-테스트" class="headerlink" title="2. 사용자 인터렉션 테스트"></a>2. 사용자 인터렉션 테스트</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&quot;페이지 버튼 클릭 시 paginate 함수가 호출된다&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> paginateMock = jest.<span class="title function_">fn</span>();</span><br><span class="line">  <span class="keyword">const</span> &#123; getByText &#125; = <span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Pagination</span> <span class="attr">totalPages</span>=<span class="string">&#123;4&#125;</span> <span class="attr">currentPage</span>=<span class="string">&#123;1&#125;</span> <span class="attr">paginate</span>=<span class="string">&#123;paginateMock&#125;</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">  fireEvent.<span class="title function_">click</span>(<span class="title function_">getByText</span>(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">  <span class="title function_">expect</span>(paginateMock).<span class="title function_">toHaveBeenCalledWith</span>(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-엣지-케이스-테스트"><a href="#3-엣지-케이스-테스트" class="headerlink" title="3. 엣지 케이스 테스트"></a>3. 엣지 케이스 테스트</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&quot;리뷰 데이터가 없을 때 빈 상태 메시지를 렌더링한다&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  (useMyReview <span class="keyword">as</span> jest.<span class="property">Mock</span>).<span class="title function_">mockReturnValue</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">content</span>: [],</span><br><span class="line">        <span class="attr">total</span>: <span class="number">0</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">renderWithProvider</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Written</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">expect</span>(screen.<span class="title function_">getByText</span>(<span class="string">&quot;아직 작성한 리뷰가 없어요!&quot;</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="▫︎-비동기-테스트-처리"><a href="#▫︎-비동기-테스트-처리" class="headerlink" title="▫︎ 비동기 테스트 처리"></a>▫︎ <strong>비동기 테스트 처리</strong></h2><h3 id="1-로딩-상태-처리"><a href="#1-로딩-상태-처리" class="headerlink" title="1. 로딩 상태 처리"></a>1. <strong>로딩 상태 처리</strong></h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&quot;로딩 중일 때 스켈레톤 UI를 표시한다&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  (useReview <span class="keyword">as</span> jest.<span class="property">Mock</span>).<span class="title function_">mockReturnValue</span>(&#123;</span><br><span class="line">    <span class="attr">isLoading</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; container &#125; = <span class="title function_">renderWithQueryClient</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ReviewContents</span> /&gt;</span></span>);</span><br><span class="line">  <span class="comment">// 스켈레톤 UI의 특정 클래스명을 기준으로 요소를 찾습니다.</span></span><br><span class="line">  <span class="keyword">const</span> skeletonElements = container.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.skeleton-style&quot;</span>);</span><br><span class="line">  <span class="title function_">expect</span>(skeletonElements.<span class="property">length</span>).<span class="title function_">toBeGreaterThan</span>(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-데이터-페칭-결과-처리"><a href="#2-데이터-페칭-결과-처리" class="headerlink" title="2. 데이터 페칭 결과 처리"></a>2. <strong>데이터 페칭 결과 처리</strong></h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&quot;여행 데이터가 있을 때 여행 카드가 렌더링된다&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  (usePastTravel <span class="keyword">as</span> jest.<span class="property">Mock</span>).<span class="title function_">mockReturnValue</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">content</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">travelId</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">travelName</span>: <span class="string">&quot;과거 여행 1&quot;</span>,</span><br><span class="line">            <span class="attr">maxTravelMateCount</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">currentTravelMateCount</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">isDomestic</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">location</span>: <span class="string">&quot;서울&quot;</span>,</span><br><span class="line">            <span class="attr">image</span>: <span class="string">&quot;https://example.com/image.jpg&quot;</span>,</span><br><span class="line">            <span class="attr">startAt</span>: <span class="string">&quot;2023-10-01&quot;</span>,</span><br><span class="line">            <span class="attr">endAt</span>: <span class="string">&quot;2023-10-10&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">total</span>: <span class="number">1</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; getByText &#125; = <span class="title function_">renderWithQueryClient</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">PastTravel</span> /&gt;</span></span>);</span><br><span class="line">  <span class="title function_">expect</span>(<span class="title function_">getByText</span>(<span class="regexp">/과거 여행 1/i</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-에러-상태-처리"><a href="#3-에러-상태-처리" class="headerlink" title="3. 에러 상태 처리"></a>3. 에러 상태 처리</h3><p>추가로 각 컴포넌트에서 발생할 수 있는 에러 상황을 고려하여 테스트케이스를 작성했습니다.</p><h2 id="▫︎-모킹-전략-활용"><a href="#▫︎-모킹-전략-활용" class="headerlink" title="▫︎ 모킹 전략 활용"></a>▫︎ 모킹 전략 활용</h2><p>외부 의존성이 있는 컴포넌트의 경우, 적절한 모킹을 통해 테스트의 안정성을 확보했습니다.</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jest.<span class="title function_">mock</span>(<span class="string">&quot;next/navigation&quot;</span>, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">useRouter</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">push</span>: jest.<span class="title function_">fn</span>(),</span><br><span class="line">    <span class="attr">replace</span>: jest.<span class="title function_">fn</span>(),</span><br><span class="line">    <span class="attr">back</span>: jest.<span class="title function_">fn</span>(),</span><br><span class="line">    <span class="comment">// 필요한 다른 router 메서드들...</span></span><br><span class="line">  &#125;),</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h1 id="▪︎-테스트-코드-작성-시-중점-사항"><a href="#▪︎-테스트-코드-작성-시-중점-사항" class="headerlink" title="▪︎ 테스트 코드 작성 시 중점 사항"></a>▪︎ <strong>테스트 코드 작성 시 중점 사항</strong></h1><h2 id="▫︎-테스트-가독성"><a href="#▫︎-테스트-가독성" class="headerlink" title="▫︎ 테스트 가독성"></a>▫︎ <strong>테스트 가독성</strong></h2><p>각 테스트 케이스의 의도가 명확히 드러나도록 작성했습니다.</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;기본적으로 &quot;myTravel&quot; 탭이 선택되어야 한다&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">renderWithQueryClient</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">MainTab</span> <span class="attr">selectedTab</span>=<span class="string">&quot;myTravel&quot;</span> <span class="attr">setSelectedTab</span>=<span class="string">&#123;setSelectedTabMock&#125;</span> <span class="attr">setSelectedSubTab</span>=<span class="string">&#123;setSelectedSubTabMock&#125;</span> /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="title function_">expect</span>(screen.<span class="title function_">getByText</span>(<span class="regexp">/나의 여행/i</span>)).<span class="title function_">toBeInTheDocument</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="▫︎-테스트-유지보수성"><a href="#▫︎-테스트-유지보수성" class="headerlink" title="▫︎ 테스트 유지보수성"></a>▫︎ <strong>테스트 유지보수성</strong></h2><p>반복되는 테스트 로직은 유틸리티 함수로 분리하여 재사용성을 높였습니다.</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">renderWithProvider</span> = (<span class="params">ui: React.ReactNode</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">QueryClientProvider</span> <span class="attr">client</span>=<span class="string">&#123;queryClient&#125;</span>&gt;</span>&#123;ui&#125;<span class="tag">&lt;/<span class="name">QueryClientProvider</span>&gt;</span></span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="▪︎-마치며"><a href="#▪︎-마치며" class="headerlink" title="▪︎ 마치며"></a>▪︎ 마치며</h1><p>테스트 코드 작성은 단순히 버그를 잡기 위한 도구가 아닌, 더 나은 설계를 위한 도구이자 문서의 역할도 수행했습니다. 특히 비동기 처리가 많은 현대 웹 애플리케이션에서 다양한 상황에 대한 테스트 케이스를 작성함으로써, 더 안정적인 서비스를 제공할 수 있었습니다.</p><p>앞으로도 테스트 커버리지를 높이고, 더 효율적인 테스트 전략을 발전시켜 나갈 예정입니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Project/">Project</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/WEGO/">WEGO</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/">테스트</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BD%94%EB%93%9C/">테스트코드</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</category>
      
      
      <comments>https://namgungjongmin.github.io/2025/01/08/project/wego/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BD%94%EB%93%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>KMP 알고리즘 ) 문자열에서 특정한 문자열을 찾는 것을 O(N)으로 해결하기</title>
      <link>https://namgungjongmin.github.io/2024/04/16/algorithm/kmp/</link>
      <guid>https://namgungjongmin.github.io/2024/04/16/algorithm/kmp/</guid>
      <pubDate>Tue, 16 Apr 2024 07:25:46 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;부분문자열-찾기&quot;&gt;&lt;a href=&quot;#부분</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png"></p><h1 id="부분문자열-찾기"><a href="#부분문자열-찾기" class="headerlink" title="부분문자열 찾기"></a>부분문자열 찾기</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/b197faaf-f92e-4f97-bdfa-c09bb9bbe970/image.png" alt="image.png"></p><blockquote><p>위 이미지와 같은 문제에서 어떠한 문자열 내에서 특정한 다른 문자열을 찾을 때 가장 단순한 방법은 두 문자열의 각 문자들을 비교하는 것입니다. 그러나 이 경우 각 문자열의 모든 문자들을 매칭하여 탐색해야하기 때문에 효율성이 낮습니다. 따라서 대상 문자열의 크기가 크거나 효율성을 높이고 싶다면 KMP 알고리즘을 고려해볼 수 있습니다. 위 사진을 예시로하여 문자열을 찾는 두가지 방법에 대해 밑에서 알아보겠습니다.</p></blockquote><h1 id="▪︎-두-문자열의-각-문자-비교"><a href="#▪︎-두-문자열의-각-문자-비교" class="headerlink" title="▪︎ 두 문자열의 각 문자 비교"></a>▪︎ 두 문자열의 각 문자 비교</h1><p>str을 기준으로 각 문자를 순회하되 해당 문자가 subStr의 첫 문자와 같다면 그 다음 문자들을 비교하는 방식으로 이루어집니다. 이 경우 str을 순회하는 start 포인터와 str과 subStr의 일치여부 확인을 위한 위치 포인터가 필요하기 때문에 O(NM)의 시간복잡도를 가집니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/9cf5f140-18fa-46f1-be7a-67fbc4c0888f/image.png" alt="image.png"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;ABCABCABBD&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> subStr = <span class="string">&quot;ABCABB&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> answerIdx = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> isMatched = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; subStr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str[i + j] !== subStr[j]) &#123;</span><br><span class="line">      isMatched = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isMatched) answerIdx.<span class="title function_">push</span>(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(answerIdx); <span class="comment">// output: [4] 4번째 문자로 시작하는 하나의 같은 문자열이 존재</span></span><br></pre></td></tr></table></figure><h1 id="▪︎-KMP-알고리즘"><a href="#▪︎-KMP-알고리즘" class="headerlink" title="▪︎ KMP 알고리즘"></a>▪︎ KMP 알고리즘</h1><p>위 방법을 개선하여 효율성 높게 문자열을 찾는 방법이 KMP 알고리즘입니다. KMP 알고리즘은 무려 O(N+M)의 시간복잡도로 해결이 가능합니다. 어떻게 그것이 가능할까요? 문자열들의 각 문자들을 비교하는 방법에서는 버려지는 정보들을 활용하기 때문입니다. 위의 예시를 다시 가져와보겠습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/48c12352-403e-4c82-87ad-0b78085edc8e/image.png" alt="image.png"></p><p>두 문자열을 비교하던 중 매칭이되지 않은 문자들을 만났습니다. 이 때 우리는 ABCABC가 ABCABB가 아니라는 것을 확인함과 동시에 ABCABB의 앞쪽 문자들과 매칭되는 부분(index 3 ~ 4)이 있다는 정보를 얻게되었습니다. 이 정보를 활용하면 str문자열의 각 문자를 시작으로 하는 문자열을 전부 확인하는 것이 아니라 subStr의 앞쪽 부분과 매칭되는 index 3에서부터 다시 비교를 시작할 수 있습니다.</p><p>이 원리를 이용하면 str을 이중 순회하는 것이 아닌 한번의 순회만으로 문자열을 찾아낼 수 있습니다. subStr을 문자열의 접두사이면서 접미사인 부분 문자열들에 대한 정보와 매칭하고 그 정보를 이용하여 str의 문자를 순회하는 동안 subStr의 포인터를 이동시켜 같은 문자열인지를 판단합니다.</p><p>KMP 알고리즘은 다음 단계를 통해 구현할 수 있습니다.</p><ol><li>subStr의 접두사,접미사 관련 정보를 담은 pi를 생성합니다.</li><li>str을 순회하며 각 문자열의 pointer 이동합니다.</li><li>subStr의 포인터가 끝으로 이동했을 때에 문자끼리 같다면 동일 문자열입니다.</li></ol><h2 id="▫︎-failure-함수를-통해-pi-배열-생성"><a href="#▫︎-failure-함수를-통해-pi-배열-생성" class="headerlink" title="▫︎ failure 함수를 통해 pi 배열 생성"></a>▫︎ failure 함수를 통해 pi 배열 생성</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/703259a6-44a5-46a1-bb38-1287d68adcfa/image.png" alt="image.png"></p><p>pi 배열은 subStr의 접두사와 접미사를 확인하여 같은 길이를 값으로 가지는 배열입니다. pi의 index 0은 0으로 시작하며 이후부터는 해당 인덱스까지의 부분문자열의 접두사와 접미사가 같은 길이를 값으로 가집니다. <strong>pi 배열은 failure함수를 통해 만들 수 있습니다.</strong></p><p>“ABCA”의 경우 앞 뒤 “A”가 같기 때문에 1을 값으로 가집니다.</p><p>“ABCAB”의 경우 앞 뒤 “AB”가 같기 때문에 2를 값으로 가집니다.</p><h3 id="failure-함수의-동작"><a href="#failure-함수의-동작" class="headerlink" title="failure 함수의 동작"></a>failure 함수의 동작</h3><ol><li>첫 인덱스 값을 0으로하는 subStr 길이와 같은 배열을 생성합니다.</li><li>새로운 포인터 k를 선언하고 subStr을 순회하면서 다음 동작을 반복합니다.<ul><li>subStr[k]와 subStr[i]가 같은 경우 pi[i]에 k+1을 저장하고 k와 i 인덱스를 모두 증가시킵니다.</li><li>다를경우 k에 pi[k-1] 위치에 있는 값을 재할당합니다. (이 동작을 subStr[k]와 subStr[i]가 같아지거나 k가 0이 될 때까지 반복합니다) 이후 i 인덱스만 증가시킵니다.</li></ul></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subStr = <span class="string">&quot;ABCABB&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> pi = <span class="title class_">Array</span>(subStr.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; subStr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; subStr[k] !== subStr[i]) &#123;</span><br><span class="line">    k = pi[k - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (subStr[k] === subStr[i]) &#123;</span><br><span class="line">    pi[i] = k + <span class="number">1</span>;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pi); <span class="comment">// [0,0,0,1,2,0]</span></span><br></pre></td></tr></table></figure><h2 id="▫︎-pi배열과-두-문자열을-이용해-문자열-찾기"><a href="#▫︎-pi배열과-두-문자열을-이용해-문자열-찾기" class="headerlink" title="▫︎ pi배열과 두 문자열을 이용해 문자열 찾기"></a>▫︎ pi배열과 두 문자열을 이용해 문자열 찾기</h2><p>이제 pi 배열을 이용해서 문자열을 찾아보겠습니다. str과 subStr의 각 포인터들을 이동시키면서 str을 순회합니다. 아래 그림과 같은 방식으로 동작합니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/231216cb-a99e-4582-bab3-f4550e5f5bd6/image.png" alt="image.png"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;ABCABCABBD&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> subStr = <span class="string">&quot;ABCABB&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> pi = <span class="title class_">Array</span>(subStr.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// failure 함수를 통해 pi 배열 설정</span></span><br><span class="line"><span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; subStr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; subStr[k] !== subStr[i]) &#123;</span><br><span class="line">    k = pi[k - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (subStr[k] === subStr[i]) &#123;</span><br><span class="line">    pi[i] = k + <span class="number">1</span>;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pi 배열을 이용해 문자열 찾기</span></span><br><span class="line"><span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> answerIdx = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; subStr[j] !== str[i]) &#123;</span><br><span class="line">    j = pi[j - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (subStr[j] === str[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j === subStr.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      answerIdx.<span class="title function_">push</span>(i - subStr.<span class="property">length</span> + <span class="number">2</span>);</span><br><span class="line">      j = pi[j];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(answerIdx); <span class="comment">// output: [4] 4번째 문자로 시작하는 하나의 같은 문자열이 존재</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/KMP/">KMP</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%B0%BE%EA%B8%B0/">문자열 찾기</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/04/16/algorithm/kmp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>에라토스테네스의 체 ) 범위 내 소수 구하기</title>
      <link>https://namgungjongmin.github.io/2024/04/08/algorithm/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%EC%B2%B4/</link>
      <guid>https://namgungjongmin.github.io/2024/04/08/algorithm/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%EC%B2%B4/</guid>
      <pubDate>Mon, 08 Apr 2024 02:15:21 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;▪︎-에라토스테네스의-체&quot;&gt;&lt;a href</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png"></p><h1 id="▪︎-에라토스테네스의-체"><a href="#▪︎-에라토스테네스의-체" class="headerlink" title="▪︎ 에라토스테네스의 체"></a>▪︎ 에라토스테네스의 체</h1><p>에라토스테네스의 체는 빠르게 범위 내 소수들을 찾는 방법입니다. 하나의 수에 대해 소수인지 아닌지를 판별하는 것은 O(N)으로 해결이 가능하지만 범위 내에서 소수들을 찾기 위해서는 추가로 범위 내에 존재하는 K개의 수가 곱해진 O(N*K)의 시간복잡도를 가질 것입니다. 그러나 에라토스테네스의 체를 이용하면 O(N * log logN)의 시간복잡도로 이를 해결할 수 있습니다.</p><h2 id="▫︎-에라토스테네스의-체-원리"><a href="#▫︎-에라토스테네스의-체-원리" class="headerlink" title="▫︎ 에라토스테네스의 체 원리"></a>▫︎ 에라토스테네스의 체 원리</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif" alt="gif"></p><ul><li><strong>_출처 : <a href="https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4">https://ko.wikipedia.org/wiki/에라토스테네스의_체</a>_</strong></li></ul><p>step 1) 2부터 소수를 구하고자 하는 구간의 모든 수를 나열한다. 그림에서 회색 사각형으로 두른 수들이 여기에 해당한다.</p><p>step 2) 2는 소수이므로 오른쪽에 2를 쓴다. (빨간색)</p><p>step 3) 자기 자신을 제외한 2의 배수를 모두 지운다.</p><p>step 4) 남아있는 수 가운데 3은 소수이므로 오른쪽에 3을 쓴다. (초록색)</p><p>step 5) 자기 자신을 제외한 3의 배수를 모두 지운다.</p><p>step 6) 남아있는 수 가운데 5는 소수이므로 오른쪽에 5를 쓴다. (파란색)</p><p>step 7) 자기 자신을 제외한 5의 배수를 모두 지운다.</p><p>step 8) 남아있는 수 가운데 7은 소수이므로 오른쪽에 7을 쓴다. (노란색)</p><p>step 9) 자기 자신을 제외한 7의 배수를 모두 지운다.</p><p>step 10) 위의 과정을 반복하면 구하는 구간의 모든 소수가 남는다. (보라색)</p><blockquote><p>범위 최대값의 제곱근보다 작거나 같은 자연수의 배수들만 지우면 된다. 위 예시의 경우 10까지만 배수들을 지워주는 동작을 시행한다.</p></blockquote><h2 id="▫︎-에라토스테네스의-체-구현"><a href="#▫︎-에라토스테네스의-체-구현" class="headerlink" title="▫︎ 에라토스테네스의 체 구현"></a>▫︎ 에라토스테네스의 체 구현</h2><ol><li>2부터 소수를 구하고자하는 구간의 모든 수를 배열의 인덱스를 key로 삼아 0과 1을 제외하고 모두 true로 초기화합니다.</li><li>생성한 배열을 순회하면서 value가 false인 경우 스킵하고, true인 경우 배열 내 해당 index의 배수에 위치하는 모든 값들을 false로 재할당합니다.</li><li>초기 생성한 배열에서 true를 값으로 가진 인덱스들이 소수입니다.</li></ol><h1 id="▪︎-Example-of-Apply"><a href="#▪︎-Example-of-Apply" class="headerlink" title="▪︎ Example of Apply"></a>▪︎ Example of Apply</h1><h2 id="▫︎-100보다-작은-소수-찾기"><a href="#▫︎-100보다-작은-소수-찾기" class="headerlink" title="▫︎ 100보다 작은 소수 찾기"></a>▫︎ 100보다 작은 소수 찾기</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 소수 체크 테이블</span></span><br><span class="line"><span class="keyword">const</span> check = <span class="title class_">Array</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">101</span>)).<span class="title function_">fill</span>(<span class="literal">true</span>).<span class="title function_">fill</span>(<span class="literal">false</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 100의 제곱근인 10보다 작은 자연수의 배수들만 지우기</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!check[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = i * <span class="number">2</span>; j &lt;= <span class="number">100</span>; j += i) &#123;</span><br><span class="line">    check[j] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 소수 배열</span></span><br><span class="line"><span class="keyword">const</span> prime = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 체크 테이블의 값이 true인 index가 소수</span></span><br><span class="line">check.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el, idx</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (el) prime.<span class="title function_">push</span>(idx);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(prime);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98-%EC%B2%B4/">에라토스테네스의 체</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%86%8C%EC%88%98-%EC%B0%BE%EA%B8%B0/">소수 찾기</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/04/08/algorithm/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%EC%B2%B4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DXDY 테크닉 ) 2차원 배열에서 4방향 움직이기</title>
      <link>https://namgungjongmin.github.io/2024/04/01/algorithm/dxdy%ED%85%8C%ED%81%AC%EB%8B%89/</link>
      <guid>https://namgungjongmin.github.io/2024/04/01/algorithm/dxdy%ED%85%8C%ED%81%AC%EB%8B%89/</guid>
      <pubDate>Mon, 01 Apr 2024 07:25:22 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;코딩테스트에서 2차원 배열</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png"></p><blockquote><p>코딩테스트에서 2차원 배열을 데이터로 주고 그 안에서 포인터를 이동시키는 문제 유형에서 유용하게 사용할 수 있는 방법입니다.</p></blockquote><h1 id="▪︎-dxdy-테크닉"><a href="#▪︎-dxdy-테크닉" class="headerlink" title="▪︎ dxdy 테크닉"></a>▪︎ dxdy 테크닉</h1><p>dxdy 테크닉은 2차원 배열에서 어느 한지점의 포인터를 상하좌우로 간편하게 이동할 수 있는 방법입니다. x방향과 y방향의 direction 정보를 저장한 배열을 생성하고 순서대로 각 데이터를 참조하면서 현재 포인터 기준 4방향의 인덱스를 탐색할 수 있습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/6e960a32-c62b-4f01-9d10-bbf2828940f9/image.png" alt="image.png"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>],</span><br><span class="line">  [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>],</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> dx = [<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> dy = [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 현재 위치를 (1,1) 이라고 할 때, pointer 위치의 값은 20</span></span><br><span class="line"><span class="keyword">const</span> cx = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> cy = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[cy + dy[i]][cx + dx[i]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output :</span></span><br><span class="line"><span class="comment">// 2 (pointer 기준 &#x27;상&#x27;)</span></span><br><span class="line"><span class="comment">// 200 (pointer 기준 &#x27;하&#x27;)</span></span><br><span class="line"><span class="comment">// 10 (pointer 기준 &#x27;좌&#x27;)</span></span><br><span class="line"><span class="comment">// 30 (pointer 기준 &#x27;우&#x27;)</span></span><br></pre></td></tr></table></figure><h1 id="▪︎-Example-of-Apply"><a href="#▪︎-Example-of-Apply" class="headerlink" title="▪︎ Example of Apply"></a>▪︎ Example of Apply</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/043f5a9f-8ae5-44b5-bdf5-251928622fc4/image.png" alt="image.png"></p><p><img src="https://velog.velcdn.com/images/vbghdl/post/384e8f9a-a6a4-4527-8b59-36ec679ee4e4/image.png" alt="image.png"></p><ul><li><a href="https://www.acmicpc.net/problem/1987">https://www.acmicpc.net/problem/1987</a></li></ul><p>이 문제는 (0,0) 위치에서부터 4방향을 움직이되 움직인 위치의 값이 이전에 지나온 값이라면 갈 수 없습니다. 따라서 dxdy 테크닉을 통해 2차원 배열을 재귀로 움직이면서 현재 위치의 값을 visited 변수에 저장하고 이동하면서 참조한 뒤, visited 값이 true라면 재귀를 멈추면 됩니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;dev/stdin&quot;</span>).<span class="title function_">toString</span>().<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> arr = input.<span class="title function_">slice</span>(<span class="number">1</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> el.<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dx = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> dy = [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> visited = <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">let</span> answer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">depth, x, y</span>) =&gt; &#123;</span><br><span class="line">  answer = answer &lt; depth ? depth : answer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> nx = x + dx[i];</span><br><span class="line">    <span class="keyword">const</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 이동할 좌표가 없을 경우 continue</span></span><br><span class="line">    <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= arr[<span class="number">0</span>].<span class="property">length</span> || ny &lt; <span class="number">0</span> || ny &gt;= arr.<span class="property">length</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 이동한 좌표의 알파벳의 아스키코드가 true면 이미 지나온 블록. continue</span></span><br><span class="line">    <span class="keyword">if</span> (visited[arr[ny][nx].<span class="title function_">charCodeAt</span>() - <span class="number">65</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    visited[arr[ny][nx].<span class="title function_">charCodeAt</span>() - <span class="number">65</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">dfs</span>(depth + <span class="number">1</span>, nx, ny);</span><br><span class="line">    visited[arr[ny][nx].<span class="title function_">charCodeAt</span>() - <span class="number">65</span>] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">visited[arr[<span class="number">0</span>][<span class="number">0</span>].<span class="title function_">charCodeAt</span>() - <span class="number">65</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="title function_">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(answer);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/DXDY-%ED%85%8C%ED%81%AC%EB%8B%89/">DXDY 테크닉</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/">그래프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/04/01/algorithm/dxdy%ED%85%8C%ED%81%AC%EB%8B%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>그래프 ) 배열 데이터로 정제하기</title>
      <link>https://namgungjongmin.github.io/2024/03/25/algorithm/%EA%B7%B8%EB%9E%98%ED%94%84/</link>
      <guid>https://namgungjongmin.github.io/2024/03/25/algorithm/%EA%B7%B8%EB%9E%98%ED%94%84/</guid>
      <pubDate>Mon, 25 Mar 2024 05:35:52 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;코딩테스트에서 그래프와 관</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png"></p><blockquote><p>코딩테스트에서 그래프와 관련된 문제를 만났을 때, 해당 그래프를 순회하고 조작할 수 있는 정제된 형태의 데이터로 만들 필요가 있습니다. 이번 포스트에서는 여러 그래프의 종료들의 분석하는 방법과 함께 그래프 정보를 인접행렬 &#x2F; 인접리스트 데이터로 정제하는 방법에 대해 다뤄보겠습니다.</p></blockquote><h1 id="▪︎-무방향-그래프"><a href="#▪︎-무방향-그래프" class="headerlink" title="▪︎ 무방향 그래프"></a>▪︎ 무방향 그래프</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/f238072b-4c39-49e0-9a55-b049eecd5750/image.png" alt="image.png"></p><p>무방향 그래프는 노드가 서로 양방향으로 연결되어있는 형태로 방향에 상관없이 연결된 노드에 접근이 가능한 구조입니다. 행을 타겟 노드로, 열을 접근할 노드로 하는 인접행렬 데이터를 배열로 만들어 순회할 수 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 무방향 그래프</span></span><br><span class="line"><span class="keyword">const</span> N = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> input = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> graph = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title class_">Array</span>(N + <span class="number">1</span>), <span class="function">() =&gt;</span> <span class="title class_">Array</span>(N + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">input.<span class="title function_">forEach</span>(<span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">  graph[array[<span class="number">0</span>]][array[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">  graph[array[<span class="number">1</span>]][array[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(graph);</span><br></pre></td></tr></table></figure><h1 id="▪︎-방향-그래프"><a href="#▪︎-방향-그래프" class="headerlink" title="▪︎ 방향 그래프"></a>▪︎ 방향 그래프</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/55c2451c-d4c9-447c-8b82-cbd9bcdef88d/image.png" alt="image.png"></p><p>방향 그래프는 노드가 단방향으로 연결되어있는 형태로 한쪽 방향으로만 연결된 노드에 접근할 수 있습니다. 입력된 그래프 데이터에서 노드가 가리키는 다른 노드의 위치에 대한 정보만을 인접행렬에 저장합니다. (입력 데이터 각 배열의 인덱스의 값의 순서가 의미를 가집니다.)</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 방향 그래프</span></span><br><span class="line"><span class="keyword">const</span> N = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> input = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> graph = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title class_">Array</span>(N + <span class="number">1</span>), <span class="function">() =&gt;</span> <span class="title class_">Array</span>(N + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">input.<span class="title function_">forEach</span>(<span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">  graph[array[<span class="number">0</span>]][array[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(graph);</span><br></pre></td></tr></table></figure><h1 id="▪︎-가중치-그래프"><a href="#▪︎-가중치-그래프" class="headerlink" title="▪︎ 가중치 그래프"></a>▪︎ 가중치 그래프</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/7601dc13-cef7-4d7a-9ced-03d1bd1acdd7/image.png" alt="image.png"></p><p><img src="https://velog.velcdn.com/images/vbghdl/post/afb6628e-d06b-437f-a4d0-b0c342c642e3/image.png" alt="image.png"></p><p>가중치 그래프는 노드끼리에 연결에 가중치가 붙어있는 구조입니다. 입력 데이터에 [1, 3, 3]과 같이 가중치에 대한 정보가 추가로 들어있습니다. 구현 방법은 위와 같으며 연결된 노드에 1이 아닌 가중치를 저장해주면 됩니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 가중치 무방향 그래프</span></span><br><span class="line"><span class="keyword">const</span> N = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> input1 = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> graph1 = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title class_">Array</span>(N + <span class="number">1</span>), <span class="function">() =&gt;</span> <span class="title class_">Array</span>(N + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">input1.<span class="title function_">forEach</span>(<span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">  graph1[array[<span class="number">0</span>]][array[<span class="number">1</span>]] = array[<span class="number">2</span>];</span><br><span class="line">  graph1[array[<span class="number">1</span>]][array[<span class="number">0</span>]] = array[<span class="number">2</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(graph1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 가중치 방향 그래프</span></span><br><span class="line"><span class="keyword">const</span> input2 = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> graph2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title class_">Array</span>(N + <span class="number">1</span>), <span class="function">() =&gt;</span> <span class="title class_">Array</span>(N + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">input2.<span class="title function_">forEach</span>(<span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">  graph2[array[<span class="number">0</span>]][array[<span class="number">1</span>]] = array[<span class="number">2</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(graph2);</span><br></pre></td></tr></table></figure><h1 id="▪︎-노드-개수가-많을-때"><a href="#▪︎-노드-개수가-많을-때" class="headerlink" title="▪︎ 노드 개수가 많을 때"></a>▪︎ 노드 개수가 많을 때</h1><p>노드의 개수가 적을 때에는 인접 행렬 데이터로 변환하여 문제를 풀 수 있지만, 노드의 개수가 많아질수록 그래프 크기가 커져 재귀의 동작이 많아져 문제를 푸는데 어려움이 생깁니다. 이럴 때는 인접행렬 대신 인접리스트를 사용하여 문제를 풀 수 있습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/f9ba602a-af2f-45a3-ba4d-bdfae53610aa/image.png" alt="image.png"></p><p>인접리스트에서는 graph의 행의 인덱스 만이 노드를 키값으로 의미를 지니게 되고, 열의 인덱스는 인접행렬과 달리 의미를 지니지 않습니다. 각 노드 행에 연결된 노드에 대한 정보를 push해주면 됩니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인접리스트</span></span><br><span class="line"><span class="keyword">const</span> N = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> input = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> graph = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title class_">Array</span>(N + <span class="number">1</span>), <span class="function">() =&gt;</span> <span class="title class_">Array</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">input.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  graph[el[<span class="number">0</span>]].<span class="title function_">push</span>(el[<span class="number">1</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(graph);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/">그래프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B0%B0%EC%97%B4-%EB%B3%80%ED%99%98/">배열 변환</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/03/25/algorithm/%EA%B7%B8%EB%9E%98%ED%94%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>재귀함수 ) 멍청한 내 동생도 이해시킨 자바스크립트 재귀함수 구현</title>
      <link>https://namgungjongmin.github.io/2024/03/20/algorithm/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/</link>
      <guid>https://namgungjongmin.github.io/2024/03/20/algorithm/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/</guid>
      <pubDate>Wed, 20 Mar 2024 07:32:32 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;▪︎-재귀-함수&quot;&gt;&lt;a href=&quot;#▪︎</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png"></p><h1 id="▪︎-재귀-함수"><a href="#▪︎-재귀-함수" class="headerlink" title="▪︎ 재귀 함수"></a>▪︎ 재귀 함수</h1><p>재귀 함수란 자기 자신을 호출하는 함수를 말합니다. 종료 조건이 충족될 때까지 반복적으로 자신을 호출하면서 주어진 동작을 수행합니다. 재귀 함수는 순회할 대상의 상태를 변경하면서 각 대상마다 비슷한 동작을 수행해야 할 때 효율적으로 사용할 수 있습니다.</p><p>[1, 2, 3, 4, 5, 6] 이라는 배열안의 모든 숫자의 합을 구하는 코드를 작성한다고 해보겠습니다. 이 경우 간단하게 배열을 for문으로 순회하는 것으로 풀이가 가능합니다.</p><p>[1, 2, 3, [1, 2, [4, 5], 3], 5, 6] 이러한 형태의 배열은 어떨까요? 3중 for문으로 배열들을 순회하면 가능할 것입니다. 그러나 문제에서 주어지는 입력값이 계속 바뀔 수 있고, 어느정도 중첩될지 예측할 수 없는 상황이라면 기존처럼 코드를 구현하기에는 한계가 있을 것입니다. 이 때 재귀함수를 사용하면 효율적이고 가독성있는 코드 작성이 가능합니다.</p><h2 id="▫︎-재귀-함수의-구성"><a href="#▫︎-재귀-함수의-구성" class="headerlink" title="▫︎ 재귀 함수의 구성"></a>▫︎ 재귀 함수의 구성</h2><p>재귀 함수는 크게 종료 조건과 실행할 동작으로 나누어 구성할 수 있습니다. 실행할 동작에서 주어진 데이터들을 가공하고 동작을 수행하면서 자기 자신을 계속 호출하다가 정해놓은 종료 조건에 다달았을 때 함수를 return하게 하는 것입니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">recursive</span> = (<span class="params">depth, ...</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>( 종료 조건 ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// depth별 실행할 동작</span></span><br><span class="line">  <span class="title function_">recursive</span>(depth+<span class="number">1</span>, ...)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">recursive</span>(<span class="number">1</span>, ...)</span><br></pre></td></tr></table></figure><h2 id="▫︎-재귀-함수의-depth"><a href="#▫︎-재귀-함수의-depth" class="headerlink" title="▫︎ 재귀 함수의 depth"></a>▫︎ 재귀 함수의 depth</h2><p>재귀 함수를 자바스크립트 코드로 처음 구현할 때, 코드의 동작을 따라가며 이해하는 것이 어렵습니다. 그러나 depth 개념을 적용하여 코드를 구현한다면 원활한 이해가 가능합니다. depth는 재귀 함수가 호출된 깊이, 즉 자신을 몇번째 호출했는지에 대한 데이터입니다.</p><p>순열과 조합을 예시로 지금까지의 내용들을 적용하여 재귀함수를 이해해보겠습니다.</p><h1 id="▪︎-카드를-뽑아보자"><a href="#▪︎-카드를-뽑아보자" class="headerlink" title="▪︎ 카드를 뽑아보자"></a>▪︎ 카드를 뽑아보자</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/a3d4d3dc-678b-41f8-aeb1-577b763694e2/image.png" alt="image.png"></p><h2 id="▫︎-순열"><a href="#▫︎-순열" class="headerlink" title="▫︎ 순열"></a>▫︎ 순열</h2><p>순열은 순서를 고려하여 카드들을 뽑는 방법입니다. 카드를 하나씩 뽑되, 뽑은 카드는 제외하고 남은 카드들 중에서 하나씩 뽑는 것을 반복하면 됩니다. 그러다가 원하는 개수의 카드를 뽑았을 때 동작을 멈추면 됩니다. 재귀를 사용하면 효율적인 이유는 카드를 뽑는 동작들이 모두 ‘주어진 배열들을 순회하며 하나를 선택한다’라는 같은 동작을 하기 때문입니다. 각 카드를 뽑는 동작, 몇 번째 카드를 뽑는 상황인지에 따라 depth가 부여됩니다. (첫 번째 카드를 뽑으면 depth 1 …)</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/7d8d03e1-e393-4e81-a4ee-00100ad54d93/image.png" alt="image.png"></p><p>이제 우리는 재귀 함수를 구현하기 위해 세가지만 고려하면 됩니다.</p><ol><li>종료 조건</li><li>시행할 동작</li><li>필요한 데이터</li></ol><ol><li><p>종료 조건은 우리가 카드를 3개 다 뽑았을 경우입니다. 따라서 3의 depth까지만 함수를 실행하고 재귀를 멈추면 됩니다.</p></li><li><p>시행할 동작은 남은 카드들 중 한개를 뽑는 것입니다. 카드 배열들을 for문으로 순회하면서 각 자리에 하나씩 넣어주면 됩니다.</p></li><li><p>필요한 데이터는 다음 세가지입니다. depth, 남은 카드들의 정보를 담은 배열, 뽑은 카드들의 배열</p></li></ol><p>위 정보를 바탕으로 처음 소개한 재귀 함수와 동일한 구성으로 코드를 구현해보면 다음과 같습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cards = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 순열</span></span><br><span class="line"><span class="keyword">const</span> answer = [];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">permutation</span> = (<span class="params">depth, leftCards, arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 종료 조건</span></span><br><span class="line">  <span class="keyword">if</span> (depth &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    answer.<span class="title function_">push</span>(arr);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// depth별 실행할 동작</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; leftCards.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> cardsArr = leftCards.<span class="title function_">filter</span>(<span class="function">(<span class="params">_, idx</span>) =&gt;</span> idx !== i); <span class="comment">// 다음에 뽑을 수 있는 카드들의 배열</span></span><br><span class="line">    <span class="title function_">permutation</span>(depth + <span class="number">1</span>, cardsArr, [...arr, leftCards[i]]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">permutation</span>(<span class="number">1</span>, cards, []);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(answer);</span><br></pre></td></tr></table></figure><h2 id="▫︎-조합"><a href="#▫︎-조합" class="headerlink" title="▫︎ 조합"></a>▫︎ 조합</h2><p>조합은 순서를 고려하지 않고 카드들을 뽑는 방법입니다. 뽑은 카드를 제외하고 다시 카드를 뽑되, 순서가 달라도 같은 카드들을 뽑으면 안되기 때문에 순회할 때 뽑은 카드 뒤쪽의 카드들만을 대상으로 합니다. 이외에는 순열과 같습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/c1a979e2-f25c-4090-834f-e176722b6787/image.png" alt="image.png"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cards = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 조합</span></span><br><span class="line"><span class="keyword">const</span> answer = [];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">combination</span> = (<span class="params">depth, leftCards, arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 종료 조건</span></span><br><span class="line">  <span class="keyword">if</span> (depth &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    answer.<span class="title function_">push</span>(arr);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// depth별 실행할 함수</span></span><br><span class="line">  <span class="keyword">if</span> (leftCards.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; leftCards.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> cardsArr = leftCards.<span class="title function_">slice</span>(i + <span class="number">1</span>); <span class="comment">// 다음에 뽑을 수 있는 카드들의 배열</span></span><br><span class="line">    <span class="title function_">combination</span>(depth + <span class="number">1</span>, cardsArr, [...arr, leftCards[i]]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">combination</span>(<span class="number">1</span>, cards, []);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(answer);</span><br></pre></td></tr></table></figure><h1 id="▪︎-Depth가-유동적이라면"><a href="#▪︎-Depth가-유동적이라면" class="headerlink" title="▪︎ Depth가 유동적이라면?"></a>▪︎ Depth가 유동적이라면?</h1><p>위에 설명한 depth 데이터는 재귀가 몇번째까지 타고 들어가며 실행되는지를 쉽게 이해하기 위해 추가한 개념입니다. depth 개념으로 순열과 조합을 구현해보면서 재귀의 동작에 대해 기본적인 이해가 생겼다면 depth에 기반한 재귀가 아닌 함수 그 자체가 데이터를 변동하며 스스로를 호출하는 경우를 생각해보겠습니다.</p><p>위의 depth를 이용한 재귀 함수의 구현은 모든 상황에서 사용할 수는 없습니다. 예를들어 얼만큼 함수를 다시 호출할지가 정해지지 않은 문제의 경우가 그렇습니다. 위의 예시에서는 ‘5장 중 3장의 카드를 뽑는다’ 였지만, 만약 숫자가 적힌 5장의 카드 중 임의의 수의 카드를 뽑아 손안의 카드와 남은 카드를 비교하는 문제에서는 depth를 기준으로 하여 재귀 함수를 호출할 수 없습니다. 아래 문제를 살펴보겠습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/af2cb58f-e093-48d0-85ce-c5422c8dabbc/image.png" alt="image.png"></p><p>이 문제에서 필요한 정보는 각 부분집합의 경우들과 그와 매치되는 남은 원소들입니다. 위 카드 예시에 대입해보자면 임의의 개수의 카드를 뽑아 순서에 상관하지 않고 뽑는 경우(조합)와 같습니다. 따라서 depth가 아닌 다른 데이터들을 바탕으로 함수를 구성해야 합니다.</p><p>임의의 개수의 원소를 뽑는다는 것은 0개 ~ 모든 원소의 개수까지를 뽑아본다는 것입니다. 따라서 조합을 실행하며 선택된 원소의 이전 원소들은 제외하고 남은 원소들의 수가 0이 될 때 함수를 종료하면 될 것 같습니다. 또한 문제를 푸는데 필요한 정보인 각 부분집합, 즉 뽑은 원소들의 배열과 그에 매칭된 남은 원소들이므로 이 둘을 데이터로하여 재귀 함수를 구성하면 문제를 풀 수 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> answer = <span class="string">&quot;NO&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr1 = [];</span><br><span class="line"><span class="keyword">let</span> arr2 = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">recursive</span> = (<span class="params">leftArr, picks</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (leftArr.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; leftArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> newArr = [...picks, leftArr[i]]; <span class="comment">// 전체 배열에서 뽑을 수 있는 (남아있는) 카드들</span></span><br><span class="line">    <span class="title function_">recursive</span>(leftArr.<span class="title function_">slice</span>(i + <span class="number">1</span>), newArr); <span class="comment">// i번째 카드를 뽑았다면 i 이후의 카드들이 남아있게 된다.</span></span><br><span class="line">    arr1.<span class="title function_">push</span>(newArr);</span><br><span class="line">    arr2.<span class="title function_">push</span>(arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> !newArr.<span class="title function_">includes</span>(el)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">recursive</span>(arr, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr1.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr1[i].<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, <span class="number">0</span>) === arr2[i].<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, <span class="number">0</span>)) answer = <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(answer);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/">재귀함수</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/03/20/algorithm/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>그리디 ) 현재의 최적의 선택을 미래의 최적의 선택으로</title>
      <link>https://namgungjongmin.github.io/2024/03/11/algorithm/%EA%B7%B8%EB%A6%AC%EB%94%94/</link>
      <guid>https://namgungjongmin.github.io/2024/03/11/algorithm/%EA%B7%B8%EB%A6%AC%EB%94%94/</guid>
      <pubDate>Mon, 11 Mar 2024 08:42:22 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;▪︎-그리디-알고리즘&quot;&gt;&lt;a href=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png"></p><h1 id="▪︎-그리디-알고리즘"><a href="#▪︎-그리디-알고리즘" class="headerlink" title="▪︎ 그리디 알고리즘"></a>▪︎ 그리디 알고리즘</h1><p>그리디 알고리즘은 미래를 고려하지 않고, 오직 현재 시점에 가장 좋은 선택을 하는 알고리즘입니다. 현재의 선택이 미래에 어떤 영향을 미칠지는 고려하지 않고, 무조건 현재 가장 빠른 선택, 가장 가치있는 선택을 내리게됩니다. 현실에서는 모든 경우를 고려하면 리소스가 너무 크고, 당장의 최적의 결과만을 쫓는다 하더라도 미래에 (최적의 결과는 아니지만) 어느 정도 보장된 결과를 내고 싶을 때 사용되는 알고리즘입니다.</p><p>그러나 코딩테스트에서 우리는 모든 케이스에 적용되는, 항상 최적의 결과가 되는 답을 찾아내야 합니다. 따라서 현재의 최적의 답이 미래의 최적의 답이 되는 상태에서만 적용할 수 있습니다.</p><h2 id="▫︎-그리디-알고리즘을-적용할-수-있는-경우"><a href="#▫︎-그리디-알고리즘을-적용할-수-있는-경우" class="headerlink" title="▫︎ 그리디 알고리즘을 적용할 수 있는 경우"></a>▫︎ 그리디 알고리즘을 적용할 수 있는 경우</h2><ol><li>현재의 선택이 미래의 선택에 영향을 주지 않는다. (탐욕스러운 선택 조건)</li><li>부분의 최적해가 모이면 전체의 최적해가 된다.</li></ol><p><img src="https://velog.velcdn.com/images/vbghdl/post/897e905f-09ac-4b1f-9087-0228e6c1c9c2/image.png" alt="image.png"></p><p>500원, 100원, 10원 짜리 동전들을 위 그림과 같이 가지고 있다고 할 때, 동전을 가장 적게 사용하면서 2120원을 만드는 방법을 고민해봅시다.</p><p>그리디 알고리즘에 따라 동전을 선택한다면 가장 큰 액수의 동전을 선택하는 것이 현재 상황에서 가장 적은 개수로 2120원에 가까워지는 방법입니다. 이 때 (1) 지금 내가 500원을 선택한 것 때문에 미래에 100원 대신 10원을 선택해야만 경우나 10원 대신 100원을 선택해야만 하는 경우는 없습니다. 또한 (2) 각 동전을 선택하는 시점에서, 남은 액수를 넘지 않는 동전 중 가장 큰 액수의 동전을 선택하면 가장 적은 동전의 수로 2120원을 맞출 수 있습니다.</p><p>대부분의 코딩테스트 경우에서 그리디 알고리즘의 적용은 주어진 데이터를 “각 판단의 시점마다 동일한 동작으로 최적해를 찾을 수 있도록 설정”하고 “예외 조건을 찾아 처리”해주는 형태로 코드를 작성하게 됩니다. 따라서 대부분의 케이스에서 그리디 문제의 핵심은 데이터의 정렬로 볼 수 있습니다. 주어진 데이터를 정렬할 수 있는 여러 방법들을 우선적으로 고려해봅니다.</p><h1 id="▪︎-Example-of-Apply-1"><a href="#▪︎-Example-of-Apply-1" class="headerlink" title="▪︎ Example of Apply 1"></a>▪︎ Example of Apply 1</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/402330a9-c43a-4c40-bb57-25d641d04470/image.png" alt="image.png"></p><ul><li><a href="https://www.acmicpc.net/problem/1931">https://www.acmicpc.net/problem/1931</a></li></ul><p>위 문제는 겹치지 않고 진행할 수 있는 최대 회의 수를 출력하는 문제입니다. 직관적으로 볼 때 가장 많은 회의를 진행하기 위해서는 가장 빨리 끝나는 회의를 먼저 처리하면 남은 시간이 많아지기 때문에 정답에 가까울 것 같습니다.</p><ol><li>데이터 설정) 입력받은 배열 데이터들의 인덱스 1 을 기준으로 오름차순 정렬합니다. 이 때 인덱스 1의 값이 같은 경우 인덱스 0의 값이 더 작은 (빨리 시작하는) 데이터를 우선합니다.</li><li>예외 조건 처리) 정렬한 데이터를 순차적으로 순회하며 카운팅하되, 아직 이전 회의가 진행중이라면 카운팅하지 않습니다.</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;dev/stdin&quot;</span>).<span class="title function_">toString</span>().<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> arr = input.<span class="title function_">slice</span>(<span class="number">1</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> el.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>));</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (a[<span class="number">1</span>] === b[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> prev = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> answer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">[start, end]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (prev &lt;= start) &#123;</span><br><span class="line">    answer++;</span><br><span class="line">    prev = end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(answer);</span><br></pre></td></tr></table></figure><h1 id="▪︎-Example-of-Apply-2"><a href="#▪︎-Example-of-Apply-2" class="headerlink" title="▪︎ Example of Apply 2"></a>▪︎ Example of Apply 2</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/5c22b7f5-dea9-48c2-b6ce-d2dd1ba5496a/image.png" alt="image.png"></p><p><img src="https://velog.velcdn.com/images/vbghdl/post/353eb72a-bc62-41f5-9203-3502b0fef543/image.png" alt="image.png"></p><ul><li><a href="https://www.acmicpc.net/problem/11000">https://www.acmicpc.net/problem/11000</a></li></ul><p>이번 문제는 모든 회의가 가능하도록 하는 강의실의 개수를 출력하는 문제입니다. 현재 진행중인 강의의 개수를 추적하고, 지금까지 동시에 진행된 강의가 가장 많을 때마다 정답을 업데이트해주면 풀 수 있을 것 같습니다. 강의의 개수를 추적하는 방법은 강의가 시작되고 끝나는 시간에 값을 부여하여 시간마다 그 값을 더해주면 됩니다. 그렇게 타임 테이블을 만들고 오름차순 정렬하여 데이터를 순회하면 정답을 도출할 수 있습니다.</p><p>타임테이블을 배열로하여 인덱스를 시간으로 추상화하는 방법은 Si, Ti의 최대값이 10^9 이므로 메모리 초과가 뜰 것 같습니다. 따라서 입력받은 데이터들에 저장된 시간들을 O(1)의 시간 복잡도로 조작가능한 Map 함수에서 key : value 형태로 관리하겠습니다. 각 시간에 시작하는 회의가 있을 때 +1, 끝나는 회의가 있을 때 -1을 하면서 시간단위로 강의실 개수를 추적합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;dev/stdin&quot;</span>).<span class="title function_">toString</span>().<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> arr = input.<span class="title function_">slice</span>(<span class="number">1</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> el.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>));</span><br><span class="line"><span class="keyword">const</span> timeTable = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타임테이블 생성</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  timeTable.<span class="title function_">set</span>(arr[i][<span class="number">0</span>], timeTable.<span class="title function_">get</span>(arr[i][<span class="number">0</span>]) ? timeTable.<span class="title function_">get</span>(arr[i][<span class="number">0</span>]) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">  timeTable.<span class="title function_">set</span>(arr[i][<span class="number">1</span>], timeTable.<span class="title function_">get</span>(arr[i][<span class="number">1</span>]) ? timeTable.<span class="title function_">get</span>(arr[i][<span class="number">1</span>]) - <span class="number">1</span> : -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타임테이블 정렬</span></span><br><span class="line"><span class="keyword">const</span> answerArr = <span class="title class_">Array</span>.<span class="title function_">from</span>(timeTable).<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">let</span> answer = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> lectures = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타임테이블 순회</span></span><br><span class="line">answerArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  lectures += el[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (lectures &gt; answer) answer = lectures;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(answer);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B7%B8%EB%A6%AC%EB%94%94/">그리디</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/03/11/algorithm/%EA%B7%B8%EB%A6%AC%EB%94%94/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>정렬 ) O(N^2)의 대표적인 정렬 방법</title>
      <link>https://namgungjongmin.github.io/2024/03/07/algorithm/%EC%A0%95%EB%A0%AC/</link>
      <guid>https://namgungjongmin.github.io/2024/03/07/algorithm/%EC%A0%95%EB%A0%AC/</guid>
      <pubDate>Thu, 07 Mar 2024 03:42:44 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이번 포스트에서는 정렬 알</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png"></p><blockquote><p>이번 포스트에서는 정렬 알고리즘의 가장 기본이 되는 세 가지의 알고리즘을 알아보고 같은 문제를 각각의 알고리즘을 적용하여 풀이해보겠습니다. O(n^2)의 시간복잡도를 가지는 효율이 낮은 정렬 방법들이지만, 코딩테스트 문제의 시간 조건이 충분할 때 간단하게 구현할 수 있습니다.</p></blockquote><h1 id="▪︎-선택-정렬"><a href="#▪︎-선택-정렬" class="headerlink" title="▪︎ 선택 정렬"></a>▪︎ 선택 정렬</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/0b922ac7-1511-4d62-bb81-03ce00f98da2/image.png" alt="Untitled"></p><p>선택 정렬은 배열의 모든 요소를 비교하여 해당되는 위치에 요소를 삽입함으로써 정렬을 완성하는 알고리즘입니다.</p><ol><li>첫 요소를 기준삼아 시작합니다.</li><li>배열에서 최솟값을 찾아 첫 요소와 교환합니다.</li><li>두 번째 요소부터 시작해 최솟값을 찾아 두 번째 요소와 교환합니다.</li><li>2의 과정을 매 위치에서 반복합니다.</li></ol><h1 id="▪︎-삽입-정렬"><a href="#▪︎-삽입-정렬" class="headerlink" title="▪︎ 삽입 정렬"></a>▪︎ 삽입 정렬</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/4f3f8406-d792-4914-a75a-9e06f078a8cd/image.png" alt="Untitled"></p><p>삽입 정렬은 매 순서마다 해당 요소를 삽입할 위치를 찾아 정렬을 완성하는 알고리즘입니다.</p><ol><li>정렬되지 않은 첫 요소를 목표로 진행합니다.</li><li>두 번째 요소가 첫 번째 요소보다 작다면 자리를 교환합니다.</li><li>세 번째 요소와 두 번째 요소를 비교하여 교환하고, 교환했다면 그 이전 요소와 다시 비교 &#x2F; 두 번째 요소보다 크다면 네 번째 요소로 넘어갑니다.</li><li>2의 과정을 매 위치에서 반복합니다.</li></ol><h1 id="▪︎-버블-정렬"><a href="#▪︎-버블-정렬" class="headerlink" title="▪︎ 버블 정렬"></a>▪︎ 버블 정렬</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/13664fbe-8031-4527-bc60-650aadbbe08b/image.png" alt="Untitled"></p><p>버블 정렬은 인접한 두 요소를 비교하여 정렬하는 알고리즘입니다. 가장 큰 요소부터 마지막 인덱스에 위치시키기 때문에 요소의 이동이 마치 거품이 수면으로 올라오는 듯한 모습을 보입니다.</p><ol><li>정렬되지 않은 마지막 요소를 목표로 진행합니다.</li><li>첫 요소와 다음 요소를 비교 첫 요소가 크다면 두 번째 요소와 자리를 교환합니다.</li><li>두 번째 요소와 그 다음 요소를 비교 두 번째 요소가 크다면 세 번째 요소와 자리를 교환합니다.</li><li>동작을 반복하면 마지막 요소에 배열의 가장 큰 값이 위치하게 됩니다.</li><li>이후 1-3 과정을 반복합니다.</li></ol><h1 id="▪︎-문제-적용"><a href="#▪︎-문제-적용" class="headerlink" title="▪︎ 문제 적용"></a>▪︎ 문제 적용</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/5fed9f67-2632-4b68-8d0f-46e5170ba6c9/image.png" alt="Untitled"></p><h2 id="▫︎-선택-정렬-풀이"><a href="#▫︎-선택-정렬-풀이" class="headerlink" title="▫︎ 선택 정렬 풀이"></a>▫︎ 선택 정렬 풀이</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> answer = [...arr];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (answer[i] &lt;= answer[j]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      [answer[i], answer[j]] = [answer[j], answer[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="▫︎-삽입-정렬-풀이"><a href="#▫︎-삽입-정렬-풀이" class="headerlink" title="▫︎ 삽입 정렬 풀이"></a>▫︎ 삽입 정렬 풀이</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> answer = [...arr];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; answer.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (answer[j] &lt; answer[j - <span class="number">1</span>]) [answer[j], answer[j - <span class="number">1</span>]] = [answer[j - <span class="number">1</span>], answer[j]];</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="▫︎-버블-정렬-풀이"><a href="#▫︎-버블-정렬-풀이" class="headerlink" title="▫︎ 버블 정렬 풀이"></a>▫︎ 버블 정렬 풀이</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> answer = [...arr];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.<span class="property">length</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (answer[j] &lt;= answer[j + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      [answer[j], answer[j + <span class="number">1</span>]] = [answer[j + <span class="number">1</span>], answer[j]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%A0%95%EB%A0%AC/">정렬</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%AC/">선택정렬</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%82%BD%EC%9E%85%EC%A0%95%EB%A0%AC/">삽입정렬</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B2%84%EB%B8%94%EC%A0%95%EB%A0%AC/">버블정렬</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/03/07/algorithm/%EC%A0%95%EB%A0%AC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>해시 ) KEY 값에 문자열을 부여해 데이터를 저장하는 방법</title>
      <link>https://namgungjongmin.github.io/2024/03/02/algorithm/%ED%95%B4%EC%8B%9C/</link>
      <guid>https://namgungjongmin.github.io/2024/03/02/algorithm/%ED%95%B4%EC%8B%9C/</guid>
      <pubDate>Sat, 02 Mar 2024 13:42:24 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;코딩 테스트 문제 중에 데</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png"></p><blockquote><p>코딩 테스트 문제 중에 데이터를 순회화며 결과를 키 값에 저장해야 할 때가 있습니다. 배열의 인덱스처럼 의미를 부여하여 사용하는 것이 아닌 의미를 지닌 키 값에 직접적으로 데이터를 매칭시킬 수 있는 방법이며, 검색에서의 시간복잡도 또한 O(1)로 효율적인 알고리즘입니다.</p></blockquote><h1 id="▪︎-해시-알고리즘-Hash"><a href="#▪︎-해시-알고리즘-Hash" class="headerlink" title="▪︎ 해시 알고리즘 (Hash)"></a>▪︎ 해시 알고리즘 (Hash)</h1><p>기본적으로 배열에 key: value 값으로 데이터를 저장하면 구현이 가능합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hashArray = [];</span><br><span class="line"></span><br><span class="line">hashArray[<span class="string">&quot;bus&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">hashArray[<span class="string">&quot;price&quot;</span>] = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hashArray[<span class="string">&quot;bus&quot;</span>]); <span class="comment">// output: 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hashArray); <span class="comment">// output: [ &quot;bus&quot;: 5, &quot;price&quot;: 1000 ]</span></span><br></pre></td></tr></table></figure><p>자바스크립트의 배열은 다른 언어의 배열과는 다릅니다. 다른 언어의 경우는 데이터가 연속적으로 나열되어 구성되는 밀집 배열이고, 자바스크립트는 희소 배열입니다. 즉 여러 개의 자료형을 허락하며 각 자료가 차지하는 메모리 공간 또한 불규칙 할 수 있습니다. 때문에 위의 방식으로도 배열을 만들 수가 있습니다.</p><p>그러나 자바스크립트에서는 더 쉽게 테이블을 사용할 수 있게하는 Map이라는 내장 함수가 있습니다. Map에서 제공되는 여러 프로토타입 메서드를 활용하면 해시 구조에서 원하는 기능을 보다 쉽게 사용할 수 있습니다.</p><h2 id="▫︎-Map-함수의-여러-메서드"><a href="#▫︎-Map-함수의-여러-메서드" class="headerlink" title="▫︎ Map 함수의 여러 메서드"></a>▫︎ Map 함수의 여러 메서드</h2><ol><li>new Map() : 새로운 Map 객체를 만듭니다.</li><li>map.set(key, value) : Map 객체 내의 key와 value를 매핑하여 저장합니다.</li><li>map.get(key) : Map 객체에서 key에 해당하는 value를 반환합니다.</li><li>map.has(key) : Map 객체 내에 key가 존재한다면 true, 존재하지 않는다면 false를 반환합니다.</li><li>map.delete(key) : Map 객체 내에서 key와 매핑된 value 모두를 삭제합니다.</li><li>map.size : Map 객체의 요소 수를 반환합니다.</li><li>map.forEach(callbackFn(key, value)) : 각 value와 key마다 callbackFn을 삽입한 순서대로 실행합니다.</li></ol><h1 id="▪︎-Example-of-Apply-1"><a href="#▪︎-Example-of-Apply-1" class="headerlink" title="▪︎ Example of Apply 1"></a>▪︎ Example of Apply 1</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/a6f8e97b-881b-494c-8c68-123a2544cbc3/image.png" alt="Untitled"></p><h2 id="▫︎-문제-접근"><a href="#▫︎-문제-접근" class="headerlink" title="▫︎ 문제 접근"></a>▫︎ 문제 접근</h2><ol><li>각 후보에 대한 데이터를 생성한다.</li><li>각 후보가 투표를 받을 때마다 데이터를 갱신한다.</li><li>가장 큰 값을 가진 후보를 출력합니다.</li></ol><p>위 문제에서 후보에 대한 정보를 저장할 때 key 값으로 후보를 지정하는 것이 좋아보입니다. ( 배열의 index에 의미를 부여하여 사용할 수 있지만 가독성이 좋지 않습니다.) Map 객체를 만들고 각 key 값으로 후보를 등록한 뒤 주어진 개표 결과를 순회하며 value를 업데이트 시켜주면 쉽게 풀 수 있습니다. 이후에는 map.forEach 메서드를 통해 Map 객체를 순회하며 가장 높은 value를 지닌 key를 답으로 등록합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> answer = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> arr = s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> map.<span class="title function_">set</span>(el, map.<span class="title function_">get</span>(el) + <span class="number">1</span> || <span class="number">1</span>));</span><br><span class="line">  map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; max) &#123;</span><br><span class="line">      answer = key;</span><br><span class="line">      max = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="▪︎-Example-of-Apply-2"><a href="#▪︎-Example-of-Apply-2" class="headerlink" title="▪︎ Example of Apply 2"></a>▪︎ Example of Apply 2</h1><blockquote><p>첫 번째 예시 문제가 key : value 형태로 데이터를 저장하기 위해 Map을 사용했다면, 이번 예시는 key에 접근할 때 효율성을 높여 시간복잡도를 줄이기 위해 적용하는 문제 예시를 보겠습니다.</p></blockquote><p><img src="https://velog.velcdn.com/images/vbghdl/post/3f079d73-7378-4a1e-a5e6-3bba18b0f2e1/image.png" alt="image.png"></p><p><img src="https://velog.velcdn.com/images/vbghdl/post/5607d50a-c95e-43a8-850c-0bc8f91c76e2/image.png" alt="image.png"></p><ul><li><a href="https://www.acmicpc.net/problem/1920">https://www.acmicpc.net/problem/1920</a></li></ul><p>위 문제는 [4, 1, 5, 2, 3] &#x2F; [1, 3, 7, 9, 5] 두 배열을 순회하여 겹치는지 확인만하면 되는 간단한 문제입니다. 그런데 N의 입력값 범위를 살펴보면</p><p>1 ≤ N ≤ 100,000 으로 이중 순회로 구현하여 O(n^2)의 시간복잡도로 풀 경우, 시간 제한에 걸리게 됩니다. Map 내장 함수의 경우 key에 접글할 때 O(1)의 시간복잡도를 가지기 때문에 하나의 배열을 Map으로 만들고 나머지 배열 하나를 순회하며 Map에 key 값이 있는지 여부만 판단하면 조건에 맞게 풀 수 있습니다.</p><ul><li>이중 순회로 구현 (시간 초과)</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> input = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;dev/stdin&quot;</span>).<span class="title function_">toString</span>().<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> N = input[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> +v);</span><br><span class="line"><span class="keyword">const</span> M = input[<span class="number">3</span>].<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> +v);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; M.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  N.<span class="title function_">includes</span>(M[i]) ? <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>) : <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>array.prototype.includes() 메서드는 O(N)의 시간복잡도를 가진다.</li><li>Map 함수 적용하여 구현 (조건 통과)</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> input = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;dev/stdin&quot;</span>).<span class="title function_">toString</span>().<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> N = input[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> +v);</span><br><span class="line"><span class="keyword">const</span> M = input[<span class="number">3</span>].<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> +v);</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">N.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> map.<span class="title function_">set</span>(el, <span class="literal">true</span>));</span><br><span class="line">M.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> (map.<span class="title function_">has</span>(el) ? <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>) : <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>)));</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%95%B4%EC%8B%9C/">해시</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/03/02/algorithm/%ED%95%B4%EC%8B%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>이진 검색 ) 10억번의 시행 횟수를 단 30번의 시행으로</title>
      <link>https://namgungjongmin.github.io/2024/02/28/algorithm/%EC%9D%B4%EC%A7%84%EA%B2%80%EC%83%89/</link>
      <guid>https://namgungjongmin.github.io/2024/02/28/algorithm/%EC%9D%B4%EC%A7%84%EA%B2%80%EC%83%89/</guid>
      <pubDate>Wed, 28 Feb 2024 05:41:44 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;코딩테스트 문제에서 주어진</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png"></p><blockquote><p>코딩테스트 문제에서 주어진 데이터들을 순회할 때, 답을 찾기 위해 직접적으로 순회하면 시간 조건을 초과하는 경우가 있습니다. 이 때 시간 복잡도를 줄이기 위해 투 포인터와 이진 검색을 고려합니다. 두 개의 포인터로 정답 도출이 가능할 것 같을 때에 투 포인터 알고리즘을 적용하고, 불가능 할 때에는 이진 검색을 적용합니다.</p></blockquote><h1 id="▪︎-이진-검색"><a href="#▪︎-이진-검색" class="headerlink" title="▪︎ 이진 검색"></a>▪︎ 이진 검색</h1><p>이진 검색은 오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘입니다. 탐색 범위를 절반씩 줄여나가면서 값을 찾기 때문에 빠른 속도를 보장합니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/9dc74621-e920-484d-95fb-1baf5db7746a/image.png" alt="Untitled"></p><p>위 배열에서 121이라는 숫자가 몇 번째 index에 있는지를 도출해야한다고 생각해봅시다. index 0부터 순회하며 121을 찾을 수 있지만 배열의 범위를 보면 121이 아닌 더 큰 값이 입력으로 들어왔을 경우 최악의 경우 10^9 번의 동작을 순회해야 합니다. 완전 탐색 포스팅에서 확인했듯이 코딩 테스트에서 우리는 10^8 안으로 시행 횟수를 기준으로 생각하기 때문에 이 방법은 불가능 합니다.</p><p>그러면 이진 검색을 활용하면 어떨까요? 최악의 경우에도 30번의 시행만으로 답을 찾아낼 수 있습니다.</p><h2 id="▫︎-이진-검색-구현"><a href="#▫︎-이진-검색-구현" class="headerlink" title="▫︎ 이진 검색 구현"></a>▫︎ 이진 검색 구현</h2><ol><li>인덱스의 최소값 &#x2F; 최대값을 변수로 선언합니다.</li><li>범위 내 중간값을 지닌 인덱스에 위치한 요소를 판단하여 121보다 크다면 최대값을 줄여 범위를 좁히고, 작다면 최소값을 높여 범위를 좁힙니다.</li><li>121을 도출할 때까지 2번의 과정을 반복합니다.</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> end = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">let</span> answer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">  <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((start + end) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (array[mid] &lt;= <span class="number">121</span>) &#123;</span><br><span class="line">    answer = mid;</span><br><span class="line">    start = mid + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> end = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기본적인 구현 방법은 위와 같고, 도출할 값의 특성에 따라 조금씩 바뀔 수 있습니다. 예를 들어 어떠한 조건에 맞는 최소값을 찾아야 한다면 도출되는 값은 여러개가 될 것이므로 계속 해서 답을 업데이트해야 합니다. 이 때 어떠한 조건문에 답을 업데이트 하는 로직을 추가할지 잘 생각해야 합니다. 위 이진 검색의 구현 코드는 ‘기본적으로 이렇게 작성된다’라고 생각하며 넘어가고 실제 문제 풀이를 통해 어떤식으로 코드가 작성되고 진행되는지 살펴보겠습니다.</p><h2 id="▫︎-최소-x2F-최대값-도출하기"><a href="#▫︎-최소-x2F-최대값-도출하기" class="headerlink" title="▫︎ 최소 &#x2F; 최대값 도출하기"></a>▫︎ 최소 &#x2F; 최대값 도출하기</h2><p>때때로 코딩테스트에서 범위에 속하는 값들 중 최소 &#x2F; 최대값을 찾아야하는 경우도 있습니다. 이 경우 위 코드를 조금 변형하여 풀어낼 수 있습니다. 이 때 answer에 mid값을 할당하는 코드의 위치가 중요합니다. 최소값을 구할 때는 end값을 조정할 때 answer값을 재할당 해야하고, 최대값을 구할 때는 start값을 조정할 때 answer를 재할당 해야합니다. 밑에 작성할 문제 풀이를 통해 확인해봅시다.</p><h1 id="▪︎-Example-of-Apply"><a href="#▪︎-Example-of-Apply" class="headerlink" title="▪︎ Example of Apply"></a>▪︎ Example of Apply</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/99dfef51-7ab0-4432-add4-84111d2cfa56/image.png" alt="Untitled"></p><p>모든 문제에서 처음 완전 탐색이 가능한지부터 생각합니다. 위 문제에서는 N 과 M에 따라 데이터를 몇번이나 순회할지 결정되어집니다. 입력 설명을 볼 때 N의 범위가 1000보다 작습니다. M에 따라 최악의 경우 1000개를 순회하면서 각 요소들을 어떤 DVD에 넣을지를 분기한다면, 시행 횟수는 2^8을 가볍게 넘을 것입니다. 따라서 이진 검색을 통해 나올 수 있는 정답의 범위를 정하고 조건에 부합하는 값 중 최소값을 찾아보겠습니다.</p><h2 id="▫︎-문제-접근"><a href="#▫︎-문제-접근" class="headerlink" title="▫︎ 문제 접근"></a>▫︎ 문제 접근</h2><ol><li>한 노래를 쪼개서 두 개의 DVD에 녹화할 수 없기 때문에, 용량 크기는 최소한 주어진 배열의 요소 중 최대값보다는 커야한다.</li><li>모두 한 DVD에 넣는 경우보다 용량이 커질 경우는 없다. 따라서 곡의 길이를 전부 합한 값이 최대값이다.</li><li>이진 검색을 통해 조건을 판별한다.</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">m, arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> answer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="title class_">Math</span>.<span class="title function_">max</span>(...arr);</span><br><span class="line">  <span class="keyword">let</span> end = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">ceil</span>((start + end) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sum + x &lt;= mid) sum += x;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (sum + x &gt; mid) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        sum = x;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &lt;= m) &#123;</span><br><span class="line">      end = mid - <span class="number">1</span>;</span><br><span class="line">      answer = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; m) start = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%9D%B4%EC%A7%84%EA%B2%80%EC%83%89/">이진검색</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/">이진탐색</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/02/28/algorithm/%EC%9D%B4%EC%A7%84%EA%B2%80%EC%83%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>투 포인터 ) 이중 순회가 시간 제한에 걸릴 때 고려해볼 알고리즘</title>
      <link>https://namgungjongmin.github.io/2024/02/21/algorithm/%ED%88%AC%ED%8F%AC%EC%9D%B8%ED%84%B0/</link>
      <guid>https://namgungjongmin.github.io/2024/02/21/algorithm/%ED%88%AC%ED%8F%AC%EC%9D%B8%ED%84%B0/</guid>
      <pubDate>Wed, 21 Feb 2024 01:31:13 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;코딩테스트에서 배열을 순회</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png"></p><blockquote><p>코딩테스트에서 배열을 순회해야 할 때, 입력값의 조건이 시간 제한에 걸려 단순 순회가 불가능한 경우가 있습니다. 이 때 고려해야할 알고리즘은 ‘투포인터’ 와 ‘이분 탐색’ 입니다. 이 포스팅은 투포인터 알고리즘을 통해 해당 문제를 해결하는 방법을 다루고 있습니다.</p></blockquote><h1 id="▪︎-투-포인터-알고리즘-Two-Pointer"><a href="#▪︎-투-포인터-알고리즘-Two-Pointer" class="headerlink" title="▪︎ 투 포인터 알고리즘 (Two-Pointer)"></a>▪︎ 투 포인터 알고리즘 (Two-Pointer)</h1><p>투 포인터 알고리즘은 주어진 배열에서 각각 다른 원소를 가리키는 2개의 포인터를 조작하면서 원하는 값을 도출할 때까지 탐색하는 알고리즘입니다. 각 포인터들의 위치를 정하고 이동하면서 포인트의 위치를 기록하고 처리합니다.</p><h2 id="▫︎-시간-복잡도"><a href="#▫︎-시간-복잡도" class="headerlink" title="▫︎ 시간 복잡도"></a>▫︎ 시간 복잡도</h2><p>순회마다 항상 두 포인터 중 하나는 1씩 증가합니다. 각 포인터는 최대 N까지 증가할 수 있습니다. 기존 배열의 순회에서는 2중 for문을 통해 두 지점을 특정해야하기 때문에 O(N^2)의 시간 복잡도를 지닌 반면, 투포인터 알고리즘을 사용하게 되면 한번의 단순 순회를 통해 포인트들을 이동하면서 처리하기 때문에 O(N)의 시간 복잡도로 문제를 해결할 수 있습니다.</p><h1 id="▪︎-Example-of-Apply"><a href="#▪︎-Example-of-Apply" class="headerlink" title="▪︎ Example of Apply"></a>▪︎ Example of Apply</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/3b5a5e6f-c79c-4544-948f-361d1fea8540/image.png" alt="Untitled"></p><h2 id="▫︎-문제-접근"><a href="#▫︎-문제-접근" class="headerlink" title="▫︎ 문제 접근"></a>▫︎ 문제 접근</h2><p>문제 해결을 위한 스텝을 나눠보면 다음과 같습니다.</p><ol><li>공통 원소를 찾는다.</li><li>오름차순으로 출력한다.</li></ol><p>1번을 해결하기 위한 가장 쉬운 방법은 두 배열 중 하나를 순회하면서 나머지 배열에 현재 인덱스의 요소들이 있는지 판별하는 것입니다. 이후 판별된 요소들만 오름차순으로 정리하면 다음과 같이 풀이할 수 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> answer = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr1.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr2.<span class="title function_">includes</span>(arr1[i])) answer.<span class="title function_">push</span>(arr1[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(answer.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)); <span class="comment">// output: [2,3,5]</span></span><br></pre></td></tr></table></figure><p>그러나 입력값을 기준으로 시간 복잡도를 판단해보면 O(N^2)의 시간복잡도를 가진 위 코드는 최악의 경우 10^8 이내의 실행되지 못하는 코드입니다. 따라서 O(N)의 시간 복잡도로 해당 문제를 해결해야 합니다.</p><h2 id="▫︎-투-포인터-알고리즘으로-접근"><a href="#▫︎-투-포인터-알고리즘으로-접근" class="headerlink" title="▫︎ 투 포인터 알고리즘으로 접근"></a>▫︎ 투 포인터 알고리즘으로 접근</h2><ol><li>주어진 배열들을 정렬한다.</li><li>각 배열의 첫 인덱스 요소를 포인터로 가리킨다. (p1, p2)</li><li>p1 인덱스 요소와 p2 인덱스 요소를 비교하며 같다면 answer array에 추가하고 다르다면 p2를 이동한다. 이 때 p2가 p1보다 크다면 p1의 위치를 이동시킨다.</li></ol><h2 id="▫︎-풀이"><a href="#▫︎-풀이" class="headerlink" title="▫︎ 풀이"></a>▫︎ 풀이</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">arr1, arr2</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> answer = [];</span><br><span class="line">  <span class="keyword">let</span> p1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> p2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  arr1.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  arr2.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (p1 &lt; arr1.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr1[p1] === arr2[p2]) &#123;</span><br><span class="line">      answer.<span class="title function_">push</span>(arr1[p1++]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1 &lt; p2) &#123;</span><br><span class="line">      p1++;</span><br><span class="line">      p2 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%88%AC%ED%8F%AC%EC%9D%B8%ED%84%B0/">투포인터</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/02/21/algorithm/%ED%88%AC%ED%8F%AC%EC%9D%B8%ED%84%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>누적합 ) 배열의 누적합을 처리하여 구간합을 알아내기</title>
      <link>https://namgungjongmin.github.io/2024/02/17/algorithm/%EB%88%84%EC%A0%81%ED%95%A9/</link>
      <guid>https://namgungjongmin.github.io/2024/02/17/algorithm/%EB%88%84%EC%A0%81%ED%95%A9/</guid>
      <pubDate>Sat, 17 Feb 2024 10:11:11 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;▪︎-누적합-알고리즘&quot;&gt;&lt;a href=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png"></p><h1 id="▪︎-누적합-알고리즘"><a href="#▪︎-누적합-알고리즘" class="headerlink" title="▪︎ 누적합 알고리즘"></a>▪︎ 누적합 알고리즘</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/ced1c26e-def1-4e96-9dfb-23e08916bed5/image.png" alt="image.png"></p><p>누적합 알고리즘은 이전 누적합에 대해 현재 인덱스의 값을 더하여 구하는 방법입니다. 기본적인 방식으로 합을 구하게 되면</p><p>1 &#x2F; 1+2 &#x2F; 1+2+3 &#x2F; 1+2+3+4 &#x2F; 1+2+3+4+5 의 방식대로 값을 구하게 되는데 이에 비해 훨씬 효율적이며 구간합을 구할 때 이중 순회를 거치지 않고 누적합을 저장한 데이터를 토대로 최종 인덱스와 시작 인덱스의 설정만으로 답을 찾아낼 수 있습니다. 적용 예시를 보면 쉽게 이해하실 수 있습니다.</p><h1 id="▪︎-Example-of-Apply"><a href="#▪︎-Example-of-Apply" class="headerlink" title="▪︎ Example of Apply"></a>▪︎ Example of Apply</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/31e8c361-d960-4b83-a3f9-29f17781b9b7/image.png" alt="image.png"></p><p><img src="https://velog.velcdn.com/images/vbghdl/post/19cf461a-e0f6-4614-947e-7a21523234c7/image.png" alt="image.png"></p><ul><li><a href="https://www.acmicpc.net/problem/11659">https://www.acmicpc.net/problem/11659</a></li></ul><p>위 문제는 배열의 1<del>3번째 누적합, 2</del>4번째 누적합, 5~5번째 누적합을 구하면되는 간단한 문제입니다. 그러나 저 세 케이스를 순회하면서 다시 for문을 통해 원소들을 합하게되면 O(N^2)의 시간복잡도로 최악의 경우 10^10의 시행횟수를 갖게되어 1초 (10^8) 시간제한을 통과할 수 없습니다. 이 때 누적합 알고리즘을 적용하여 주어진 배열의 누적합을 따로 데이터로 저장해놓고 단순 접근과 연산만으로 답을 찾아낼 수 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> input = fs</span><br><span class="line">  .<span class="title function_">readFileSync</span>(<span class="string">&quot;dev/stdin&quot;</span>)</span><br><span class="line">  .<span class="title function_">toString</span>()</span><br><span class="line">  .<span class="title function_">trim</span>()</span><br><span class="line">  .<span class="title function_">split</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> el.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> +v));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [N, M] = input[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> numbers = input[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> arr = input.<span class="title function_">slice</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> prefixSum = <span class="title class_">Array</span>(N + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>); <span class="comment">// 문제에서 인덱스가 기준이 아닌 몇번 째인지로 판단하기 때문에 1부터 데이터를 저장</span></span><br><span class="line"><span class="keyword">let</span> answer = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 누적합 데이터를 생성</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">  prefixSum[i + <span class="number">1</span>] = prefixSum[i] + numbers[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 누적합 데이터를 단순 연산하는 것 만으로 구간합 도출</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  answer.<span class="title function_">push</span>(prefixSum[arr[i][<span class="number">1</span>]] - prefixSum[arr[i][<span class="number">0</span>] - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(answer.<span class="title function_">join</span>(<span class="string">&quot;\n&quot;</span>));</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%88%84%EC%A0%81%ED%95%A9/">누적합</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/02/17/algorithm/%EB%88%84%EC%A0%81%ED%95%A9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>완전탐색 ) 1초 제한시간 기준을 통한 적용 여부 판별</title>
      <link>https://namgungjongmin.github.io/2024/02/14/algorithm/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/</link>
      <guid>https://namgungjongmin.github.io/2024/02/14/algorithm/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/</guid>
      <pubDate>Wed, 14 Feb 2024 06:16:15 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;코딩테스트 대부분의 문제에</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/e0ccaaba-5d36-47b1-b7ec-e658aad36afe/image.png"></p><blockquote><p>코딩테스트 대부분의 문제에서 주어진 자료를 순회하여 답을 도출하는 경우가 많습니다. 이 때 어떠한 알고리즘으로 순회를 하여 문제에 접근하는 것이 좋을지 1초의 제한 시간 기준을 통해 판별하는 방법을 정리한 글입니다.</p></blockquote><h1 id="▪︎-시간-복잡도를-고려한-기준-적용"><a href="#▪︎-시간-복잡도를-고려한-기준-적용" class="headerlink" title="▪︎ 시간 복잡도를 고려한 기준 적용"></a>▪︎ 시간 복잡도를 고려한 기준 적용</h1><p>대부분의 코딩테스트 시험의 시간 제한 조건은 1초~5초 내외입니다. 따라서 실행 시간을 1초 내로 줄이는 것을 목표로 문제에 접근하는 것이 코딩테스트를 준비하는 데 있어 합리적입니다.</p><p>테스트를 하는 각 서버의 CPU에 따라서 같은 코드라도 실행 시간이 천차 만별이므로 “엄격하게 시간 복잡도를 몇으로 해야된다”라고 규정하는 것은 어렵습니다. 그러나 관행적으로 10^8 이내의 시행 횟수를 1초 내외의 제한 시간을 통과한 것으로 인정하고 그에 맞게 설계를 하는 편입니다.</p><p>데이터를 순회하여 정답을 도출해야하는 문제에서는 제일 먼저 완전 탐색(Brute Force)을 고려합니다. 이 때 전체적인 풀이의 흐름을 그려보고 시행 횟수를 빠르게 판단해보는 것이 좋습니다. 10^8 이내의 시행 횟수로 정답 도출이 가능하다면 완전 탐색을 적용하고, 불가능하다면 다른 알고리즘을 고려해보아야 합니다.</p><h1 id="▪︎-Example-of-Apply"><a href="#▪︎-Example-of-Apply" class="headerlink" title="▪︎ Example of Apply"></a>▪︎ Example of Apply</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/e9d6afc6-dd84-4a94-83bd-7ccda4919c61/image.png" alt="Untitled"></p><h2 id="▫︎-문제-접근"><a href="#▫︎-문제-접근" class="headerlink" title="▫︎ 문제 접근"></a>▫︎ 문제 접근</h2><p>이 문제에서 우리는 총 3번의 순회가 필요합니다.</p><ol><li>2번의 반복문을 통한 멘토 학생과 멘티 학생이 매칭</li><li>1번의 반복문을 통한 테스트 결과 순회</li></ol><p>가장 먼저 완전 탐색을 고려하여 10^8 이내의 시행 횟수로 정답 도출이 가능한지 확인합니다. 제시된 입력 설명에서 최악의 시행 횟수 경우를 산정해보면 20<em>20</em>10 입니다. 따라서 다른 알고리즘의 고려 없이 바로 완전 탐색을 적용 가능합니다.</p><h2 id="▫︎-풀이"><a href="#▫︎-풀이" class="headerlink" title="▫︎ 풀이"></a>▫︎ 풀이</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">test</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> answer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= test[<span class="number">0</span>].<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= test[<span class="number">0</span>].<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === j) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> isMatched = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; test.<span class="property">length</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (test[k].<span class="title function_">indexOf</span>(i) &gt; test[k].<span class="title function_">indexOf</span>(j)) &#123;</span><br><span class="line">          isMatched = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isMatched) answer += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="▫︎-시간복잡도가-충분하지-않다면"><a href="#▫︎-시간복잡도가-충분하지-않다면" class="headerlink" title="▫︎ 시간복잡도가 충분하지 않다면"></a>▫︎ 시간복잡도가 충분하지 않다면</h2><ol><li>포인터 두 개로 두번의 순회를 한번으로 줄일 수 있다면 ⇒ 투포인터 사용</li><li>순회 내에서 배열의 조작 메서드의 O(n)의 시간복잡도를 그 이하로 낮추려면 ⇒ 자료구조 사용<ul><li>우선순위 큐 &#x2F; 연결리스트</li></ul></li><li>배열 탐색을 O(1)로 하고 싶다면 ⇒ 해시 (Map 함수) 사용</li><li>정렬된 데이터를 기준으로 답을 찾을 수 있을 것 같다면 ⇒ 이진 검색 사용</li></ol><p>위의 예시들은 제가 코딩테스트에서 완전 탐색으로 접근할 때 시행횟수가 크다면 고려하는 다음 접근들입니다. 각 케이스 별 정리와 예시 문제 풀이는 알고리즘 카테고리 내 포스팅에서 확인하실 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/">완전탐색</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/02/14/algorithm/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_과정 종료 회고</title>
      <link>https://namgungjongmin.github.io/2024/02/11/fc-yanolja/retrospective_all/</link>
      <guid>https://namgungjongmin.github.io/2024/02/11/fc-yanolja/retrospective_all/</guid>
      <pubDate>Sun, 11 Feb 2024 13:54:53 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;파이널 프로젝트가 끝나면서</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png"></p><blockquote><p>파이널 프로젝트가 끝나면서 7개월의 부트캠프 과정이 끝이 났습니다. 길다면 길고 짧다면 짧을 수 있는 시간인데 부트캠프를 진행하기 이전의 저와 수료한 이후의 저는 완전 다른 사람이 된 것 같아요. 사실 처음 시작할 때는 기본적인 클론 코딩도 버거워하던 저였는데 이제는 혼자서 프로젝트를 기획하고 개발하면서 이번엔 어떤 기술을 적용해볼까 행복한 고민을 하고 있어요. 이번 포스팅은 저번에 포스팅 했던 파이널 프로젝트의 결과를 공유해보고, 제가 패스트캠퍼스 X 야놀자 부트캠프를 진행하면서 어떻게 달라졌는지 회고해보려고 해요. 추가로 좋은 소식도 하나 자랑해보려고 합니다. ㅎㅎ.</p></blockquote><h1 id="파이널-프로젝트-끝"><a href="#파이널-프로젝트-끝" class="headerlink" title="파이널 프로젝트 끝!"></a>파이널 프로젝트 끝!</h1><p>패스트캠퍼스 X 야놀자 부트캠프에서 진행한 RFP기반 기업 연계 프로젝트가 끝이 났습니다. 이번 프로젝트는 확실히 기획 분들과 디자이너 분이 계셔서 프론트엔드에서 와이어프레임을 짜고 디자인 했을 때보다 확실히 결과가 잘 나온 것 같아요! 만들어진 사이트를 보면서 “와! 진짜 서비스하고 있는 사이트처럼 생겼다”라고 생각했습니다. 저희가 부트캠프의 마지막을 장식한 프로젝트 결과물을 함께 감상해봐요.</p><h1 id="사이트-핵심-기능"><a href="#사이트-핵심-기능" class="headerlink" title="사이트 핵심 기능"></a>사이트 핵심 기능</h1><p>저번 포스팅에서 투표 기반 여행 일정 앱을 만든다고 했었죠? 우리 앱의 핵심 기능은 다음과 같습니다. 하나씩 살펴봐요.</p><h2 id="1-여행지-투표"><a href="#1-여행지-투표" class="headerlink" title="1) 여행지 투표"></a>1) 여행지 투표</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/60508778-5e1c-4c71-ae9e-7bf9cabea2b2/image.png"></p><h2 id="2-투표-기반-일정-작성"><a href="#2-투표-기반-일정-작성" class="headerlink" title="2) 투표 기반 일정 작성"></a>2) 투표 기반 일정 작성</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/a1151c91-77e5-44a4-8d7e-f5a9a007dbd5/image.png"></p><h2 id="3-루트-최적화"><a href="#3-루트-최적화" class="headerlink" title="3) 루트 최적화"></a>3) 루트 최적화</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/4e68c1bb-468b-4456-bf23-a69d4427aab5/image.png"></p><h2 id="4-여행-정보-검색"><a href="#4-여행-정보-검색" class="headerlink" title="4) 여행 정보 검색"></a>4) 여행 정보 검색</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/20c6e43e-b2ce-4c19-97ed-19c6e7445c8c/image.png"></p><h1 id="랜딩-페이지-생성-및-마케팅"><a href="#랜딩-페이지-생성-및-마케팅" class="headerlink" title="랜딩 페이지 생성 및 마케팅"></a>랜딩 페이지 생성 및 마케팅</h1><p>기획분들 덕분에 마케팅도 경험할 수 있었어요. 랜딩 페이지를 만들고 인스타그램과 페이스북 같은 SNS 마케팅을 통해 사람들에게 저희 앱을 노출시키고 랜딩페이지로 유도하여 사전 예약을 받게 하였습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/35be0e28-007d-4ac5-8b20-3928a5c6eb75/image.png"></p><p>약 일주일 간 랜딩페이지 방문자 413명, CTA 입력폼 섹션 도달 인원 50명, 사전 출시 알림 신청 인원 41명으로 전환율 10%를 달성했습니다!</p><h1 id="트립-보트-소개-영상"><a href="#트립-보트-소개-영상" class="headerlink" title="트립 보트 소개 영상"></a>트립 보트 소개 영상</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/53f51036-afa0-4b85-82a2-c46de47b42f0/image.png"><br><a href="https://www.youtube.com/watch?v=9d4K_1AzSAA">https://www.youtube.com/watch?v=9d4K_1AzSAA</a></p><h1 id="부트캠프-후-나는-어떻게-달라졌을까"><a href="#부트캠프-후-나는-어떻게-달라졌을까" class="headerlink" title="부트캠프 후 나는 어떻게 달라졌을까?"></a>부트캠프 후 나는 어떻게 달라졌을까?</h1><p>부트캠프를 진행하면서 총 4번의 협업 프로젝트를 통해 학습 기간 익혔던 기술들을 적용해볼 수 있었습니다. 부트캠프 이전과 달리 프로젝트마다 적용하게 되었거나 프로젝트를 통해 새로 얻게 된 지식들이 많은 것 같아요. 또 협업 프로젝트로 인해 다른 사람들과 어떻게 함께 개발해야 하는지를 알게 된 것이 너무 좋았습니다.</p><h2 id="1-웹표준-및-웹접근성-적용"><a href="#1-웹표준-및-웹접근성-적용" class="headerlink" title="1) 웹표준 및 웹접근성 적용"></a>1) 웹표준 및 웹접근성 적용</h2><p>저는 패스트캠퍼스 X 야놀자 부트캠프에서 마크업 언어를 배우면서 특히나 웹표준과 웹접근성을 중요하게 생각했던 것 같아요. 어떻게 하면 시멘틱한 마크업을 할 수 있을까, 또 어떻게 해야 모든 사람에게 정보를 공유할 수 있을까 고민했습니다.</p><p>웹표준을 지키기 위해 시멘틱한 마크업을 하려고 했고, 그러기 위해서는 각 태그별 특징을 명확히 인지할 필요가 있었습니다. 특히 각 태그의 특징을 아는 것은 웹 접근성 확보를 위해서도 꼭 필요한 부분이었기 때문에 단순한 기능 구현보다는 의미있는 코드를 작성하려고 노력하게 되었어요.</p><p>예를들어 ol과 ul의 차이점에서 스크린리더가 어떻게 읽어주는지를 고려한다면 같은 리스트 태그라도 어떤 것을 쓰는게 맞을지 한번 더 고민했습니다. 또 스크린리더 사용자를 고려하는 코드들을 프로젝트마다 적용하게 되었어요. 특히나 각 섹션별 설명을 p태그로 넣어두고 디자인 요소를 해치지 않기 위해 accessibility hidden 스타일을 적용하여 읽어주기만 한다던가 반대로 디자인적으로만 사용되는 이미지 요소이기에 스크린리더가 읽어줄 필요가 없는 상황에서는 aria-hidden 속성을 적용하게 되었습니다.</p><h2 id="2-다양한-스타일-라이브러리와-프레임워크-경험"><a href="#2-다양한-스타일-라이브러리와-프레임워크-경험" class="headerlink" title="2) 다양한 스타일 라이브러리와 프레임워크 경험"></a>2) 다양한 스타일 라이브러리와 프레임워크 경험</h2><p>또 다양한 스타일 라이브러리와 프레임워크를 경험하면서 “어떨 때 어떤 것을 써야겠다”하는 자신만의 기준도 생기게 되었습니다. 예를 들어 생산성이 중요한 프로젝트에서는 tailwindCSS와 같은 유틸리티 퍼스트 스타일 프레임워크를 통해 빠른 개발을 할 수 있었고, 충분한 기획과 디자인 시스템 아래에서 시작된 개발에서는 Sass를 이용하여 다양한 함수와 mixin을 통해 디자인 시스템에 맞춰 세팅을 해두고 개발에 들어간다면 훨씬 수월하게 개발이 진행된다는 것을 경험했어요.</p><p>또 차크라 ui와 MUI와 같은 라이브러리를 통해 보다 쉽게 ui 컴포넌트를 구현해볼 수 있었습니다. 다만 ui 컴포넌트 라이브러리의 경우 커스터마이징이 오히려 생개발보다 힘든 경우도 있었기 때문에 기획의 디자인이 라이브러리 테마와 거리가 멀다면 오히려 적용하지 않거나 headless ui를 적용하는 것이 좋겠다는 생각을 했습니다.</p><h2 id="3-다양한-협업-툴과-git-전략-이용-경험"><a href="#3-다양한-협업-툴과-git-전략-이용-경험" class="headerlink" title="3) 다양한 협업 툴과 git 전략 이용 경험"></a>3) 다양한 협업 툴과 git 전략 이용 경험</h2><p>총 4번의 협업프로젝트를 진행했습니다. 디자인, 기획, 백엔드, 프론트엔드가 함께 프로젝트를 경험하게 되면서 실제 기업에서 어떻게 함께 일하게 될지를 미리 경험해본 느낌이었어요. 또 다양한 협업 툴을 통해 일정을 관리하고 소통하면서 커뮤니케이션 능력을 익혔구요.</p><p>또 프로젝트마다 다양한 프로젝트 관리 전략을 적용해보면서 협업을 경험할 수 있었습니다. jira나 github project 경험, 그리고 gitflow와 같은 브랜치 관리 전략 등을 적용해보면서 이제 실무에 들어가서도 다른 사람과 함께 협업할 능력을 갖추었다는 자신감을 가질 수 있게 되었습니다.</p><h2 id="4-스스로-학습하는-방법을-익힘"><a href="#4-스스로-학습하는-방법을-익힘" class="headerlink" title="4) 스스로 학습하는 방법을 익힘"></a>4) 스스로 학습하는 방법을 익힘</h2><p>패스트캠퍼스 X 야놀자 부트캠프는 온라인으로 진행되었습니다. 제공된 강의를 통해 정해진 커리큘럼을 따라가면서 자기가 원하는 공부를 추가적으로 진행할 수 있었던 점이 저에게는 정말 큰 성장의 발판이 되었던 것 같아요.</p><p>개발을 공부하다보면 배운 지식들에서 새로운 가지들이 자꾸 나오는 것을 경험했습니다. 이것들을 ‘앨리스의 토끼굴’이라고 표현하더라구요. 그래서 그런 지식들까지 다 공부해서 섭렵해버리겠다! 라는 생각을 제 모토로 삼았습니다. 그래서 제 프로필 소개가 ‘토끼굴을 정복하는 개발자’에요 ㅎㅎ.</p><p>강의를 통해 html5를 배우면서 웹 접근성이라는 개념을 알게 되었고, 이렇게 연결된 지식들을 더 공부하기위해 WCAG2.1을 공부하면서 더 깊은 이해가 가능했어요. 만약 다른 커리큘럼 진행만을 강요하는 부트캠프였다면 이런식의 공부가 힘들었을 것 같아요.</p><h2 id="5-유저-뿐만이-아니라-기업의-입장에서도-코드를-작성할-수-있게-됨"><a href="#5-유저-뿐만이-아니라-기업의-입장에서도-코드를-작성할-수-있게-됨" class="headerlink" title="5) 유저 뿐만이 아니라 기업의 입장에서도 코드를 작성할 수 있게 됨"></a>5) 유저 뿐만이 아니라 기업의 입장에서도 코드를 작성할 수 있게 됨</h2><p>프론트엔드 개발자가 유저 중심의 코드를 작성해야 한다는 것은 모두가 알고 계실 내용일 것 같아요. 그런데 기업의 입장에서도 고민을 해보는 것이 필요하다고 생각합니다. 여러 프로젝트를 진행하고 또 배포와 관련하여 여러 비용 처리를 경험하게 되면서 기업의 입장에서 코드를 작성하는 것이 필요한 일이라는 것을 깨닫게 되었습니다.</p><p>예를들어 서버 비용을 줄이기 위해 서버에 fileList를 그대로 전달하는 것이 아닌 S3의 Presigned URL을 이용하여 따로 업로드하고, 그 url만 서버에 전달해주어 서버 비용을 낮출 수 있었어요.</p><h1 id="부트캠프-수료"><a href="#부트캠프-수료" class="headerlink" title="부트캠프 수료!!!!!"></a>부트캠프 수료!!!!!</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/86d0fba3-6ee5-4a0e-b7fa-80d91fd879f9/image.png"></p><p>드디어 부트캠프를 수료하게 되었네요. 7개월이 짧은 시간은 아니지만 저에게는 정말 순식간에 지나간 것 같습니다. 그만큼 부트캠프에 몰입하고 있었던 것 같아요. 좋은 사람들을 많이 만날 수 있었고, 함께 성장할 수 있었어요. 이런 기회를 준 패스트캠퍼스에 정말 감사하는 마음 뿐이랍니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/ae938868-7fcd-48e2-94bc-d34ddb98eb52/image.png"></p><h1 id="내가-최우수-수료생"><a href="#내가-최우수-수료생" class="headerlink" title="내가 최우수 수료생!!"></a>내가 최우수 수료생!!</h1><p>너무나 감사하게도 이번 부트캠프 최우수 수료생으로 선정되었습니다. 과정 진행 동안의 프로젝트와 과제, 퀴즈 등을 종합하여 선정되었는데, 정말 수강생 분들끼리의 점수 차이가 미미하더라구요. 운이 좋았다는 생각과 동시에 그만큼 열심히 한 나 자신을 칭찬해주고 싶었습니다. 최우수 수료생에게는 모의 면접과 모의 코딩테스트 등 여러가지 취업을 위한 추가적인 혜택이 있었어요. 잘 활용해서 꼭 원하는 곳에 취업하도록 노력하겠습니다. 그 동안 감사했습니다!</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/02/11/fc-yanolja/retrospective_all/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_파이널 프로젝트 회고</title>
      <link>https://namgungjongmin.github.io/2024/01/31/fc-yanolja/retrospective_final/</link>
      <guid>https://namgungjongmin.github.io/2024/01/31/fc-yanolja/retrospective_final/</guid>
      <pubDate>Wed, 31 Jan 2024 14:34:13 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;돌아온 패스트캠퍼스 X 야</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png"></p><blockquote><p>돌아온 패스트캠퍼스 X 야놀자 부트캠프 포스팅입니다! 2024년의 새로운 해의 시작과 함께 1월부터 저희 부트캠프에서는 ‘파이널 프로젝트’를 진행했습니다. 이번 프로젝트에서는 기획, 디자인, 백엔드, 프론트 각 포지션들이 하나의 팀을 이루어 진행하게 되었습니다. 저번 미니 프로젝트에서는 백엔드와 프론트 두 포지션만이 있었기 때문에 개발 외적으로도 디자인이나 앱 기획 등을 신경쓸게 많았는데요! 이번 파이널 프로젝트에서는 기획분들의 요청에 맞추어 구현만 하면되었기 때문에 개발에만 집중할 수 있어서 정말 좋았던 것 같아요.</p></blockquote><h1 id="기업-연계-프로젝트"><a href="#기업-연계-프로젝트" class="headerlink" title="기업 연계 프로젝트"></a>기업 연계 프로젝트</h1><p>이번 프로젝트는 야놀자의 기업 RFP를 제안서를 토대로 개발이 이루어졌습니다. 패스트 캠퍼스 X 야놀자 부트캠프에서만 경험할 수 있는 최고의 프로젝트라고 생각했어요. 실제 기업의 문제 및 니즈를 분석하고 스스로 해결책을 개발하는 과정을 경험할 수 있었습니다. 개발 중간 중간 야놀자 실무진분들의 멘토링을 받을 수 있었고, 주마다 꾸준하게 진행사항들을 확인하고 그에 대한 의문점이나 조언들을 멘토님에게 얻을 수 있었습니다.</p><h1 id="팀-결성"><a href="#팀-결성" class="headerlink" title="팀 결성!"></a>팀 결성!</h1><p>저희 팀은 ‘여행 여정 공유 플랫폼’을 주제로 개발을 진행하게 되었습니다. 팀 구성은 디자이너 1명, PM 4명, 프론트엔드 6명, 백엔드 5명으로 이루어지게 되었습니다. 미니에 비해 규모가 확 커졌다는 것이 느껴졌어요. 기획분들과 디자이너분이 추가된만큼 피그마도 엄청 무섭게 커졌습니다. 처음엔 와 우리가 저걸 개발할 수 있을까? 싶을정도로요..</p><p>프로젝트 기획과 디자인은 피그마를 통해 진행되었습니다. 디자이너와 기획분들과는 피그마 내의 댓글을 통해 기능들을 구체화하고 완성시켰어요. 각자 작업하면서 의문이 드는 부분이나 수정이 필요하다고 생각되는 부분들은 댓글로 달아놓아 확인할 수 있게 하였고, 구체적인 상의는 매일 있는 코어 타임과 주 한번의 팀 미팅을 통해 방향을 정했습니다.</p><p>디자인의 경우 전체적인 앱의 통일성을 위해 글꼴과 크기, 볼드값을 사용될 컴포넌트별로 정리해주셨고, 앱 전반적으로 사용될 토스트나 알림모달, 그리고 박스들의 형태또한 정해서 전해주셨습니다. 이번 프로젝트에서 저희는 sass를 사용하기 때문에 미리 저렇게 정리해서 주시니 변수들과 함수에 적용시켜 개발을 정말 편하게 할 수 있었어요.</p><h2 id="와이어프레임"><a href="#와이어프레임" class="headerlink" title="와이어프레임"></a>와이어프레임</h2><p><a href="https://www.figma.com/file/oeQ2vOcyO3SuInuMf3Dlj8/%EC%B5%9C%EC%A2%85-%ED%99%94%EB%A9%B4(PM)?type=design&amp;node-id=0-1&amp;mode=design&amp;t=nZD111AWFn7ozFJx-0">https://www.figma.com/file/oeQ2vOcyO3SuInuMf3Dlj8/%EC%B5%9C%EC%A2%85-%ED%99%94%EB%A9%B4(PM)?type=design&amp;node-id=0-1&amp;mode=design&amp;t=nZD111AWFn7ozFJx-0</a></p><p><img src="https://velog.velcdn.com/images/vbghdl/post/4e5289a3-9ced-4cd1-9a32-0855acff9a36/image.png"><br><img src="https://velog.velcdn.com/images/vbghdl/post/a815031a-8123-4363-a3f5-50cd4b95ef3d/image.png"></p><blockquote><p>확실히 디자인, 기획 분들과 함께하는 프로젝트다보니 피그마 규모 부터가 저번 프로젝트랑 다릅니다…ㅠ (내가 할 수 있을까 걱정도 많이 했어요)</p></blockquote><h2 id="디자인가이드"><a href="#디자인가이드" class="headerlink" title="디자인가이드"></a>디자인가이드</h2><p><a href="https://www.figma.com/file/ypTLv92s72sihUApnxjP5C/%EA%B0%95%EC%9E%90%EB%B0%AD-%ED%94%BC%EA%B7%B8%EB%A7%88?type=design&amp;node-id=40-2&amp;mode=design&amp;t=Jf8iEjAoqYVNtYJX-0">https://www.figma.com/file/ypTLv92s72sihUApnxjP5C/%EA%B0%95%EC%9E%90%EB%B0%AD-%ED%94%BC%EA%B7%B8%EB%A7%88?type=design&amp;node-id=40-2&amp;mode=design&amp;t=Jf8iEjAoqYVNtYJX-0</a></p><p><img src="https://velog.velcdn.com/images/vbghdl/post/c654d8fa-fcb2-43d4-87a1-88607add869c/image.png"></p><blockquote><p>디자인 분께서 각 컴포넌트별로 세세하고 통일감있게 작성해주셨어요. 덕분에 미리 sass 변수와 mixin에 등록하고 뽑아쓰면서 편하게 개발에 집중할 수 있었습니다!</p></blockquote><h1 id="개발-진행"><a href="#개발-진행" class="headerlink" title="개발 진행"></a>개발 진행</h1><h2 id="Sass-변수-및-mixin-적용"><a href="#Sass-변수-및-mixin-적용" class="headerlink" title="Sass 변수 및 mixin 적용"></a>Sass 변수 및 mixin 적용</h2><p>디자이너분의 디자인 가이드를 바탕으로 sass 변수에 색상과 글씨를 선언해주었습니다. 특히 font size, font weight, line height의 경우 sass 맵을 생성하고 mixin 내에서 불러와 적용할 수 있도록 하였습니다.</p><p>실제 스타일이 적용되는 부분에서는 @include typography(headline) 처럼 작성해주면 디자이너분이 headline에 적용되길 기대한 글씨에 대한 모든 값들이 한번에 적용되었습니다!! 확실히 이전 프로젝트들과 달리 디자이너분이 디자인 시스템을 갖추어주시니 개발이 너무 편해졌어요.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/b23be087-aa52-4bdc-8454-3c42ed9fe3bd/image.png"></p><h2 id="MSW-적용"><a href="#MSW-적용" class="headerlink" title="MSW 적용"></a>MSW 적용</h2><p>프론트엔드의 가장 이상적인 개발 진행은 백엔드 API가 완성되어 거기에 맞춰 데이터 페칭을 하고 그에따른 UI를 화면에 출력하는 것이라고 생각합니다. 하지만… 같이 시작한 프로젝트에서 저희가 백엔드의 완성만을 기다릴 수는 없어요. 그래서 MSW를 적용했습니다!</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/977c3f4d-c83f-4f6b-bd01-e2669df4275b/image.png"></p><p>개발 환경에서는 MSW가 api 요청을 탈취해서 모킹 서버로부터 저희가 정한 응답을 받고 데이터들을 페이지에 렌더링할 수 있습니다. 이게 정말 좋았던게 백엔드와의 협의를 통해 엔드포인트만 정해둔다면 이후 배포시에도 코드의 변경없이 실제 서버로 그대로 요청을 보낼 수 있다는 것이 신세계였습니다.</p><p>프로젝트 막바지에는 위의 이미지처럼 모킹 함수 내에 return문을 추가시켜서 모킹하지 않고 바로 서버로 요청을 보내보면서 테스트 해볼 수 있었어요!</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>파이널 프로젝트도 끝나가고 이제는 수료도 코앞으로 다가왔습니다. 6개월 가량 정말 길거라고 생각한 것이 무색하게 후딱 지나가버렸어요. 패스트캠퍼스 X 야놀자 부트캠프 덕분에 스스로 자신감도 생기고 무엇보다 어떻게 개발자로서 발전해나갈지 깨닫는 계기가 된 것 같아요. 이번 마지막 프로젝트도 잘 마치고 다음 포스팅엔 마지막으로 부트캠프를 진행하며 느꼈던 총 후기로 돌아오겠습니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/01/31/fc-yanolja/retrospective_final/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_미니프로젝트 회고</title>
      <link>https://namgungjongmin.github.io/2023/12/15/fc-yanolja/retrospective_mini/</link>
      <guid>https://namgungjongmin.github.io/2023/12/15/fc-yanolja/retrospective_mini/</guid>
      <pubDate>Fri, 15 Dec 2023 11:44:16 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이번 포스팅은 패스트캠퍼스</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png"></p><blockquote><p>이번 포스팅은 패스트캠퍼스 X 야놀자 부트캠프에서 진행한 ‘미니 프로젝트’를 진행하며 겪은 경험과 과정, 그리고 느낀점들을 공유하려고 합니다. 처음으로 경험했던 백엔드와의 협업 프로젝트였는데요! 이번 프로젝트를 하면서 팀장 역할도 맡게 되어서 부담감도 있었던 프로젝트였던 것 같아요. 하지만 함께 노력해준 팀원들과 멘토님의 도움 덕분에 수월하게 진행된 것 같습니다. 패스트캠퍼스 X 야놀자 부트캠프의 미니프로젝트! 어떻게 진행이 되었나 함께 보실까요?</p></blockquote><h1 id="프로젝트의-시작"><a href="#프로젝트의-시작" class="headerlink" title="프로젝트의 시작"></a>프로젝트의 시작</h1><p>이번 프로젝트에서는 ‘숙박 예약 API 서비스’를 과제로 전달받았습니다. 프로젝트 RFP를 통해 프로젝트 정의서와 기능적 요구사항들을 전달받고 해당 기능들을 백엔드 팀과의 협업을 통해 구현해나가야 했어요. 11월20일 ~ 12월01일 2주간 정말 열심히 개발했답니다.</p><h1 id="기획과-디자인"><a href="#기획과-디자인" class="headerlink" title="기획과 디자인"></a>기획과 디자인</h1><p>프로젝트의 기획은 피그마를 통해 구체화하였습니다. 팀 전체가 모여 와이어프레임과 세부 디자인을 결정하고 세부적으로 백엔드 팀원분들과의 상의를 통해 우선 순위 기능들, 구현하기 힘들거나 후순위인 기능들을 정리하였습니다.</p><p><a href="https://www.figma.com/file/uRO4rM5NR5F1WTIsv6ALWD/12%EA%B1%B8%EC%A7%80%EB%A7%90%EC%A1%B0?type=design&node-id=0:1&mode=design&t=kG7h2ykBGJ5rrZpc-1">Figma URL</a><br><img src="https://velog.velcdn.com/images/vbghdl/post/efb0515a-20f2-4e2d-8ff5-d5eb61a70948/image.png"></p><h1 id="기술-선택"><a href="#기술-선택" class="headerlink" title="기술 선택"></a>기술 선택</h1><p>기획이 완료되어 가면서 개발시 어떠한 기술들을 쓸 것인가에 대해 팀원들과 이야기를 나누었습니다. 제일 먼저 저희가 주목한 부분은 ‘어떤 기술을 써야 기업에 이익을 극대화할 수 있을 것인가?’였습니다. 숙박 예약 사이트의 각각의 숙박업소들이 나와있는 페이지와 객실 정보들을 확인하는 페이지들의 노출도가 높을 수록 우리 사이트를 접근하는 유저들이 많을 것이고, 그것이 기업의 이익과 연결된다고 생각했습니다. 따라서 이전 프로젝트와는 달리 NEXT.JS를 사용하기로 하였습니다.</p><p>NEXT.JS는 서버 컴포넌트가 있기 때문에 SSR이 가능합니다. 즉 자바스크립트 기반으로 빈 문서를 가져와 렌더링하는 리액트의 CSR과는 달리 우리가 서버 컴포넌트로 활용하고자 하는 페이지는 해당 정보를 문서에서 그려올 수 있기 때문에 검색 엔진 최적화에 유리합니다. 바로 우리 페이지를 더 쉽고, 많이 노출시킬 수 있다는 뜻이에요!</p><p>이후에는 백엔드에서 전달해준 API 명세등을 미리 타입으로 지정해두기 위해 Typescript도 도입했습니다. API 명세에 없는 키값을 입력하거나 타이핑 오타 등으로 일어날 오류를 런타임환경에서 확인하고 수정할 수 있었어요.</p><p>마지막으로 스타일 프레임워크는 TailwindCss를 선택했습니다. TailwindCss를 선택한 이유는 2주라는 짧은 시간 동안 처음 진행해보는 백엔드와의 협업 프로젝트였기 때문에 개발 생산성이 중요하다고 생각했기 때문입니다. 유틸리티 퍼스트 방식을 도입하면서 화면에 그려지는 레이아웃들을 직접 확인하면서 바로바로 적용해나갈 수 있어 확실히 빠른 개발 진행이 가능했습니다.</p><h1 id="협업-방식과-개발-전략-설정"><a href="#협업-방식과-개발-전략-설정" class="headerlink" title="협업 방식과 개발 전략 설정"></a>협업 방식과 개발 전략 설정</h1><p>다음으로 정해야 할 것은 ‘어떻게 협업할 것인가?’였습니다.</p><h2 id="ZEP"><a href="#ZEP" class="headerlink" title="ZEP"></a>ZEP</h2><p>전체적인 회의 진행과 기본 커뮤니케이션은 ZEP을 통해 이루어졌습니다. ZEP은 화면공유, 음성채팅, 영상채팅 등이 가능한 협업 툴인데요, 마치 게임처럼 아기자기한 캐릭터들을 이동해가면서 커뮤니케이션을 할 수 있어서 너무 재미있었어요.<br><img src="https://velog.velcdn.com/images/vbghdl/post/51cd3359-aa51-4580-97e5-65505fc04b9e/image.png"></p><blockquote><p>저희 프로젝트 방은 이렇게 생겼어요. 프론트 책상에서 회의를 하다가 백엔드 팀에게 질문사항이 생기면 ‘쫑쫑쫑’ 백엔드 테이블로 걸어가서 물어보곤 했답니다.</p></blockquote><h2 id="Trello"><a href="#Trello" class="headerlink" title="Trello"></a>Trello</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/c0648461-9a00-46ac-b0b0-3930689c3eec/image.png"><br>다음으로는 백엔드와 프론트엔드 사이에서 맡은 역할 별로 요구사항이나 수정사항, 또는 오류 등에 대해 1:1로 요청을 보내기에 trello가 편하다고 생각되어서 도입하게 되었습니다. 같은 프론트엔드 팀원이나 백엔드 팀원에게 요청을 보낼 때 간단하게 카드를 달아놓을 수 있습니다. 해당 주제에 대한 카드에서 댓글을 통해 서로 의견을 주고 받거나 진행사항을 공유할 수 있었습니다.</p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>마지막으로는 가장 주축이 되었던 모두의 Github입니다! 프론트엔드 팀의 개발에 있어서 프로세스를 정해두었어요.</p><ol><li>분담한 역할에 따라 구현할 기능에 대한 개발 내용을 미리 이슈로 등록한다.<br><img src="https://velog.velcdn.com/images/vbghdl/post/dc6cf5c5-b1a3-4cc8-ba1d-f2baf3c0e05b/image.png"></li><li>개인이 개발한 내용은 반드시 PR을 통해 팀원들과 공유하고 코드리뷰와 approval을 거친 뒤에 브랜치에 적용한다.<br><img src="https://velog.velcdn.com/images/vbghdl/post/eaf59b90-91fa-43a7-9461-f01cca5c8b7f/image.png"></li></ol><p>이 때 각 팀원 별로 브랜치를 분기해서 PR을 보냈어야 했는데 이를 단순화하기 위해 Gitflow도 도입했습니다! 저희가 사용한 브랜치 분기 전략은 밑의 링크에서 확인하실 수 있어요.</p><p><a href="https://warp-pirate-416.notion.site/caba5079fcc64628bebb8bd56a768054">브랜치 분기 전략</a></p><h1 id="프로젝트-진행"><a href="#프로젝트-진행" class="headerlink" title="프로젝트 진행"></a>프로젝트 진행</h1><p>프로젝트는 2주 동안 정말 눈코 뜰 새 없이 빠르게 지나갔습니다. 그나마 다행인 점은 기획 단계에서 백엔드와의 상의를 통해 전체적인 그림을 잘 잡아놨기에, 큰 충돌 없이 잘 진행될 수 있었어요.</p><p>저는 인증관련 페이지들과 기능들을 맡아 구현하게 되었습니다.</p><blockquote><p>이 때 NEXT.JS에서 쿠키 관련 이슈 때문에 너무 고생을 했는데… 이 부분은 차후에 NEXT.JS의 쿠키 사용에서의 이슈와 해결 방법이라는 주제로 다시 포스팅 하도록 할게요!</p></blockquote><p>또 저는 팀장으로서 전체적으로 팀원들의 개발 진행 사항이나 오류들을 파악해야 했습니다. 코드 리뷰도 정말 열심히 봤구요. 저의 역량은 이 모든 것을 자연스럽게 할 수 있을 정도로 충분하지 않다고 생각했고, 처음에 팀장을 맡았을 때에도 너무 부담이었던 부분이었습니다. 그러나 우리는 팀!<br>혼자서 모든 것을 해결한 것이 아니었어요. 팀원들의 도움과 스스로의 노력이 더해졌을 때 프로젝트는 정말 순조롭게 흘러갈 수 있었습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/cf69a43c-d3e0-47a9-b38a-a5ccc778d0ca/image.png"></p><blockquote><p>쌓여가는 Close PR과 우리들의 피, 땀 , 눈물…</p></blockquote><h1 id="프로젝트-완성과-리팩토링"><a href="#프로젝트-완성과-리팩토링" class="headerlink" title="프로젝트 완성과 리팩토링"></a>프로젝트 완성과 리팩토링</h1><p>드디어 2주가 지나고 저희 프로젝트가 완성되었습니다. 너무 힘든 2주였지만 완성된 결과물들이 제대로 동작하는 것들을 보면서 피로가 싹 날아가는 느낌이었어요! (물론 아직 부족한 점이 많아요…)</p><p><a href="https://www.stayinn.site/">STAYINN 사이트 링크</a><br><img src="https://velog.velcdn.com/images/vbghdl/post/7c08d8de-82ae-4e25-95fe-6c6994310eee/image.png"></p><h2 id="OVERVIEW"><a href="#OVERVIEW" class="headerlink" title="OVERVIEW"></a>OVERVIEW</h2><p><a href="https://drive.google.com/file/d/14apsd5GBasq9pUgUAFFZjZgJzqrIvaB2/view?usp=sharing"><img src="https://github.com/Dont12/KDT_Y_FE_Mini-Project/assets/79249376/3e556cb5-0763-4335-991f-7d8e36c73962" alt="시연영상"></a></p><h1 id="리팩토링"><a href="#리팩토링" class="headerlink" title="리팩토링"></a>리팩토링</h1><p>프로젝트가 끝난 뒤에는 2주간의 리팩토링 기간이 주어졌습니다. 각 팀원별로 맡은 부분에서 아쉬웠던 부분이나 추가적인 기능 구현들을 진행했습니다.</p><p>저의 경우에는 가장 주된 리팩토링 기능이 인가 여부에 따라 페이지를 라우팅하는 부분이였어요. 우리 사이트의 메인 페이지나 숙박&#x2F;객실 정보들을 보여주는 페이지의 경우는 로그인이 없어도 이용할 수 있지만, 마이페이지, 장바구니 페이지, 예약 하기 등에서는 반드시 로그인이 필요하기 때문에 로그인 페이지로 리다이렉트 시켜주는 로직이 필요했거든요.</p><p>기존 프로젝트에서 제가 구현한 방식은 페이지가 렌더링 되면서 로그인한 유저 정보를 API 요청하고 로그인이 되어있지 않아 요청이 실패하면 리다이렉트 시켜주는 방식이었습니다. 문제는 이렇게 구현했을 경우에는 페이지가 렌더링 되면서 요청하기 때문에 잠시동안 해당 페이지가 보여지다가 로그인 페이지로 넘어가는 깜빡거림 현상이 있었습니다.</p><p>이를 해결하기 위해 해당 페이지로 이동할 때 렌더링 이전 유저 정보를 요청하고 그 결과에 따라 렌더링 여부를 결정하는 것이 필요했어요. 이를 위해 미들웨어를 작성했습니다.</p><p>이 때 미들웨어를 작성하면서 쿠키 이슈가 생겼는데, 백엔드 단에서 Set-cookie를 해주더라도 next서버에는 쿠키라는 개념이 없기 때문에 next서버에서의 요청에서 쿠키가 담겨가지 않아 인증 요청을 할 수가 없었습니다. 이를 해결하기 위해 로그인시 브라우저에 Set-cookie된 토큰들을 직접 next서버에 변수로 불러와 header의 cookie로 직접 넣어서 api 요청을 해주어야 했어요. ‘next-client-cookies&#x2F;server’의 CookiesProvider를 RootLayout에 감싸주어 서버 컴포넌트와 클라이언트 컴포넌트에서 쿠키들을 공유할 수 있게 했습니다. 이후엔 Set-cookie한 토큰들의 값을 로그인시 읽어와 CookiesProvider에 따로 set 해주어 미들웨어에서 토큰들을 읽을 수 있게 하였고, 마찬가지로 로그아웃 시에는 따로 CookiesProvider의 토큰 값들을 remove 해주는 로직을 추가해주는 것으로 해결했습니다.</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>2주간의 협업 프로젝트는 저의 역량을 한층 더 끌어올려준 것을 넘어서 다른 사람들과의 협업이 어떻게 진행되고 그 안에서 제가 어떤 방식으로 다른 사람들에게 내 요구를 전할지, 어떻게 표현할지를 생각해보는 계기가 되었습니다. 어느덧 벌써 ‘파이널 프로젝트’를 앞두고 있는데요. 이 경험을 잘 살려서 파이널 프로젝트 또한 잘 마무리하고 찾아뵙겠습니다!</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/12/15/fc-yanolja/retrospective_mini/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_과정 중간 회고</title>
      <link>https://namgungjongmin.github.io/2023/11/18/fc-yanolja/retrospective_middle/</link>
      <guid>https://namgungjongmin.github.io/2023/11/18/fc-yanolja/retrospective_middle/</guid>
      <pubDate>Fri, 17 Nov 2023 15:11:16 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/b6ddf37a-7880-49ca-9bd1-1db35537648c/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;오늘 포스팅은 지금까지 약</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/b6ddf37a-7880-49ca-9bd1-1db35537648c/image.png"></p><blockquote><p>오늘 포스팅은 지금까지 약 4개월 과정동안 패스트캠퍼스 부트캠프 과정을 진행하면서 경험한 것들과 느낀점들을 공유하려고 합니다. 이젠 정말 과정의 반을 넘기게 되었는데요 회고를 작성하려고 지난 저의 발자취들을 따라가본 결과 정말 많은 성장을 했음을 알 수가 있었어요! 제 성장의 토대가 되어주신 강사님들과 멘토님, 그리고 운영진 분들께 모두 감싸의 말씀 올립니다.</p></blockquote><h1 id="1-HTML-x2F-CSS"><a href="#1-HTML-x2F-CSS" class="headerlink" title="1. HTML&#x2F;CSS"></a>1. HTML&#x2F;CSS</h1><p>HTML&#x2F;CSS는 사실 부트캠프 과정을 시작하기 전에도 학습을 했던 부분이었기에 이번 과정에서는 보다 심화된 내용들을 학습하고 싶었습니다. 단순한 마크업 구현에서 벗어나 접근성과 웹표준, 그리고 최적화 관점에서 양질의 코드를 쓸 수 있도록 공부해야겠다는 생각을 했습니다.</p><p>HTML&#x2F;CSS과제는 원하는 사이트를 하나 선정해서 클론 코딩을 하는 것이었습니다. 앞서 말한 여러 추가적인 공부 내용들을 적용해보고자 노력했습니다.</p><h2 id="The-Armor-Bearer-클론"><a href="#The-Armor-Bearer-클론" class="headerlink" title="The Armor Bearer 클론"></a>The Armor Bearer 클론</h2><p>깃허브 링크: <a href="https://github.com/NamgungJongMin/Yanolja_FE_HTML-CSS">https://github.com/NamgungJongMin/Yanolja_FE_HTML-CSS</a></p><p><img src="https://velog.velcdn.com/images/vbghdl/post/b5062c35-12f5-4eeb-9edf-b62c6d459f17/image.png"></p><p>이 프로젝트를 하면서 Scss의 활용을 좀 더 심화해서 익힐 수 있었습니다. BEM 방법론을 적용하면서 중첩규칙을 보다 효율적으로 이용할 수 있었고, Mixin 등의 유틸함수를 통해 유지보수면에서도 더 나은 코드가 무엇일지 고민해볼 수 있는 시간이었습니다.</p><p>또한 스크린리더 사용자의 긍정적 경험을 위해 디자인적 요소라 읽어주지 않을 요소와 읽어주진 않지만 어떤 섹션인지 설명해주어야 할 것 같은 부분에 읽어주도록 처리해주었습니다.</p><p>추가로 렌더링 관점에서 웹성능을 끌어올릴 수 있는 방법에 대해 고민했습니다. 이미지 최적화와 스타일 적용 방식의 최적화를 고민하고 적용해보면서 매우 값진 시간을 보낼 수 있었습니다.</p><h1 id="2-Javascript"><a href="#2-Javascript" class="headerlink" title="2. Javascript"></a>2. Javascript</h1><p>자바스크립트의 경우에는 프로젝트를 생성하고 진행하면서 어떤 폴더 구조를 사용할지, 같은 기능이라도 어떤 방식이 유지보수에 도움이 될지에 대한 고민을 많이 했던 것 같습니다.</p><h2 id="직원-관리-서비스"><a href="#직원-관리-서비스" class="headerlink" title="직원 관리 서비스"></a>직원 관리 서비스</h2><p>깃허브 링크: <a href="https://github.com/NamgungJongMin/Yanolja_FE_JavaScript">https://github.com/NamgungJongMin/Yanolja_FE_JavaScript</a></p><p><img src="https://velog.velcdn.com/images/vbghdl/post/1b2e01ac-364f-4759-8f77-5e2d4ee5e6d4/image.png"><br><img src="https://velog.velcdn.com/images/vbghdl/post/af8a550d-d05e-463a-b96d-175a88bc6db9/image.png"><br><img src="https://velog.velcdn.com/images/vbghdl/post/9847506c-9f75-4b04-9ec1-6e27cccf5399/image.png"></p><p>로그인&#x2F;회원가입 기능을 구현하면서 한 스크립트 파일에 담는 것이 아니라 스키마로 분류하고 validation 결과를 반환하는 getter함수를 지니는 객체를 만들어 파일을 분리해주었습니다. 단순히 어떻게 구현할지가 아니라 어떤 방법으로 구현해 나갈지 고민할 수 있는 뜻 깊은 시간이었어요.</p><h1 id="3-토이프로젝트-1"><a href="#3-토이프로젝트-1" class="headerlink" title="3. 토이프로젝트 1"></a>3. 토이프로젝트 1</h1><p>다음으로 진행된 토이프로젝트는 팀과 함께하는 협업 프로젝트였습니다. 제가 무려… 팀장을 맡았답니다. 단순히 혼자 하는 것에 비해 서로에 맞추고 또 일정을 조율해나가면서 전체적인 코드 컨벤션도 맞춰야 했습니다. 또한 커밋 방식이나 브랜치 분기 전략 등을 도입해보면서 실제 현업에서 일하는 개발자 분들의 입장을 쪼..곰? 이나마 체험해볼 수 있었습니다.</p><h2 id="직원-위키-사이트"><a href="#직원-위키-사이트" class="headerlink" title="직원 위키 사이트"></a>직원 위키 사이트</h2><p>깃허브 링크: <a href="https://github.com/NamgungJongMin/toy1">https://github.com/NamgungJongMin/toy1</a></p><p><img src="https://velog.velcdn.com/images/vbghdl/post/151e69b8-9ab9-4fba-a23a-5249d0253ef8/image.png"><br><img src="https://velog.velcdn.com/images/vbghdl/post/09068c07-dea1-4430-8a3a-2fa1ea76536e/image.png"></p><p>처음으로 파이어베이스를 사용해보면서 데이터들을 실제 저장하고 가져오는 것들을 해볼 수 있었습니다. 너무 흥미로웠어요. 협업 프로젝트는 단순히 혼자하는 프로젝트와는 정말 달랐습니다. 팀원들에게 모르는 것들을 질문하고 또 내가 질문 받았을 때 해결해주면서 뿌듯함을 느꼈고, 함께 무언가를 만들어 나간다는 고양감을 느낄 수 있었던 것 같습니다. 실제 현업에 가서도 다른 사람들과 일을 하게 될텐데 앞서 경험한 팀 프로젝트는 큰 힘이 되어줄 것이라고 생각합니다.</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>어떠신가요?! 패스트캠퍼스 부트캠프를 통해 점점 더 고민하고, 노력하고, 성장해나가는 제 모습이 보이셨나요? 오늘 회고 포스팅은 단순히 글을 쓰는 것을 넘어 지금까지의 저를 되돌아보고 반성하고, 잘했다 기특하게 생각할 수 있었습니다. 여러분들도 지금 고민하고 있다면 도전하세요. 당장은 미약하더라도 노력하는 시간은 절대 배신하지 않을거에요. 오늘 포스팅도 읽어주셔서 너무 감사했습니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/11/18/fc-yanolja/retrospective_middle/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_강사진 &amp; 멘토 후기</title>
      <link>https://namgungjongmin.github.io/2023/10/27/fc-yanolja/teacher-metor/</link>
      <guid>https://namgungjongmin.github.io/2023/10/27/fc-yanolja/teacher-metor/</guid>
      <pubDate>Fri, 27 Oct 2023 13:15:06 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/9e036891-73ba-421f-84e7-47b199aa339d/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;지금까지 패스트캠퍼스 X </description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/9e036891-73ba-421f-84e7-47b199aa339d/image.png"></p><blockquote><p>지금까지 패스트캠퍼스 X 야놀자 부트캠프가 어떤식으로 진행되어 가는지를 소개했었는데요, 오늘은 부트캠프의 강사분들의 약력과 함께 실제 강의를 들어본 입장에서 후기를 전해드리고자 합니다. 또한 현재 진행되고 있는 멘토님과의 멘토링이 어떻게 도움이 되고있는지도 이야기 해볼게요.</p></blockquote><h1 id="부트캠프-강사진"><a href="#부트캠프-강사진" class="headerlink" title="부트캠프 강사진"></a>부트캠프 강사진</h1><h2 id="박영웅-강사님"><a href="#박영웅-강사님" class="headerlink" title="박영웅 강사님"></a>박영웅 강사님</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/9a658f58-3058-4295-b642-262fd33dec9a/image.png"></p><p>부트캠프에서 가장 먼저 강의를 통해 만나뵙게 된 박영웅 강사님! 프론트엔드의 기초라고 할 수 있는 HTML과 CSS, 그리고 Javascript에 대한 온라인 강의를 통해 만나뵈었습니다.</p><p>특히 Javascript의 경우에는 앞으로 배울 현업에서 쓰이는 중요한 기술들의 토대가 되기 때문에 확실히 공부해야한다고 생각했었습니다. 박영웅 강사님의 강의 같은 경우 우선적으로 이론에 대해 자세하게 정리하신 후 저희가 자주 접할 수 있는 사이트들을 실습으로 코딩하면서 이론들이 어떻게 실제 개발과정에서 쓰이는지를 학습할 수 있었습니다.</p><p>실습 강의로 API를 활용한 영화검색 사이트 만들기를 진행해 주셨는데요, 단순히 자바스크립트를 이용한 동적 구현뿐만 아니라 컴포넌트의 개념까지 설명해주시면서 실제 프로젝트의 적용할 수 있는 디렉토리 구성과 라우팅까지 학습할 수 있는 정말 좋은 강의라고 생각합니다.</p><p>사실 이 강의를 볼때마다 아쉬웠던 점이 하나 있어요. 저희가 두번째 과제로 Javascript를 활용한 사이트를 만들었었는데, 과제 시점이 이 실습 강의를 듣는 시점 이전이었기 때문에 많이 헤맸습니다. 과제를 제출한 뒤에 강의를 듣고는 ‘아 강의를 듣고 과제를 했다면 정말 수월하게 할 수 있었겠다.’라는 생각이 들었습니다.</p><h2 id="안재원-강사님"><a href="#안재원-강사님" class="headerlink" title="안재원 강사님"></a>안재원 강사님</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/7cc3aa0c-ebff-4c52-aa98-2f845470670d/image.png"></p><p>안재원 강사님은 리액트와 여러가지 프레임 워크들을 강의해주셨습니다. 온라인 강의와 더불어 실시간 강의를 통해서 여러가지 실습들을 통해 다양한 개발 경험을 할 수 있도록 해주셨어요.</p><p>현업에서 현재 가장 많이 사용하고 있는(취업에 제일 중요하다고 해요) React와 프레임워크들을 강의해주셨어요. 특히 실습위주의 강의이다보니 매 강의마다 시간이 훌떡훌떡 갔습니다.</p><p>중요한 점은 실습을 통한 코드 따라치기를 벗어나 다시 한번 학습한 내용에 대해 되돌아보는 시간이 매우 중요하다는 생각을 하게 됬어요. 실습을 통해 개발을 매끄럽게 진행하시는데 따라치다보면 어느새 완성되어가는 결과물들이 내 실력이라는 착각을 할 수 있겠다고 생각했습니다.</p><p>막상 혼자 무에서부터 개발을 시작하려다보면 무엇을 해야할지 감이 안잡히고 헤매는 경우가 생기곤 해요. 그래서 그러지 않도록 어떻게 접근하셨고, 왜 이것부터 하셨지?, 왜 이 메소드를 사용하셨을까와 같은 점들을 바로바로 질문하면서 메모해두려고 노력을 많이 했습니다.</p><h2 id="나동빈-강사님"><a href="#나동빈-강사님" class="headerlink" title="나동빈 강사님"></a>나동빈 강사님</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/ad8151a1-0f99-490d-bed7-1c11660f57a3/image.png"></p><p>나동빈 강사님은 패스트캠퍼스 X 야놀자 부트캠프의 알고리즘 강의를 맡아주셨어요. 특히 저는 그룹스터디를 통해 매주 알고리즘 주제를 정하고 해당 알고리즘의 대표 문제들을 풀어오고 있었는데 도움을 많이 받았습니다.</p><p>이번 주의 주제가 BFS라면 해당 주제에 대한 나동빈 강사님의 녹화강의를 듣고 정리한 뒤에 문제를 풀면서 머리로 이해한 개념들을 문제 풀이에 적용하는 방식으로 공부했습니다.</p><p>특히 단순한 개념 강의만이 아니라 어떤 문제들을 만났을 때 해당 알고리즘을 떠올려야 하는지, 알고리즘이 문제마다 어떤식으로 구현되는지를 여러 예시 문제들을 풀어주시면서 자연스럽게 코딩테스트 문제들을 익힐 수 있도록 강의하시는게 정말 좋았습니다.</p><blockquote><p>나동빈님은 사실 부트캠프를 시작하기 이전에도 유튜브를 통해 몇번 뵌적이 있었어요. 그때마다 어떤식으로 개발 공부를 할지, 코딩테스트 공부는 어떻게 준비해야하는지 등에 대해 많은 조언이 담긴 영상들을 통해 큰 도움을 받았다고 생각했는데 이번 부트캠프에서 강사진으로 만나뵙게 되니 너무 반가웠습니다.</p></blockquote><h1 id="그룹-7조-멘토님"><a href="#그룹-7조-멘토님" class="headerlink" title="그룹 7조 멘토님"></a>그룹 7조 멘토님</h1><h2 id="서정현-멘토님"><a href="#서정현-멘토님" class="headerlink" title="서정현 멘토님"></a>서정현 멘토님</h2><p>저희 그룹에서 멘토링을 해주시는 서정현 멘토님! 현재 현업에서 근무하고 계십니다. 따라서 개발 외적인 부분들에 대해서도 질문을 많이 드리고 도움이 되는 답변을 많이 얻어가는 것 같아요.</p><p>예를들어, 스타트업에 취직을 하게 된다면 어떤 기업들을 선택해야 하는지, 취업 프로세스 등과 같은 것들도 물어봅니다. (현업에서 근무하시면서 실제 팀원들을 뽑는 위치시다보니 취업관련 질문들에 대해서도 도움이 되는 답변들을 많이 해주세요!)</p><p>부트캠프가 진행되면서 개발와중 생기는 궁금점들을 모두 질문하기보다는 웹서칭을 통해 스스로 해결하게 되는 경우가 많아지면서 저희 조의 질문들이 점점 적어지는 것 같아요. 하지만 매 멘토링 시간마다 최대한 많은 도움을 주기 위해서 노력해주시는게 느껴집니다.</p><p>요즘에는 질문이 적어 시간이 남을 때는 면접관련 도움을 주시기로 해주셨어요. 실제 팀원들을 선별하는 경험과 취업을 위한 면접을 둘다 경험해보셨기 때문에 주시는 면접 질문들 하나하나 소중히 기록하고 답변할 수 있도록 준비하려고 노력하고 있습니다.</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>오늘 포스팅에서 패스트캠퍼스 X 야놀자 부트캠프의 강사분들과 멘토님을소개하고 부트캠프 과정 중 느꼈던 여러가지 점들을 적어보았습니다. 이 포스팅을 보시는 분들이면 아마 국비지원이나 부트캠프 등에 관심이 있으신 분들이라고 생각됩니다. 저는 패스트캠퍼스에서 운영하는 부트캠프가 좋은 강사분들과 커리큘럼을 가지고 있다고 생각해요. 제 포스팅들이 여러분의 선택에 도움이 되었으면 좋겠다고 생각합니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/10/27/fc-yanolja/teacher-metor/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_워크샵 &amp; 멘토링</title>
      <link>https://namgungjongmin.github.io/2023/10/13/fc-yanolja/workshop/</link>
      <guid>https://namgungjongmin.github.io/2023/10/13/fc-yanolja/workshop/</guid>
      <pubDate>Fri, 13 Oct 2023 14:01:29 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;저번 포스팅에서 그룹스터디</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png"></p><blockquote><p>저번 포스팅에서 그룹스터디 팀 결성과 진행 방식 그리고 후기를 알려드렸었어요. 패스트캠퍼스 X 야놀자 부트캠프에서는 각 팀 별 그룹스터디만 진행되는 것이 아니라 주기적으로 워크샵을 통해 부트캠프를 함께 하는 동기생들이 어떤 방식으로 공부를 이어나가고 있는지 이야기를 나눠볼 수 있는 시간이 있었습니다. 오늘은 두번에 걸쳐 진행된 워크샵 후기와 함께 저번에 말씀드렸던 패스트캠퍼스 X 야놀자 부트캠프의 장점이라고 언급했던 멘토링 후기에 대해서 이야기하려 합니다.</p></blockquote><h1 id="1차-부트캠프-워크샵"><a href="#1차-부트캠프-워크샵" class="headerlink" title="1차 부트캠프 워크샵"></a>1차 부트캠프 워크샵</h1><p>7월 24일에 그룹스터디 워크샵을 가졌습니다. 이번 워크샵에서는 각 그룹스터디 별로 어떻게 진행되어 가는지, 느낀점들이나 공유하고 싶은 내용등을 자유롭게 이야기하는 시간이었습니다. 각 그룹스터디 별로 스터디 주제나 진행 방식들이 차이가 있어서 좋은점들은 우리 스터디에도 적용하고 싶은 마음에 정말 열심히 들었던 것 같습니다. 뿐만아니라 우리 스터디에서 잘 적용되고 있는 방식들을 자랑하고 싶은 마음도 있었던 것 같아요!</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/50a48252-2ce3-415d-a3fd-aa59a79a1c0c/image.png"></p><p>저희 조는 노션을 통해 발표자료를 준비해 워크샵을 준비했습니다. 저희 조원들 소개와 스터디 진행방식 그리고 느낀점들을 발표자료로 준비했습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/1cf733f9-082d-4e32-afef-bd7355f6b6fc/image.png"></p><p>저번 포스팅에서 다뤘던 코딩테스트 스터디에 대한 발표 자료네요. 백준을 통해 각 알고리즘별로 이론 공부와 더불어 대표 문제들을 학습했습니다.</p><blockquote><p>이제는 알고리즘 별 대표문제들을 쭉 훑고나서 프로그래머스에서 기출문제들 위주로 코딩테스트 스터디를 진행하고 있어요!! 확실히 알고리즘별로 학습을 탄탄히 한 뒤에 기출문제 풀이로 넘어가니 문제를 접근하는 방식이나 풀이에 있어서 도움을 많이 받는 것 같습니다.</p></blockquote><p><img src="https://velog.velcdn.com/images/vbghdl/post/4c07f09c-28a5-4c9c-8792-6f8bf1c1483a/image.png"></p><p>다음으로는 자바스크립트 딥다이브 스터디에 대한 발표 자료인데요, 각자 발표를 준비한다는 마음으로 책을 정독하고 뽑기로 걸린 팀원이 주제들에 대해 설명한다는 방식은 다른 많은 팀들에게 좋은 호응을 얻었습니다! 그분들 스터디에도 적용하는 것을 고민한다는 이야기도 들었어요.</p><p>사실 900쪽이 넘어가는 이 두꺼운 책을 팀원들과 언제 다 읽을 수 있을까 걱정이 많았는데 지금 이 글을 쓰는 지금은 벌써 완독을 눈앞에 두고 있답니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/c2c9ec52-96bb-4ead-8abb-1367ba435ab4/image.png"></p><p>저희 그룹 뿐만아니라 다름 스터디그룹에서도 정말 열심히 스터디를 진행하고 계신거 같더라구요. 저희와 다른 방식을 선택한 그룹이나 저도 꼭 해보고 싶은 주제를 선정해 스터디를 진행하는 팀들도 있었습니다. 특히 그룹원들끼리 토이프로젝트를 진행하는 팀이 흥미로워서 주기적으로 팀 노션을 눈팅해왔는데, 이번 워크샵을 통해 어떤 결과물들을 만들고 있는지 자세히 소개해주셔서 너무 재밌었던 것 같아요.</p><h1 id="2차-부트캠프-워크샵"><a href="#2차-부트캠프-워크샵" class="headerlink" title="2차 부트캠프 워크샵"></a>2차 부트캠프 워크샵</h1><p>8월 25일에는 두번째 워크샵이 진행되었습니다. 이전 그룹스터디 워크샵과는 다르게 각 개인이 그 동안 부트캠프를 진행하면서 느낀점이나 배운점들 또는 공유하고 싶은 주제들에 대해서 이야기하는 시간이었습니다. 추가로 진행된 ‘천하제일 내 꿀통 자랑대회’ !!!<br>주제를 선정해 발표하고 참여자 전원 상품까지 얻어갈 수 있는 좋은 기회였습니다. 한치의 고민도 없이 바로 참여했습니다 😁</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/eea7ef38-8c78-4a72-a4a5-62a9d74519d5/image.png"></p><p>발표자 분들이 생각보다 많이 적었어요. 저를 포함해 네분이 발표를 진행하셨습니다. 아마 발표에 대해 부담감이 있으신 분들이 있으셨던 것 같아요. 그 동안 눈팅해온 동기생분들 중에는 정말 실력자분들이 많으셔서 기대했는데 아쉬웠습니다 ㅠㅠ.</p><h2 id="천하제일-내-꿀통-자랑대회-발표"><a href="#천하제일-내-꿀통-자랑대회-발표" class="headerlink" title="천하제일 내 꿀통 자랑대회 발표"></a>천하제일 내 꿀통 자랑대회 발표</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/fea9756d-d132-4866-be3a-2731b48ada2b/image.png"></p><p>저는 웹 성능과 성능 지표를 활용한 최적화라는 주제로 발표를 했습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/a37446ab-99af-491b-a395-ac1b6f45a7eb/image.png"></p><p>우선 성능에 대한 전반적인 설명에 앞서 필요한 지식인 렌더링 과정에 대해서 이야기하고, 성능 개선의 필요성을 설명한 뒤 다양한 성능 지표에 대해 소개하고 그 지표를 기반으로한 최적화 방안에 대해 이야기했습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/a6128709-f2dd-4aa0-b693-95c44044c095/image.png"></p><p>성능 개선의 필요성을 엘레베이터 닫기 버튼을 누르는 우리의 모습과 연관지어 설명해보았는데 참 괜찮은 예시였던 것 같아요^^.</p><p>많이 떨리기도 했지만 한편으로는 설렘 가운데서 발표를 잘 마무리할 수 있었습니다.</p><blockquote><p>마지막 발표인데다 다른 분들에 비해 긴 시간의 발표여서 더 떨렸던 것 같아요. 시간이 너무 길까 말도 너무 빨랐던 것 같고… 경험삼아 다음번엔 더 잘할 수 있겠죠?</p></blockquote><p><img src="https://velog.velcdn.com/images/vbghdl/post/e1fcbe2e-c1bb-4fcd-b83f-cbe4db63b0a1/image.png"></p><p>다른 분들의 발표 중에 특히 어승준님의 optimistic ui 와 pasimistic ui에 대한 발표는 정말 유익했습니다. 부트캠프의 장점! 동기생들과의 연결. 바로 DM을 드려 이야기를 나누고 발표자료들을 교환한 뒤 주말에 공부했습니다. 너무 너무 유익했습니다.</p><p>워크샵이 잘 마무리되고 상품도 잘 받았답니다. 아! 저는 ‘개발자의 글쓰기’라는 책을 선택해서 받았어요!</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/cc77e27b-9190-4f15-b536-5562542ea4cd/image.png"></p><h1 id="그룹스터디-멘토링"><a href="#그룹스터디-멘토링" class="headerlink" title="그룹스터디 멘토링"></a>그룹스터디 멘토링</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/883458f4-9840-4217-ad1e-43eeac5ec1f3/image.png"></p><p>패스트캠퍼스 X 야놀자 부트캠프의 큰 장점이라고 저번 포스팅에서 이야기 했던 멘토링입니다. 공부를 하면서 모르는 내용들 궁금한 내용들을 그때마다 요청서에 적어두면 현직 멘토님의 답변과 함께 일주일에 한번 있는 멘토링 시간에 이야기를 나눠볼 수 있었습니다.</p><blockquote><p>사실 처음에는 멘토링이라는 것이 이 정도로 좋을지 몰랐어요. 우리가 공부를 하다가 궁금한 것이 생기면 질문하고 답변을 기다리기 보다는 구글링등을 통해 바로바로 알고 해결하려고 하잖아요. 그런데 꼭 개발 지식에 관련된 내용이 아니더라도 직접 취업 후 경험을 통해 알 수있는 내용들이나 질문하기 어려운 추상적인 것들도 대화를 통해 충족시킬 수 있다는 점이 너무나도 좋았습니다.</p></blockquote><p>질문이 없을 때 이 귀중한 멘토링 시간을 어떻게 써야할지는 항상 고민이었습니다. 그래서 멘토님과의 이야기를 통해 남는 시간은 저희 면접 준비를 도와주시기로 하셨어요! 멘토님께서 직접 경험하셨던 면접 질문들이나 실제 팀원을 뽑으실 때 물어볼 것 같은 질문들을 저희에게 제시해주시고 답변을 들어주시며 교정해주시는데 너무나 유익한 것 같습니다.</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>패스트캠퍼스 X 야놀자 부트캠프를 진행하면서 부트캠프로 이곳을 선택한 것이 정말 확실한 선택이었다는 것을 요즘 계속해서 느끼고 있습니다. 과정 중 진행되는 앞서 소개한 여러가지들 중 도움이 되지 않는 것이 단 하나도 없는 것 같아요. 제가 쓰는 후기들이 국비지원이나 부트캠프를 고려하는 다른 학우분들께 도움이 되셨으면 좋겠습니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/10/13/fc-yanolja/workshop/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_그룹스터디</title>
      <link>https://namgungjongmin.github.io/2023/09/21/fc-yanolja/group-study/</link>
      <guid>https://namgungjongmin.github.io/2023/09/21/fc-yanolja/group-study/</guid>
      <pubDate>Thu, 21 Sep 2023 13:11:15 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/1e9ac916-94b3-4bd5-ba78-e69f4e3c0dad/image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;그룹스터디-팀-결성&quot;&gt;&lt;a href=&quot;#</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/1e9ac916-94b3-4bd5-ba78-e69f4e3c0dad/image.png"></p><h1 id="그룹스터디-팀-결성"><a href="#그룹스터디-팀-결성" class="headerlink" title="그룹스터디 팀 결성"></a>그룹스터디 팀 결성</h1><p>패스트캠퍼스 X 야놀자 부트캠프의 시작과 함께 그룹이 배정되었습니다!!. 성후님, 혜민님, 홍규님, 수연님, 영민님, 그리고 저 이렇게 6명의 그룹원들이 한팀이 되었어요. 그룹의 팀장은 성후님께서 맡아주시기로 결정되었습니다.</p><p>저희 팀이 7조라 팀명을 ‘마 니 개발좀7나’로 결정하였습니다. 재밌지 않나요?😂 이후엔 회의를 통해 앞으로 우리가 어떤 방식으로 그룹스터디를 운영해나갈지, 무엇을 공부할지에 대해 이야기를 나누었습니다.</p><h1 id="그룹스터디-운영"><a href="#그룹스터디-운영" class="headerlink" title="그룹스터디 운영"></a>그룹스터디 운영</h1><p>패스트캠퍼스 X 야놀자 부트캠프의 그룹스터디는 자유도가 매우 높은 스터디입니다. 그룹스터디 진행 방식과 목적, 목표 그리고 공부할 내용까지도 팀원과의 협의를 통해 결정하고 팀별로 알아서 이루어지게 됩니다.</p><p>그룹스터디의 진행사항은 노션을 통해 정리하게 되었습니다. 패스트캠퍼스 X 야놀자 부트캠프의 노션에 저희 그룹스터디 페이지가 생성이 되었네요!<br><img src="https://velog.velcdn.com/images/vbghdl/post/91ac3510-6a78-4dfc-977d-4f7f64b501e9/image.png"></p><p>저희가 그룹스터디를 통해 이루고자하는 목표는 두가지로 잡았습니다.</p><ol><li>코딩테스트에 합격할 수 있는 수준의 알고리즘 역량을 기른다.</li><li>JavaScript Deep Dive 책을 완독하고, 각 주제를 서로에게 설명해줄 수 있다.</li></ol><p>따라서 그룹스터디에서는 코딩테스트 준비로 알고리즘 공부와 Javascript 이론에 대한 공부가 함께 진행되기로 했습니다.</p><h2 id="1-알고리즘-공부-및-코딩테스트-준비"><a href="#1-알고리즘-공부-및-코딩테스트-준비" class="headerlink" title="1) 알고리즘 공부 및 코딩테스트 준비"></a>1) 알고리즘 공부 및 코딩테스트 준비</h2><p>코딩테스트 준비는 각 주마다 알고리즘 주제를 선정하고 해당 알고리즘을 사용하여 풀 수 있는 코딩테스트 문제를 백준에서 선택하여 풀어옵니다. 이후에는 사다리타기를 통해 문제별 발표자를 선정하고 해당 발표자가 어떻게 문제를 접근했고, 어떻게 풀어나갔는지를 설명합니다. 발표 이후에는 조원들끼리 서로의 풀이과정을 공유하며 코드 리뷰를 하는 시간을 갖게 됩니다.</p><p>Brute Force 알고리즘을 공부한 스터디 내용을 살펴볼까요?</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/dd8f702b-290d-4e62-932d-e8880b95a29f/image.png"></p><p>주제 알고리즘에 대한 설명과 관련된 코딩테스트 문제들, 그리고 문제들을 맡은 발표자들이 정리되어 있네요!</p><p>그 다음에는 해당 문제에 대한 담당자의 풀이와 그것을 비교한 팀원들의 코드리뷰 내용들이 정리되어있습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/61cf9ea4-e2ba-4b94-b4fe-4dd16723423e/image.png"><img src="https://velog.velcdn.com/images/vbghdl/post/2bc41f98-e233-4da6-acf4-7991466d3c25/image.png"></p><p>개인별 문제풀이 코드들을 팀원 모두가 함께 확인하고 자신의 코드와 비교하면서 다른 사람의 문제 접근 방식과 코드 구현 방식을 확인할 수 있었고, 이후 코드리뷰를 통한 토론을 통해 어떤 방식이 더 좋은 방식이고, 좋은 코드인지 이야기를 나눠보면서 JavaScript 코드의 구현 역량을 기를 수 있었습니다.</p><h2 id="2-JavaScript-Deep-Dive-스터디"><a href="#2-JavaScript-Deep-Dive-스터디" class="headerlink" title="2) JavaScript Deep Dive 스터디"></a>2) JavaScript Deep Dive 스터디</h2><p>JavaScript Deep Dive 스터디의 경우 러버덕 방식으로 진행하기로 결정되었습니다. 미리 정한 범위까지 책을 정독하고, 발표자를 선정하여 해당 주제에 대한 내용에 대해 발표하고, 즉각적으로 내용에 대한 이해 여부를 검증하면서 이해하지 못한 문장들에 대해서도 이야기를 나누었습니다. 이 방식을 통해 다음과 같은 이점들을 얻을 수 있었습니다.</p><ol><li>해당 주제에 대한 완벽한 이해</li></ol><blockquote><p>저희는 다른 사람에게 설명할 수 있어야 비로소 자신의 지식이라고 생각했습니다. 해당 주제에 대해 전체적으로 설명할 수 있어야 내가 완벽히 이해한 내용이고, 또한 그렇게 설명을 염두에두고 공부하는 과정에서 주제에 대해 깊이있는 공부가 가능할 것이라고 생각했습니다.</p></blockquote><ol start="2"><li>면접 준비</li></ol><blockquote><p>다른사람에게 설명하는 것을 염두에 둔 공부와 실제 발표는 해당 주제에 대해 자신감을 얻게 될 것이라 생각했습니다. 또한 내 지식을 다른 사람에게 말하는 것을 반복하게 되면서 자연스럽게 면접 준비가 되겠다고 생각했습니다.</p></blockquote><p>이렇게 러버덕을 통한 공부 이후에는 스터디 때 오간 내용들을 종합하여 정리된 내용을 토대로 블로그 포스팅을 통해 해당 주제에 대한 지식을 온전히 자신의 것으로 만들 수 있게 하였습니다.<br><img src="https://velog.velcdn.com/images/vbghdl/post/253e4570-fa3d-4cb8-9696-43f389de5b9c/image.png"><img src="https://velog.velcdn.com/images/vbghdl/post/ce0f8585-29bd-49b6-bf9d-8c0e448803cf/image.png"></p><h2 id="3-그룹스터디-멘토링"><a href="#3-그룹스터디-멘토링" class="headerlink" title="3) 그룹스터디 멘토링"></a>3) 그룹스터디 멘토링</h2><p>그룹스터디 진행이 서로의 의견 교환을 통해 이루어진다는 것은 스스로가 생각할 기회가 많다는 장점이 있지만, 한편으로는 팀원끼리의 소통만으로는 올바른 판단인지를 결정하기 힘들다는 단점이 있었습니다. 모두 공부하는 입장이기 때문에 오고간 이야기들을 객관적으로 검증할 방법이 필요했습니다.</p><p>이를 위해 패스트캠퍼스 X 야놀자 부트캠프에서는 주 1회 그룹별 멘토링 시간을 제공해주었습니다. 멘토님께 질문하면서 현재 스터디 방향이 맞는지 계속 확인하고, 팀원들끼리 판단하지 못했던 여러 주제들에 대해 멘토링을 받을 수 있었습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/86aa6ab8-995c-4a66-b1ff-79b4ed4564e8/image.png"><img src="https://velog.velcdn.com/images/vbghdl/post/6b1e1660-479e-43b0-b92d-4f00beeba51d/image.png"><img src="https://velog.velcdn.com/images/vbghdl/post/31975dc8-a5d2-4ea9-b9fe-7c8e3f278d38/image.png"></p><p>스터디를 진행하면서 궁금한 점들이 생길 때마다 멘토링 사전요청서에 작성하여 해당 질문에 대한 답들을 멘토님께 들을 수 있었고, 추가로 구글밋 등을 활용해 매주 멘토님과 직접 이야기하면서 궁금한 점들을 해결할 수 있었습니다.</p><h1 id="그룹스터디-후기"><a href="#그룹스터디-후기" class="headerlink" title="그룹스터디 후기"></a>그룹스터디 후기</h1><p>그룹스터디의 가장 큰 효과는 자기 자신을 객관화 할 수 있다는 점이었습니다. 내가 어느정도의 실력을 가지고 있는지, 스스로를 팀원들과 비교하면서 파악할 수 있었고 자신의 장점과 부족한점들 또한 배울 수 있는 기회가 되었습니다.</p><p>또한 혼자 공부를 진행해 가는 것은 매너리즘에 빠질 우려가 있습니다. 사람이 항상 의욕적일 수는 없고 어느 순간 나태해질 수 있는데, 확실한 목표 설정과 계획을 통해 강제적으로 공부해야되는 부분이 정해지다보니 항상 일정한 공부량을 채울 수 있게 되었고 하루에 공부하는 공부의 총량또한 늘어난 것이 느껴졌습니다.</p><p>기존에 다른 그룹스터디를 경험해보았지만 패스트캠퍼스 X 야놀자 부트캠프의 그룹스터디의 차별화 된 강점이 느껴진 부분은 지속적인 관리가 이루어진다는 점이었습니다. 그룹스터디 운영방식에 대해서는 자유를 부여하지만 멘토링 시스템의 도입과 운영진 분들의 진행사항 확인 등을 통해 각 그룹별 스터디가 잘 이루어지고 있는지를 지속적으로 검증할 수 있었고, 공부 방향에 대한 확신또한 얻을 수 있었습니다.</p><p>이대로 꾸준히 진행되었을 때 개발자로서의 역량을 키울 수 있다는 것에 확신이 생겼고, 부트캠프를 수료했을 때 얼마나 스스로가 성장해있을지를 기대하게 됩니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/09/21/fc-yanolja/group-study/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
