<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Namgung Jong Min</title>
    <link>https://NamgungJongMin.github.io/</link>
    
    <atom:link href="https://namgungjongmin.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 05 Aug 2024 17:10:52 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_과정 종료 회고</title>
      <link>https://namgungjongmin.github.io/2024/02/11/fc-yanolja/retrospective_all/</link>
      <guid>https://namgungjongmin.github.io/2024/02/11/fc-yanolja/retrospective_all/</guid>
      <pubDate>Sun, 11 Feb 2024 13:54:53 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;파이널 프로젝트가 끝나면서</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png"></p><blockquote><p>파이널 프로젝트가 끝나면서 7개월의 부트캠프 과정이 끝이 났습니다. 길다면 길고 짧다면 짧을 수 있는 시간인데 부트캠프를 진행하기 이전의 저와 수료한 이후의 저는 완전 다른 사람이 된 것 같아요. 사실 처음 시작할 때는 기본적인 클론 코딩도 버거워하던 저였는데 이제는 혼자서 프로젝트를 기획하고 개발하면서 이번엔 어떤 기술을 적용해볼까 행복한 고민을 하고 있어요. 이번 포스팅은 저번에 포스팅 했던 파이널 프로젝트의 결과를 공유해보고, 제가 패스트캠퍼스 X 야놀자 부트캠프를 진행하면서 어떻게 달라졌는지 회고해보려고 해요. 추가로 좋은 소식도 하나 자랑해보려고 합니다. ㅎㅎ.</p></blockquote><h1 id="파이널-프로젝트-끝"><a href="#파이널-프로젝트-끝" class="headerlink" title="파이널 프로젝트 끝!"></a>파이널 프로젝트 끝!</h1><p>패스트캠퍼스 X 야놀자 부트캠프에서 진행한 RFP기반 기업 연계 프로젝트가 끝이 났습니다. 이번 프로젝트는 확실히 기획 분들과 디자이너 분이 계셔서 프론트엔드에서 와이어프레임을 짜고 디자인 했을 때보다 확실히 결과가 잘 나온 것 같아요! 만들어진 사이트를 보면서 “와! 진짜 서비스하고 있는 사이트처럼 생겼다”라고 생각했습니다. 저희가 부트캠프의 마지막을 장식한 프로젝트 결과물을 함께 감상해봐요.</p><h1 id="사이트-핵심-기능"><a href="#사이트-핵심-기능" class="headerlink" title="사이트 핵심 기능"></a>사이트 핵심 기능</h1><p>저번 포스팅에서 투표 기반 여행 일정 앱을 만든다고 했었죠? 우리 앱의 핵심 기능은 다음과 같습니다. 하나씩 살펴봐요.</p><h2 id="1-여행지-투표"><a href="#1-여행지-투표" class="headerlink" title="1) 여행지 투표"></a>1) 여행지 투표</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/60508778-5e1c-4c71-ae9e-7bf9cabea2b2/image.png"></p><h2 id="2-투표-기반-일정-작성"><a href="#2-투표-기반-일정-작성" class="headerlink" title="2) 투표 기반 일정 작성"></a>2) 투표 기반 일정 작성</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/a1151c91-77e5-44a4-8d7e-f5a9a007dbd5/image.png"></p><h2 id="3-루트-최적화"><a href="#3-루트-최적화" class="headerlink" title="3) 루트 최적화"></a>3) 루트 최적화</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/4e68c1bb-468b-4456-bf23-a69d4427aab5/image.png"></p><h2 id="4-여행-정보-검색"><a href="#4-여행-정보-검색" class="headerlink" title="4) 여행 정보 검색"></a>4) 여행 정보 검색</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/20c6e43e-b2ce-4c19-97ed-19c6e7445c8c/image.png"></p><h1 id="랜딩-페이지-생성-및-마케팅"><a href="#랜딩-페이지-생성-및-마케팅" class="headerlink" title="랜딩 페이지 생성 및 마케팅"></a>랜딩 페이지 생성 및 마케팅</h1><p>기획분들 덕분에 마케팅도 경험할 수 있었어요. 랜딩 페이지를 만들고 인스타그램과 페이스북 같은 SNS 마케팅을 통해 사람들에게 저희 앱을 노출시키고 랜딩페이지로 유도하여 사전 예약을 받게 하였습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/35be0e28-007d-4ac5-8b20-3928a5c6eb75/image.png"></p><p>약 일주일 간 랜딩페이지 방문자 413명, CTA 입력폼 섹션 도달 인원 50명, 사전 출시 알림 신청 인원 41명으로 전환율 10%를 달성했습니다!</p><h1 id="트립-보트-소개-영상"><a href="#트립-보트-소개-영상" class="headerlink" title="트립 보트 소개 영상"></a>트립 보트 소개 영상</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/53f51036-afa0-4b85-82a2-c46de47b42f0/image.png"><br><a href="https://www.youtube.com/watch?v=9d4K_1AzSAA">https://www.youtube.com/watch?v=9d4K_1AzSAA</a></p><h1 id="부트캠프-후-나는-어떻게-달라졌을까"><a href="#부트캠프-후-나는-어떻게-달라졌을까" class="headerlink" title="부트캠프 후 나는 어떻게 달라졌을까?"></a>부트캠프 후 나는 어떻게 달라졌을까?</h1><p>부트캠프를 진행하면서 총 4번의 협업 프로젝트를 통해 학습 기간 익혔던 기술들을 적용해볼 수 있었습니다. 부트캠프 이전과 달리 프로젝트마다 적용하게 되었거나 프로젝트를 통해 새로 얻게 된 지식들이 많은 것 같아요. 또 협업 프로젝트로 인해 다른 사람들과 어떻게 함께 개발해야 하는지를 알게 된 것이 너무 좋았습니다.</p><h2 id="1-웹표준-및-웹접근성-적용"><a href="#1-웹표준-및-웹접근성-적용" class="headerlink" title="1) 웹표준 및 웹접근성 적용"></a>1) 웹표준 및 웹접근성 적용</h2><p>저는 패스트캠퍼스 X 야놀자 부트캠프에서 마크업 언어를 배우면서 특히나 웹표준과 웹접근성을 중요하게 생각했던 것 같아요. 어떻게 하면 시멘틱한 마크업을 할 수 있을까, 또 어떻게 해야 모든 사람에게 정보를 공유할 수 있을까 고민했습니다.</p><p>웹표준을 지키기 위해 시멘틱한 마크업을 하려고 했고, 그러기 위해서는 각 태그별 특징을 명확히 인지할 필요가 있었습니다. 특히 각 태그의 특징을 아는 것은 웹 접근성 확보를 위해서도 꼭 필요한 부분이었기 때문에 단순한 기능 구현보다는 의미있는 코드를 작성하려고 노력하게 되었어요.</p><p>예를들어 ol과 ul의 차이점에서 스크린리더가 어떻게 읽어주는지를 고려한다면 같은 리스트 태그라도 어떤 것을 쓰는게 맞을지 한번 더 고민했습니다. 또 스크린리더 사용자를 고려하는 코드들을 프로젝트마다 적용하게 되었어요. 특히나 각 섹션별 설명을 p태그로 넣어두고 디자인 요소를 해치지 않기 위해 accessibility hidden 스타일을 적용하여 읽어주기만 한다던가 반대로 디자인적으로만 사용되는 이미지 요소이기에 스크린리더가 읽어줄 필요가 없는 상황에서는 aria-hidden 속성을 적용하게 되었습니다.</p><h2 id="2-다양한-스타일-라이브러리와-프레임워크-경험"><a href="#2-다양한-스타일-라이브러리와-프레임워크-경험" class="headerlink" title="2) 다양한 스타일 라이브러리와 프레임워크 경험"></a>2) 다양한 스타일 라이브러리와 프레임워크 경험</h2><p>또 다양한 스타일 라이브러리와 프레임워크를 경험하면서 “어떨 때 어떤 것을 써야겠다”하는 자신만의 기준도 생기게 되었습니다. 예를 들어 생산성이 중요한 프로젝트에서는 tailwindCSS와 같은 유틸리티 퍼스트 스타일 프레임워크를 통해 빠른 개발을 할 수 있었고, 충분한 기획과 디자인 시스템 아래에서 시작된 개발에서는 Sass를 이용하여 다양한 함수와 mixin을 통해 디자인 시스템에 맞춰 세팅을 해두고 개발에 들어간다면 훨씬 수월하게 개발이 진행된다는 것을 경험했어요.</p><p>또 차크라 ui와 MUI와 같은 라이브러리를 통해 보다 쉽게 ui 컴포넌트를 구현해볼 수 있었습니다. 다만 ui 컴포넌트 라이브러리의 경우 커스터마이징이 오히려 생개발보다 힘든 경우도 있었기 때문에 기획의 디자인이 라이브러리 테마와 거리가 멀다면 오히려 적용하지 않거나 headless ui를 적용하는 것이 좋겠다는 생각을 했습니다.</p><h2 id="3-다양한-협업-툴과-git-전략-이용-경험"><a href="#3-다양한-협업-툴과-git-전략-이용-경험" class="headerlink" title="3) 다양한 협업 툴과 git 전략 이용 경험"></a>3) 다양한 협업 툴과 git 전략 이용 경험</h2><p>총 4번의 협업프로젝트를 진행했습니다. 디자인, 기획, 백엔드, 프론트엔드가 함께 프로젝트를 경험하게 되면서 실제 기업에서 어떻게 함께 일하게 될지를 미리 경험해본 느낌이었어요. 또 다양한 협업 툴을 통해 일정을 관리하고 소통하면서 커뮤니케이션 능력을 익혔구요.</p><p>또 프로젝트마다 다양한 프로젝트 관리 전략을 적용해보면서 협업을 경험할 수 있었습니다. jira나 github project 경험, 그리고 gitflow와 같은 브랜치 관리 전략 등을 적용해보면서 이제 실무에 들어가서도 다른 사람과 함께 협업할 능력을 갖추었다는 자신감을 가질 수 있게 되었습니다.</p><h2 id="4-스스로-학습하는-방법을-익힘"><a href="#4-스스로-학습하는-방법을-익힘" class="headerlink" title="4) 스스로 학습하는 방법을 익힘"></a>4) 스스로 학습하는 방법을 익힘</h2><p>패스트캠퍼스 X 야놀자 부트캠프는 온라인으로 진행되었습니다. 제공된 강의를 통해 정해진 커리큘럼을 따라가면서 자기가 원하는 공부를 추가적으로 진행할 수 있었던 점이 저에게는 정말 큰 성장의 발판이 되었던 것 같아요.</p><p>개발을 공부하다보면 배운 지식들에서 새로운 가지들이 자꾸 나오는 것을 경험했습니다. 이것들을 ‘앨리스의 토끼굴’이라고 표현하더라구요. 그래서 그런 지식들까지 다 공부해서 섭렵해버리겠다! 라는 생각을 제 모토로 삼았습니다. 그래서 제 프로필 소개가 ‘토끼굴을 정복하는 개발자’에요 ㅎㅎ.</p><p>강의를 통해 html5를 배우면서 웹 접근성이라는 개념을 알게 되었고, 이렇게 연결된 지식들을 더 공부하기위해 WCAG2.1을 공부하면서 더 깊은 이해가 가능했어요. 만약 다른 커리큘럼 진행만을 강요하는 부트캠프였다면 이런식의 공부가 힘들었을 것 같아요.</p><h2 id="5-유저-뿐만이-아니라-기업의-입장에서도-코드를-작성할-수-있게-됨"><a href="#5-유저-뿐만이-아니라-기업의-입장에서도-코드를-작성할-수-있게-됨" class="headerlink" title="5) 유저 뿐만이 아니라 기업의 입장에서도 코드를 작성할 수 있게 됨"></a>5) 유저 뿐만이 아니라 기업의 입장에서도 코드를 작성할 수 있게 됨</h2><p>프론트엔드 개발자가 유저 중심의 코드를 작성해야 한다는 것은 모두가 알고 계실 내용일 것 같아요. 그런데 기업의 입장에서도 고민을 해보는 것이 필요하다고 생각합니다. 여러 프로젝트를 진행하고 또 배포와 관련하여 여러 비용 처리를 경험하게 되면서 기업의 입장에서 코드를 작성하는 것이 필요한 일이라는 것을 깨닫게 되었습니다.</p><p>예를들어 서버 비용을 줄이기 위해 서버에 fileList를 그대로 전달하는 것이 아닌 S3의 Presigned URL을 이용하여 따로 업로드하고, 그 url만 서버에 전달해주어 서버 비용을 낮출 수 있었어요.</p><h1 id="부트캠프-수료"><a href="#부트캠프-수료" class="headerlink" title="부트캠프 수료!!!!!"></a>부트캠프 수료!!!!!</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/86d0fba3-6ee5-4a0e-b7fa-80d91fd879f9/image.png"></p><p>드디어 부트캠프를 수료하게 되었네요. 7개월이 짧은 시간은 아니지만 저에게는 정말 순식간에 지나간 것 같습니다. 그만큼 부트캠프에 몰입하고 있었던 것 같아요. 좋은 사람들을 많이 만날 수 있었고, 함께 성장할 수 있었어요. 이런 기회를 준 패스트캠퍼스에 정말 감사하는 마음 뿐이랍니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/ae938868-7fcd-48e2-94bc-d34ddb98eb52/image.png"></p><h1 id="내가-최우수-수료생"><a href="#내가-최우수-수료생" class="headerlink" title="내가 최우수 수료생!!"></a>내가 최우수 수료생!!</h1><p>너무나 감사하게도 이번 부트캠프 최우수 수료생으로 선정되었습니다. 과정 진행 동안의 프로젝트와 과제, 퀴즈 등을 종합하여 선정되었는데, 정말 수강생 분들끼리의 점수 차이가 미미하더라구요. 운이 좋았다는 생각과 동시에 그만큼 열심히 한 나 자신을 칭찬해주고 싶었습니다. 최우수 수료생에게는 모의 면접과 모의 코딩테스트 등 여러가지 취업을 위한 추가적인 혜택이 있었어요. 잘 활용해서 꼭 원하는 곳에 취업하도록 노력하겠습니다. 그 동안 감사했습니다!</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/02/11/fc-yanolja/retrospective_all/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_파이널 프로젝트 회고</title>
      <link>https://namgungjongmin.github.io/2024/01/31/fc-yanolja/retrospective_final/</link>
      <guid>https://namgungjongmin.github.io/2024/01/31/fc-yanolja/retrospective_final/</guid>
      <pubDate>Wed, 31 Jan 2024 14:34:13 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;돌아온 패스트캠퍼스 X 야</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png"></p><blockquote><p>돌아온 패스트캠퍼스 X 야놀자 부트캠프 포스팅입니다! 2024년의 새로운 해의 시작과 함께 1월부터 저희 부트캠프에서는 ‘파이널 프로젝트’를 진행했습니다. 이번 프로젝트에서는 기획, 디자인, 백엔드, 프론트 각 포지션들이 하나의 팀을 이루어 진행하게 되었습니다. 저번 미니 프로젝트에서는 백엔드와 프론트 두 포지션만이 있었기 때문에 개발 외적으로도 디자인이나 앱 기획 등을 신경쓸게 많았는데요! 이번 파이널 프로젝트에서는 기획분들의 요청에 맞추어 구현만 하면되었기 때문에 개발에만 집중할 수 있어서 정말 좋았던 것 같아요.</p></blockquote><h1 id="기업-연계-프로젝트"><a href="#기업-연계-프로젝트" class="headerlink" title="기업 연계 프로젝트"></a>기업 연계 프로젝트</h1><p>이번 프로젝트는 야놀자의 기업 RFP를 제안서를 토대로 개발이 이루어졌습니다. 패스트 캠퍼스 X 야놀자 부트캠프에서만 경험할 수 있는 최고의 프로젝트라고 생각했어요. 실제 기업의 문제 및 니즈를 분석하고 스스로 해결책을 개발하는 과정을 경험할 수 있었습니다. 개발 중간 중간 야놀자 실무진분들의 멘토링을 받을 수 있었고, 주마다 꾸준하게 진행사항들을 확인하고 그에 대한 의문점이나 조언들을 멘토님에게 얻을 수 있었습니다.</p><h1 id="팀-결성"><a href="#팀-결성" class="headerlink" title="팀 결성!"></a>팀 결성!</h1><p>저희 팀은 ‘여행 여정 공유 플랫폼’을 주제로 개발을 진행하게 되었습니다. 팀 구성은 디자이너 1명, PM 4명, 프론트엔드 6명, 백엔드 5명으로 이루어지게 되었습니다. 미니에 비해 규모가 확 커졌다는 것이 느껴졌어요. 기획분들과 디자이너분이 추가된만큼 피그마도 엄청 무섭게 커졌습니다. 처음엔 와 우리가 저걸 개발할 수 있을까? 싶을정도로요..</p><p>프로젝트 기획과 디자인은 피그마를 통해 진행되었습니다. 디자이너와 기획분들과는 피그마 내의 댓글을 통해 기능들을 구체화하고 완성시켰어요. 각자 작업하면서 의문이 드는 부분이나 수정이 필요하다고 생각되는 부분들은 댓글로 달아놓아 확인할 수 있게 하였고, 구체적인 상의는 매일 있는 코어 타임과 주 한번의 팀 미팅을 통해 방향을 정했습니다.</p><p>디자인의 경우 전체적인 앱의 통일성을 위해 글꼴과 크기, 볼드값을 사용될 컴포넌트별로 정리해주셨고, 앱 전반적으로 사용될 토스트나 알림모달, 그리고 박스들의 형태또한 정해서 전해주셨습니다. 이번 프로젝트에서 저희는 sass를 사용하기 때문에 미리 저렇게 정리해서 주시니 변수들과 함수에 적용시켜 개발을 정말 편하게 할 수 있었어요.</p><h2 id="와이어프레임"><a href="#와이어프레임" class="headerlink" title="와이어프레임"></a>와이어프레임</h2><p><a href="https://www.figma.com/file/oeQ2vOcyO3SuInuMf3Dlj8/%EC%B5%9C%EC%A2%85-%ED%99%94%EB%A9%B4(PM)?type=design&amp;node-id=0-1&amp;mode=design&amp;t=nZD111AWFn7ozFJx-0">https://www.figma.com/file/oeQ2vOcyO3SuInuMf3Dlj8/%EC%B5%9C%EC%A2%85-%ED%99%94%EB%A9%B4(PM)?type=design&amp;node-id=0-1&amp;mode=design&amp;t=nZD111AWFn7ozFJx-0</a></p><p><img src="https://velog.velcdn.com/images/vbghdl/post/4e5289a3-9ced-4cd1-9a32-0855acff9a36/image.png"><br><img src="https://velog.velcdn.com/images/vbghdl/post/a815031a-8123-4363-a3f5-50cd4b95ef3d/image.png"></p><blockquote><p>확실히 디자인, 기획 분들과 함께하는 프로젝트다보니 피그마 규모 부터가 저번 프로젝트랑 다릅니다…ㅠ (내가 할 수 있을까 걱정도 많이 했어요)</p></blockquote><h2 id="디자인가이드"><a href="#디자인가이드" class="headerlink" title="디자인가이드"></a>디자인가이드</h2><p><a href="https://www.figma.com/file/ypTLv92s72sihUApnxjP5C/%EA%B0%95%EC%9E%90%EB%B0%AD-%ED%94%BC%EA%B7%B8%EB%A7%88?type=design&amp;node-id=40-2&amp;mode=design&amp;t=Jf8iEjAoqYVNtYJX-0">https://www.figma.com/file/ypTLv92s72sihUApnxjP5C/%EA%B0%95%EC%9E%90%EB%B0%AD-%ED%94%BC%EA%B7%B8%EB%A7%88?type=design&amp;node-id=40-2&amp;mode=design&amp;t=Jf8iEjAoqYVNtYJX-0</a></p><p><img src="https://velog.velcdn.com/images/vbghdl/post/c654d8fa-fcb2-43d4-87a1-88607add869c/image.png"></p><blockquote><p>디자인 분께서 각 컴포넌트별로 세세하고 통일감있게 작성해주셨어요. 덕분에 미리 sass 변수와 mixin에 등록하고 뽑아쓰면서 편하게 개발에 집중할 수 있었습니다!</p></blockquote><h1 id="개발-진행"><a href="#개발-진행" class="headerlink" title="개발 진행"></a>개발 진행</h1><h2 id="Sass-변수-및-mixin-적용"><a href="#Sass-변수-및-mixin-적용" class="headerlink" title="Sass 변수 및 mixin 적용"></a>Sass 변수 및 mixin 적용</h2><p>디자이너분의 디자인 가이드를 바탕으로 sass 변수에 색상과 글씨를 선언해주었습니다. 특히 font size, font weight, line height의 경우 sass 맵을 생성하고 mixin 내에서 불러와 적용할 수 있도록 하였습니다.</p><p>실제 스타일이 적용되는 부분에서는 @include typography(headline) 처럼 작성해주면 디자이너분이 headline에 적용되길 기대한 글씨에 대한 모든 값들이 한번에 적용되었습니다!! 확실히 이전 프로젝트들과 달리 디자이너분이 디자인 시스템을 갖추어주시니 개발이 너무 편해졌어요.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/b23be087-aa52-4bdc-8454-3c42ed9fe3bd/image.png"></p><h2 id="MSW-적용"><a href="#MSW-적용" class="headerlink" title="MSW 적용"></a>MSW 적용</h2><p>프론트엔드의 가장 이상적인 개발 진행은 백엔드 API가 완성되어 거기에 맞춰 데이터 페칭을 하고 그에따른 UI를 화면에 출력하는 것이라고 생각합니다. 하지만… 같이 시작한 프로젝트에서 저희가 백엔드의 완성만을 기다릴 수는 없어요. 그래서 MSW를 적용했습니다!</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/977c3f4d-c83f-4f6b-bd01-e2669df4275b/image.png"></p><p>개발 환경에서는 MSW가 api 요청을 탈취해서 모킹 서버로부터 저희가 정한 응답을 받고 데이터들을 페이지에 렌더링할 수 있습니다. 이게 정말 좋았던게 백엔드와의 협의를 통해 엔드포인트만 정해둔다면 이후 배포시에도 코드의 변경없이 실제 서버로 그대로 요청을 보낼 수 있다는 것이 신세계였습니다.</p><p>프로젝트 막바지에는 위의 이미지처럼 모킹 함수 내에 return문을 추가시켜서 모킹하지 않고 바로 서버로 요청을 보내보면서 테스트 해볼 수 있었어요!</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>파이널 프로젝트도 끝나가고 이제는 수료도 코앞으로 다가왔습니다. 6개월 가량 정말 길거라고 생각한 것이 무색하게 후딱 지나가버렸어요. 패스트캠퍼스 X 야놀자 부트캠프 덕분에 스스로 자신감도 생기고 무엇보다 어떻게 개발자로서 발전해나갈지 깨닫는 계기가 된 것 같아요. 이번 마지막 프로젝트도 잘 마치고 다음 포스팅엔 마지막으로 부트캠프를 진행하며 느꼈던 총 후기로 돌아오겠습니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      
      <comments>https://namgungjongmin.github.io/2024/01/31/fc-yanolja/retrospective_final/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_미니프로젝트 회고</title>
      <link>https://namgungjongmin.github.io/2023/12/15/fc-yanolja/retrospective_mini/</link>
      <guid>https://namgungjongmin.github.io/2023/12/15/fc-yanolja/retrospective_mini/</guid>
      <pubDate>Fri, 15 Dec 2023 11:44:16 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이번 포스팅은 패스트캠퍼스</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png"></p><blockquote><p>이번 포스팅은 패스트캠퍼스 X 야놀자 부트캠프에서 진행한 ‘미니 프로젝트’를 진행하며 겪은 경험과 과정, 그리고 느낀점들을 공유하려고 합니다. 처음으로 경험했던 백엔드와의 협업 프로젝트였는데요! 이번 프로젝트를 하면서 팀장 역할도 맡게 되어서 부담감도 있었던 프로젝트였던 것 같아요. 하지만 함께 노력해준 팀원들과 멘토님의 도움 덕분에 수월하게 진행된 것 같습니다. 패스트캠퍼스 X 야놀자 부트캠프의 미니프로젝트! 어떻게 진행이 되었나 함께 보실까요?</p></blockquote><h1 id="프로젝트의-시작"><a href="#프로젝트의-시작" class="headerlink" title="프로젝트의 시작"></a>프로젝트의 시작</h1><p>이번 프로젝트에서는 ‘숙박 예약 API 서비스’를 과제로 전달받았습니다. 프로젝트 RFP를 통해 프로젝트 정의서와 기능적 요구사항들을 전달받고 해당 기능들을 백엔드 팀과의 협업을 통해 구현해나가야 했어요. 11월20일 ~ 12월01일 2주간 정말 열심히 개발했답니다.</p><h1 id="기획과-디자인"><a href="#기획과-디자인" class="headerlink" title="기획과 디자인"></a>기획과 디자인</h1><p>프로젝트의 기획은 피그마를 통해 구체화하였습니다. 팀 전체가 모여 와이어프레임과 세부 디자인을 결정하고 세부적으로 백엔드 팀원분들과의 상의를 통해 우선 순위 기능들, 구현하기 힘들거나 후순위인 기능들을 정리하였습니다.</p><p><a href="https://www.figma.com/file/uRO4rM5NR5F1WTIsv6ALWD/12%EA%B1%B8%EC%A7%80%EB%A7%90%EC%A1%B0?type=design&node-id=0:1&mode=design&t=kG7h2ykBGJ5rrZpc-1">Figma URL</a><br><img src="https://velog.velcdn.com/images/vbghdl/post/efb0515a-20f2-4e2d-8ff5-d5eb61a70948/image.png"></p><h1 id="기술-선택"><a href="#기술-선택" class="headerlink" title="기술 선택"></a>기술 선택</h1><p>기획이 완료되어 가면서 개발시 어떠한 기술들을 쓸 것인가에 대해 팀원들과 이야기를 나누었습니다. 제일 먼저 저희가 주목한 부분은 ‘어떤 기술을 써야 기업에 이익을 극대화할 수 있을 것인가?’였습니다. 숙박 예약 사이트의 각각의 숙박업소들이 나와있는 페이지와 객실 정보들을 확인하는 페이지들의 노출도가 높을 수록 우리 사이트를 접근하는 유저들이 많을 것이고, 그것이 기업의 이익과 연결된다고 생각했습니다. 따라서 이전 프로젝트와는 달리 NEXT.JS를 사용하기로 하였습니다.</p><p>NEXT.JS는 서버 컴포넌트가 있기 때문에 SSR이 가능합니다. 즉 자바스크립트 기반으로 빈 문서를 가져와 렌더링하는 리액트의 CSR과는 달리 우리가 서버 컴포넌트로 활용하고자 하는 페이지는 해당 정보를 문서에서 그려올 수 있기 때문에 검색 엔진 최적화에 유리합니다. 바로 우리 페이지를 더 쉽고, 많이 노출시킬 수 있다는 뜻이에요!</p><p>이후에는 백엔드에서 전달해준 API 명세등을 미리 타입으로 지정해두기 위해 Typescript도 도입했습니다. API 명세에 없는 키값을 입력하거나 타이핑 오타 등으로 일어날 오류를 런타임환경에서 확인하고 수정할 수 있었어요.</p><p>마지막으로 스타일 프레임워크는 TailwindCss를 선택했습니다. TailwindCss를 선택한 이유는 2주라는 짧은 시간 동안 처음 진행해보는 백엔드와의 협업 프로젝트였기 때문에 개발 생산성이 중요하다고 생각했기 때문입니다. 유틸리티 퍼스트 방식을 도입하면서 화면에 그려지는 레이아웃들을 직접 확인하면서 바로바로 적용해나갈 수 있어 확실히 빠른 개발 진행이 가능했습니다.</p><h1 id="협업-방식과-개발-전략-설정"><a href="#협업-방식과-개발-전략-설정" class="headerlink" title="협업 방식과 개발 전략 설정"></a>협업 방식과 개발 전략 설정</h1><p>다음으로 정해야 할 것은 ‘어떻게 협업할 것인가?’였습니다.</p><h2 id="ZEP"><a href="#ZEP" class="headerlink" title="ZEP"></a>ZEP</h2><p>전체적인 회의 진행과 기본 커뮤니케이션은 ZEP을 통해 이루어졌습니다. ZEP은 화면공유, 음성채팅, 영상채팅 등이 가능한 협업 툴인데요, 마치 게임처럼 아기자기한 캐릭터들을 이동해가면서 커뮤니케이션을 할 수 있어서 너무 재미있었어요.<br><img src="https://velog.velcdn.com/images/vbghdl/post/51cd3359-aa51-4580-97e5-65505fc04b9e/image.png"></p><blockquote><p>저희 프로젝트 방은 이렇게 생겼어요. 프론트 책상에서 회의를 하다가 백엔드 팀에게 질문사항이 생기면 ‘쫑쫑쫑’ 백엔드 테이블로 걸어가서 물어보곤 했답니다.</p></blockquote><h2 id="Trello"><a href="#Trello" class="headerlink" title="Trello"></a>Trello</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/c0648461-9a00-46ac-b0b0-3930689c3eec/image.png"><br>다음으로는 백엔드와 프론트엔드 사이에서 맡은 역할 별로 요구사항이나 수정사항, 또는 오류 등에 대해 1:1로 요청을 보내기에 trello가 편하다고 생각되어서 도입하게 되었습니다. 같은 프론트엔드 팀원이나 백엔드 팀원에게 요청을 보낼 때 간단하게 카드를 달아놓을 수 있습니다. 해당 주제에 대한 카드에서 댓글을 통해 서로 의견을 주고 받거나 진행사항을 공유할 수 있었습니다.</p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>마지막으로는 가장 주축이 되었던 모두의 Github입니다! 프론트엔드 팀의 개발에 있어서 프로세스를 정해두었어요.</p><ol><li>분담한 역할에 따라 구현할 기능에 대한 개발 내용을 미리 이슈로 등록한다.<br><img src="https://velog.velcdn.com/images/vbghdl/post/dc6cf5c5-b1a3-4cc8-ba1d-f2baf3c0e05b/image.png"></li><li>개인이 개발한 내용은 반드시 PR을 통해 팀원들과 공유하고 코드리뷰와 approval을 거친 뒤에 브랜치에 적용한다.<br><img src="https://velog.velcdn.com/images/vbghdl/post/eaf59b90-91fa-43a7-9461-f01cca5c8b7f/image.png"></li></ol><p>이 때 각 팀원 별로 브랜치를 분기해서 PR을 보냈어야 했는데 이를 단순화하기 위해 Gitflow도 도입했습니다! 저희가 사용한 브랜치 분기 전략은 밑의 링크에서 확인하실 수 있어요.</p><p><a href="https://warp-pirate-416.notion.site/caba5079fcc64628bebb8bd56a768054">브랜치 분기 전략</a></p><h1 id="프로젝트-진행"><a href="#프로젝트-진행" class="headerlink" title="프로젝트 진행"></a>프로젝트 진행</h1><p>프로젝트는 2주 동안 정말 눈코 뜰 새 없이 빠르게 지나갔습니다. 그나마 다행인 점은 기획 단계에서 백엔드와의 상의를 통해 전체적인 그림을 잘 잡아놨기에, 큰 충돌 없이 잘 진행될 수 있었어요.</p><p>저는 인증관련 페이지들과 기능들을 맡아 구현하게 되었습니다.</p><blockquote><p>이 때 NEXT.JS에서 쿠키 관련 이슈 때문에 너무 고생을 했는데… 이 부분은 차후에 NEXT.JS의 쿠키 사용에서의 이슈와 해결 방법이라는 주제로 다시 포스팅 하도록 할게요!</p></blockquote><p>또 저는 팀장으로서 전체적으로 팀원들의 개발 진행 사항이나 오류들을 파악해야 했습니다. 코드 리뷰도 정말 열심히 봤구요. 저의 역량은 이 모든 것을 자연스럽게 할 수 있을 정도로 충분하지 않다고 생각했고, 처음에 팀장을 맡았을 때에도 너무 부담이었던 부분이었습니다. 그러나 우리는 팀!<br>혼자서 모든 것을 해결한 것이 아니었어요. 팀원들의 도움과 스스로의 노력이 더해졌을 때 프로젝트는 정말 순조롭게 흘러갈 수 있었습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/cf69a43c-d3e0-47a9-b38a-a5ccc778d0ca/image.png"></p><blockquote><p>쌓여가는 Close PR과 우리들의 피, 땀 , 눈물…</p></blockquote><h1 id="프로젝트-완성과-리팩토링"><a href="#프로젝트-완성과-리팩토링" class="headerlink" title="프로젝트 완성과 리팩토링"></a>프로젝트 완성과 리팩토링</h1><p>드디어 2주가 지나고 저희 프로젝트가 완성되었습니다. 너무 힘든 2주였지만 완성된 결과물들이 제대로 동작하는 것들을 보면서 피로가 싹 날아가는 느낌이었어요! (물론 아직 부족한 점이 많아요…)</p><p><a href="https://www.stayinn.site/">STAYINN 사이트 링크</a><br><img src="https://velog.velcdn.com/images/vbghdl/post/7c08d8de-82ae-4e25-95fe-6c6994310eee/image.png"></p><h2 id="OVERVIEW"><a href="#OVERVIEW" class="headerlink" title="OVERVIEW"></a>OVERVIEW</h2><p><a href="https://drive.google.com/file/d/14apsd5GBasq9pUgUAFFZjZgJzqrIvaB2/view?usp=sharing"><img src="https://github.com/Dont12/KDT_Y_FE_Mini-Project/assets/79249376/3e556cb5-0763-4335-991f-7d8e36c73962" alt="시연영상"></a></p><h1 id="리팩토링"><a href="#리팩토링" class="headerlink" title="리팩토링"></a>리팩토링</h1><p>프로젝트가 끝난 뒤에는 2주간의 리팩토링 기간이 주어졌습니다. 각 팀원별로 맡은 부분에서 아쉬웠던 부분이나 추가적인 기능 구현들을 진행했습니다.</p><p>저의 경우에는 가장 주된 리팩토링 기능이 인가 여부에 따라 페이지를 라우팅하는 부분이였어요. 우리 사이트의 메인 페이지나 숙박&#x2F;객실 정보들을 보여주는 페이지의 경우는 로그인이 없어도 이용할 수 있지만, 마이페이지, 장바구니 페이지, 예약 하기 등에서는 반드시 로그인이 필요하기 때문에 로그인 페이지로 리다이렉트 시켜주는 로직이 필요했거든요.</p><p>기존 프로젝트에서 제가 구현한 방식은 페이지가 렌더링 되면서 로그인한 유저 정보를 API 요청하고 로그인이 되어있지 않아 요청이 실패하면 리다이렉트 시켜주는 방식이었습니다. 문제는 이렇게 구현했을 경우에는 페이지가 렌더링 되면서 요청하기 때문에 잠시동안 해당 페이지가 보여지다가 로그인 페이지로 넘어가는 깜빡거림 현상이 있었습니다.</p><p>이를 해결하기 위해 해당 페이지로 이동할 때 렌더링 이전 유저 정보를 요청하고 그 결과에 따라 렌더링 여부를 결정하는 것이 필요했어요. 이를 위해 미들웨어를 작성했습니다.</p><p>이 때 미들웨어를 작성하면서 쿠키 이슈가 생겼는데, 백엔드 단에서 Set-cookie를 해주더라도 next서버에는 쿠키라는 개념이 없기 때문에 next서버에서의 요청에서 쿠키가 담겨가지 않아 인증 요청을 할 수가 없었습니다. 이를 해결하기 위해 로그인시 브라우저에 Set-cookie된 토큰들을 직접 next서버에 변수로 불러와 header의 cookie로 직접 넣어서 api 요청을 해주어야 했어요. ‘next-client-cookies&#x2F;server’의 CookiesProvider를 RootLayout에 감싸주어 서버 컴포넌트와 클라이언트 컴포넌트에서 쿠키들을 공유할 수 있게 했습니다. 이후엔 Set-cookie한 토큰들의 값을 로그인시 읽어와 CookiesProvider에 따로 set 해주어 미들웨어에서 토큰들을 읽을 수 있게 하였고, 마찬가지로 로그아웃 시에는 따로 CookiesProvider의 토큰 값들을 remove 해주는 로직을 추가해주는 것으로 해결했습니다.</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>2주간의 협업 프로젝트는 저의 역량을 한층 더 끌어올려준 것을 넘어서 다른 사람들과의 협업이 어떻게 진행되고 그 안에서 제가 어떤 방식으로 다른 사람들에게 내 요구를 전할지, 어떻게 표현할지를 생각해보는 계기가 되었습니다. 어느덧 벌써 ‘파이널 프로젝트’를 앞두고 있는데요. 이 경험을 잘 살려서 파이널 프로젝트 또한 잘 마무리하고 찾아뵙겠습니다!</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/12/15/fc-yanolja/retrospective_mini/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_과정 중간 회고</title>
      <link>https://namgungjongmin.github.io/2023/11/18/fc-yanolja/retrospective_middle/</link>
      <guid>https://namgungjongmin.github.io/2023/11/18/fc-yanolja/retrospective_middle/</guid>
      <pubDate>Fri, 17 Nov 2023 15:11:16 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/b6ddf37a-7880-49ca-9bd1-1db35537648c/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;오늘 포스팅은 지금까지 약</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/b6ddf37a-7880-49ca-9bd1-1db35537648c/image.png"></p><blockquote><p>오늘 포스팅은 지금까지 약 4개월 과정동안 패스트캠퍼스 부트캠프 과정을 진행하면서 경험한 것들과 느낀점들을 공유하려고 합니다. 이젠 정말 과정의 반을 넘기게 되었는데요 회고를 작성하려고 지난 저의 발자취들을 따라가본 결과 정말 많은 성장을 했음을 알 수가 있었어요! 제 성장의 토대가 되어주신 강사님들과 멘토님, 그리고 운영진 분들께 모두 감싸의 말씀 올립니다.</p></blockquote><h1 id="1-HTML-x2F-CSS"><a href="#1-HTML-x2F-CSS" class="headerlink" title="1. HTML&#x2F;CSS"></a>1. HTML&#x2F;CSS</h1><p>HTML&#x2F;CSS는 사실 부트캠프 과정을 시작하기 전에도 학습을 했던 부분이었기에 이번 과정에서는 보다 심화된 내용들을 학습하고 싶었습니다. 단순한 마크업 구현에서 벗어나 접근성과 웹표준, 그리고 최적화 관점에서 양질의 코드를 쓸 수 있도록 공부해야겠다는 생각을 했습니다.</p><p>HTML&#x2F;CSS과제는 원하는 사이트를 하나 선정해서 클론 코딩을 하는 것이었습니다. 앞서 말한 여러 추가적인 공부 내용들을 적용해보고자 노력했습니다.</p><h2 id="The-Armor-Bearer-클론"><a href="#The-Armor-Bearer-클론" class="headerlink" title="The Armor Bearer 클론"></a>The Armor Bearer 클론</h2><p>깃허브 링크: <a href="https://github.com/NamgungJongMin/Yanolja_FE_HTML-CSS">https://github.com/NamgungJongMin/Yanolja_FE_HTML-CSS</a></p><p><img src="https://velog.velcdn.com/images/vbghdl/post/b5062c35-12f5-4eeb-9edf-b62c6d459f17/image.png"></p><p>이 프로젝트를 하면서 Scss의 활용을 좀 더 심화해서 익힐 수 있었습니다. BEM 방법론을 적용하면서 중첩규칙을 보다 효율적으로 이용할 수 있었고, Mixin 등의 유틸함수를 통해 유지보수면에서도 더 나은 코드가 무엇일지 고민해볼 수 있는 시간이었습니다.</p><p>또한 스크린리더 사용자의 긍정적 경험을 위해 디자인적 요소라 읽어주지 않을 요소와 읽어주진 않지만 어떤 섹션인지 설명해주어야 할 것 같은 부분에 읽어주도록 처리해주었습니다.</p><p>추가로 렌더링 관점에서 웹성능을 끌어올릴 수 있는 방법에 대해 고민했습니다. 이미지 최적화와 스타일 적용 방식의 최적화를 고민하고 적용해보면서 매우 값진 시간을 보낼 수 있었습니다.</p><h1 id="2-Javascript"><a href="#2-Javascript" class="headerlink" title="2. Javascript"></a>2. Javascript</h1><p>자바스크립트의 경우에는 프로젝트를 생성하고 진행하면서 어떤 폴더 구조를 사용할지, 같은 기능이라도 어떤 방식이 유지보수에 도움이 될지에 대한 고민을 많이 했던 것 같습니다.</p><h2 id="직원-관리-서비스"><a href="#직원-관리-서비스" class="headerlink" title="직원 관리 서비스"></a>직원 관리 서비스</h2><p>깃허브 링크: <a href="https://github.com/NamgungJongMin/Yanolja_FE_JavaScript">https://github.com/NamgungJongMin/Yanolja_FE_JavaScript</a></p><p><img src="https://velog.velcdn.com/images/vbghdl/post/1b2e01ac-364f-4759-8f77-5e2d4ee5e6d4/image.png"><br><img src="https://velog.velcdn.com/images/vbghdl/post/af8a550d-d05e-463a-b96d-175a88bc6db9/image.png"><br><img src="https://velog.velcdn.com/images/vbghdl/post/9847506c-9f75-4b04-9ec1-6e27cccf5399/image.png"></p><p>로그인&#x2F;회원가입 기능을 구현하면서 한 스크립트 파일에 담는 것이 아니라 스키마로 분류하고 validation 결과를 반환하는 getter함수를 지니는 객체를 만들어 파일을 분리해주었습니다. 단순히 어떻게 구현할지가 아니라 어떤 방법으로 구현해 나갈지 고민할 수 있는 뜻 깊은 시간이었어요.</p><h1 id="3-토이프로젝트-1"><a href="#3-토이프로젝트-1" class="headerlink" title="3. 토이프로젝트 1"></a>3. 토이프로젝트 1</h1><p>다음으로 진행된 토이프로젝트는 팀과 함께하는 협업 프로젝트였습니다. 제가 무려… 팀장을 맡았답니다. 단순히 혼자 하는 것에 비해 서로에 맞추고 또 일정을 조율해나가면서 전체적인 코드 컨벤션도 맞춰야 했습니다. 또한 커밋 방식이나 브랜치 분기 전략 등을 도입해보면서 실제 현업에서 일하는 개발자 분들의 입장을 쪼..곰? 이나마 체험해볼 수 있었습니다.</p><h2 id="직원-위키-사이트"><a href="#직원-위키-사이트" class="headerlink" title="직원 위키 사이트"></a>직원 위키 사이트</h2><p>깃허브 링크: <a href="https://github.com/NamgungJongMin/toy1">https://github.com/NamgungJongMin/toy1</a></p><p><img src="https://velog.velcdn.com/images/vbghdl/post/151e69b8-9ab9-4fba-a23a-5249d0253ef8/image.png"><br><img src="https://velog.velcdn.com/images/vbghdl/post/09068c07-dea1-4430-8a3a-2fa1ea76536e/image.png"></p><p>처음으로 파이어베이스를 사용해보면서 데이터들을 실제 저장하고 가져오는 것들을 해볼 수 있었습니다. 너무 흥미로웠어요. 협업 프로젝트는 단순히 혼자하는 프로젝트와는 정말 달랐습니다. 팀원들에게 모르는 것들을 질문하고 또 내가 질문 받았을 때 해결해주면서 뿌듯함을 느꼈고, 함께 무언가를 만들어 나간다는 고양감을 느낄 수 있었던 것 같습니다. 실제 현업에 가서도 다른 사람들과 일을 하게 될텐데 앞서 경험한 팀 프로젝트는 큰 힘이 되어줄 것이라고 생각합니다.</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>어떠신가요?! 패스트캠퍼스 부트캠프를 통해 점점 더 고민하고, 노력하고, 성장해나가는 제 모습이 보이셨나요? 오늘 회고 포스팅은 단순히 글을 쓰는 것을 넘어 지금까지의 저를 되돌아보고 반성하고, 잘했다 기특하게 생각할 수 있었습니다. 여러분들도 지금 고민하고 있다면 도전하세요. 당장은 미약하더라도 노력하는 시간은 절대 배신하지 않을거에요. 오늘 포스팅도 읽어주셔서 너무 감사했습니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/11/18/fc-yanolja/retrospective_middle/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_강사진 &amp; 멘토 후기</title>
      <link>https://namgungjongmin.github.io/2023/10/27/fc-yanolja/teacher-metor/</link>
      <guid>https://namgungjongmin.github.io/2023/10/27/fc-yanolja/teacher-metor/</guid>
      <pubDate>Fri, 27 Oct 2023 13:15:06 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/9e036891-73ba-421f-84e7-47b199aa339d/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;지금까지 패스트캠퍼스 X </description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/9e036891-73ba-421f-84e7-47b199aa339d/image.png"></p><blockquote><p>지금까지 패스트캠퍼스 X 야놀자 부트캠프가 어떤식으로 진행되어 가는지를 소개했었는데요, 오늘은 부트캠프의 강사분들의 약력과 함께 실제 강의를 들어본 입장에서 후기를 전해드리고자 합니다. 또한 현재 진행되고 있는 멘토님과의 멘토링이 어떻게 도움이 되고있는지도 이야기 해볼게요.</p></blockquote><h1 id="부트캠프-강사진"><a href="#부트캠프-강사진" class="headerlink" title="부트캠프 강사진"></a>부트캠프 강사진</h1><h2 id="박영웅-강사님"><a href="#박영웅-강사님" class="headerlink" title="박영웅 강사님"></a>박영웅 강사님</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/9a658f58-3058-4295-b642-262fd33dec9a/image.png"></p><p>부트캠프에서 가장 먼저 강의를 통해 만나뵙게 된 박영웅 강사님! 프론트엔드의 기초라고 할 수 있는 HTML과 CSS, 그리고 Javascript에 대한 온라인 강의를 통해 만나뵈었습니다.</p><p>특히 Javascript의 경우에는 앞으로 배울 현업에서 쓰이는 중요한 기술들의 토대가 되기 때문에 확실히 공부해야한다고 생각했었습니다. 박영웅 강사님의 강의 같은 경우 우선적으로 이론에 대해 자세하게 정리하신 후 저희가 자주 접할 수 있는 사이트들을 실습으로 코딩하면서 이론들이 어떻게 실제 개발과정에서 쓰이는지를 학습할 수 있었습니다.</p><p>실습 강의로 API를 활용한 영화검색 사이트 만들기를 진행해 주셨는데요, 단순히 자바스크립트를 이용한 동적 구현뿐만 아니라 컴포넌트의 개념까지 설명해주시면서 실제 프로젝트의 적용할 수 있는 디렉토리 구성과 라우팅까지 학습할 수 있는 정말 좋은 강의라고 생각합니다.</p><p>사실 이 강의를 볼때마다 아쉬웠던 점이 하나 있어요. 저희가 두번째 과제로 Javascript를 활용한 사이트를 만들었었는데, 과제 시점이 이 실습 강의를 듣는 시점 이전이었기 때문에 많이 헤맸습니다. 과제를 제출한 뒤에 강의를 듣고는 ‘아 강의를 듣고 과제를 했다면 정말 수월하게 할 수 있었겠다.’라는 생각이 들었습니다.</p><h2 id="안재원-강사님"><a href="#안재원-강사님" class="headerlink" title="안재원 강사님"></a>안재원 강사님</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/7cc3aa0c-ebff-4c52-aa98-2f845470670d/image.png"></p><p>안재원 강사님은 리액트와 여러가지 프레임 워크들을 강의해주셨습니다. 온라인 강의와 더불어 실시간 강의를 통해서 여러가지 실습들을 통해 다양한 개발 경험을 할 수 있도록 해주셨어요.</p><p>현업에서 현재 가장 많이 사용하고 있는(취업에 제일 중요하다고 해요) React와 프레임워크들을 강의해주셨어요. 특히 실습위주의 강의이다보니 매 강의마다 시간이 훌떡훌떡 갔습니다.</p><p>중요한 점은 실습을 통한 코드 따라치기를 벗어나 다시 한번 학습한 내용에 대해 되돌아보는 시간이 매우 중요하다는 생각을 하게 됬어요. 실습을 통해 개발을 매끄럽게 진행하시는데 따라치다보면 어느새 완성되어가는 결과물들이 내 실력이라는 착각을 할 수 있겠다고 생각했습니다.</p><p>막상 혼자 무에서부터 개발을 시작하려다보면 무엇을 해야할지 감이 안잡히고 헤매는 경우가 생기곤 해요. 그래서 그러지 않도록 어떻게 접근하셨고, 왜 이것부터 하셨지?, 왜 이 메소드를 사용하셨을까와 같은 점들을 바로바로 질문하면서 메모해두려고 노력을 많이 했습니다.</p><h2 id="나동빈-강사님"><a href="#나동빈-강사님" class="headerlink" title="나동빈 강사님"></a>나동빈 강사님</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/ad8151a1-0f99-490d-bed7-1c11660f57a3/image.png"></p><p>나동빈 강사님은 패스트캠퍼스 X 야놀자 부트캠프의 알고리즘 강의를 맡아주셨어요. 특히 저는 그룹스터디를 통해 매주 알고리즘 주제를 정하고 해당 알고리즘의 대표 문제들을 풀어오고 있었는데 도움을 많이 받았습니다.</p><p>이번 주의 주제가 BFS라면 해당 주제에 대한 나동빈 강사님의 녹화강의를 듣고 정리한 뒤에 문제를 풀면서 머리로 이해한 개념들을 문제 풀이에 적용하는 방식으로 공부했습니다.</p><p>특히 단순한 개념 강의만이 아니라 어떤 문제들을 만났을 때 해당 알고리즘을 떠올려야 하는지, 알고리즘이 문제마다 어떤식으로 구현되는지를 여러 예시 문제들을 풀어주시면서 자연스럽게 코딩테스트 문제들을 익힐 수 있도록 강의하시는게 정말 좋았습니다.</p><blockquote><p>나동빈님은 사실 부트캠프를 시작하기 이전에도 유튜브를 통해 몇번 뵌적이 있었어요. 그때마다 어떤식으로 개발 공부를 할지, 코딩테스트 공부는 어떻게 준비해야하는지 등에 대해 많은 조언이 담긴 영상들을 통해 큰 도움을 받았다고 생각했는데 이번 부트캠프에서 강사진으로 만나뵙게 되니 너무 반가웠습니다.</p></blockquote><h1 id="그룹-7조-멘토님"><a href="#그룹-7조-멘토님" class="headerlink" title="그룹 7조 멘토님"></a>그룹 7조 멘토님</h1><h2 id="서정현-멘토님"><a href="#서정현-멘토님" class="headerlink" title="서정현 멘토님"></a>서정현 멘토님</h2><p>저희 그룹에서 멘토링을 해주시는 서정현 멘토님! 현재 현업에서 근무하고 계십니다. 따라서 개발 외적인 부분들에 대해서도 질문을 많이 드리고 도움이 되는 답변을 많이 얻어가는 것 같아요.</p><p>예를들어, 스타트업에 취직을 하게 된다면 어떤 기업들을 선택해야 하는지, 취업 프로세스 등과 같은 것들도 물어봅니다. (현업에서 근무하시면서 실제 팀원들을 뽑는 위치시다보니 취업관련 질문들에 대해서도 도움이 되는 답변들을 많이 해주세요!)</p><p>부트캠프가 진행되면서 개발와중 생기는 궁금점들을 모두 질문하기보다는 웹서칭을 통해 스스로 해결하게 되는 경우가 많아지면서 저희 조의 질문들이 점점 적어지는 것 같아요. 하지만 매 멘토링 시간마다 최대한 많은 도움을 주기 위해서 노력해주시는게 느껴집니다.</p><p>요즘에는 질문이 적어 시간이 남을 때는 면접관련 도움을 주시기로 해주셨어요. 실제 팀원들을 선별하는 경험과 취업을 위한 면접을 둘다 경험해보셨기 때문에 주시는 면접 질문들 하나하나 소중히 기록하고 답변할 수 있도록 준비하려고 노력하고 있습니다.</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>오늘 포스팅에서 패스트캠퍼스 X 야놀자 부트캠프의 강사분들과 멘토님을소개하고 부트캠프 과정 중 느꼈던 여러가지 점들을 적어보았습니다. 이 포스팅을 보시는 분들이면 아마 국비지원이나 부트캠프 등에 관심이 있으신 분들이라고 생각됩니다. 저는 패스트캠퍼스에서 운영하는 부트캠프가 좋은 강사분들과 커리큘럼을 가지고 있다고 생각해요. 제 포스팅들이 여러분의 선택에 도움이 되었으면 좋겠다고 생각합니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/10/27/fc-yanolja/teacher-metor/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_워크샵 &amp; 멘토링</title>
      <link>https://namgungjongmin.github.io/2023/10/13/fc-yanolja/workshop/</link>
      <guid>https://namgungjongmin.github.io/2023/10/13/fc-yanolja/workshop/</guid>
      <pubDate>Fri, 13 Oct 2023 14:01:29 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;저번 포스팅에서 그룹스터디</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/5e1e2ac9-3a7a-4a13-89bd-fa4abc0b669a/image.png"></p><blockquote><p>저번 포스팅에서 그룹스터디 팀 결성과 진행 방식 그리고 후기를 알려드렸었어요. 패스트캠퍼스 X 야놀자 부트캠프에서는 각 팀 별 그룹스터디만 진행되는 것이 아니라 주기적으로 워크샵을 통해 부트캠프를 함께 하는 동기생들이 어떤 방식으로 공부를 이어나가고 있는지 이야기를 나눠볼 수 있는 시간이 있었습니다. 오늘은 두번에 걸쳐 진행된 워크샵 후기와 함께 저번에 말씀드렸던 패스트캠퍼스 X 야놀자 부트캠프의 장점이라고 언급했던 멘토링 후기에 대해서 이야기하려 합니다.</p></blockquote><h1 id="1차-부트캠프-워크샵"><a href="#1차-부트캠프-워크샵" class="headerlink" title="1차 부트캠프 워크샵"></a>1차 부트캠프 워크샵</h1><p>7월 24일에 그룹스터디 워크샵을 가졌습니다. 이번 워크샵에서는 각 그룹스터디 별로 어떻게 진행되어 가는지, 느낀점들이나 공유하고 싶은 내용등을 자유롭게 이야기하는 시간이었습니다. 각 그룹스터디 별로 스터디 주제나 진행 방식들이 차이가 있어서 좋은점들은 우리 스터디에도 적용하고 싶은 마음에 정말 열심히 들었던 것 같습니다. 뿐만아니라 우리 스터디에서 잘 적용되고 있는 방식들을 자랑하고 싶은 마음도 있었던 것 같아요!</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/50a48252-2ce3-415d-a3fd-aa59a79a1c0c/image.png"></p><p>저희 조는 노션을 통해 발표자료를 준비해 워크샵을 준비했습니다. 저희 조원들 소개와 스터디 진행방식 그리고 느낀점들을 발표자료로 준비했습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/1cf733f9-082d-4e32-afef-bd7355f6b6fc/image.png"></p><p>저번 포스팅에서 다뤘던 코딩테스트 스터디에 대한 발표 자료네요. 백준을 통해 각 알고리즘별로 이론 공부와 더불어 대표 문제들을 학습했습니다.</p><blockquote><p>이제는 알고리즘 별 대표문제들을 쭉 훑고나서 프로그래머스에서 기출문제들 위주로 코딩테스트 스터디를 진행하고 있어요!! 확실히 알고리즘별로 학습을 탄탄히 한 뒤에 기출문제 풀이로 넘어가니 문제를 접근하는 방식이나 풀이에 있어서 도움을 많이 받는 것 같습니다.</p></blockquote><p><img src="https://velog.velcdn.com/images/vbghdl/post/4c07f09c-28a5-4c9c-8792-6f8bf1c1483a/image.png"></p><p>다음으로는 자바스크립트 딥다이브 스터디에 대한 발표 자료인데요, 각자 발표를 준비한다는 마음으로 책을 정독하고 뽑기로 걸린 팀원이 주제들에 대해 설명한다는 방식은 다른 많은 팀들에게 좋은 호응을 얻었습니다! 그분들 스터디에도 적용하는 것을 고민한다는 이야기도 들었어요.</p><p>사실 900쪽이 넘어가는 이 두꺼운 책을 팀원들과 언제 다 읽을 수 있을까 걱정이 많았는데 지금 이 글을 쓰는 지금은 벌써 완독을 눈앞에 두고 있답니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/c2c9ec52-96bb-4ead-8abb-1367ba435ab4/image.png"></p><p>저희 그룹 뿐만아니라 다름 스터디그룹에서도 정말 열심히 스터디를 진행하고 계신거 같더라구요. 저희와 다른 방식을 선택한 그룹이나 저도 꼭 해보고 싶은 주제를 선정해 스터디를 진행하는 팀들도 있었습니다. 특히 그룹원들끼리 토이프로젝트를 진행하는 팀이 흥미로워서 주기적으로 팀 노션을 눈팅해왔는데, 이번 워크샵을 통해 어떤 결과물들을 만들고 있는지 자세히 소개해주셔서 너무 재밌었던 것 같아요.</p><h1 id="2차-부트캠프-워크샵"><a href="#2차-부트캠프-워크샵" class="headerlink" title="2차 부트캠프 워크샵"></a>2차 부트캠프 워크샵</h1><p>8월 25일에는 두번째 워크샵이 진행되었습니다. 이전 그룹스터디 워크샵과는 다르게 각 개인이 그 동안 부트캠프를 진행하면서 느낀점이나 배운점들 또는 공유하고 싶은 주제들에 대해서 이야기하는 시간이었습니다. 추가로 진행된 ‘천하제일 내 꿀통 자랑대회’ !!!<br>주제를 선정해 발표하고 참여자 전원 상품까지 얻어갈 수 있는 좋은 기회였습니다. 한치의 고민도 없이 바로 참여했습니다 😁</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/eea7ef38-8c78-4a72-a4a5-62a9d74519d5/image.png"></p><p>발표자 분들이 생각보다 많이 적었어요. 저를 포함해 네분이 발표를 진행하셨습니다. 아마 발표에 대해 부담감이 있으신 분들이 있으셨던 것 같아요. 그 동안 눈팅해온 동기생분들 중에는 정말 실력자분들이 많으셔서 기대했는데 아쉬웠습니다 ㅠㅠ.</p><h2 id="천하제일-내-꿀통-자랑대회-발표"><a href="#천하제일-내-꿀통-자랑대회-발표" class="headerlink" title="천하제일 내 꿀통 자랑대회 발표"></a>천하제일 내 꿀통 자랑대회 발표</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/fea9756d-d132-4866-be3a-2731b48ada2b/image.png"></p><p>저는 웹 성능과 성능 지표를 활용한 최적화라는 주제로 발표를 했습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/a37446ab-99af-491b-a395-ac1b6f45a7eb/image.png"></p><p>우선 성능에 대한 전반적인 설명에 앞서 필요한 지식인 렌더링 과정에 대해서 이야기하고, 성능 개선의 필요성을 설명한 뒤 다양한 성능 지표에 대해 소개하고 그 지표를 기반으로한 최적화 방안에 대해 이야기했습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/a6128709-f2dd-4aa0-b693-95c44044c095/image.png"></p><p>성능 개선의 필요성을 엘레베이터 닫기 버튼을 누르는 우리의 모습과 연관지어 설명해보았는데 참 괜찮은 예시였던 것 같아요^^.</p><p>많이 떨리기도 했지만 한편으로는 설렘 가운데서 발표를 잘 마무리할 수 있었습니다.</p><blockquote><p>마지막 발표인데다 다른 분들에 비해 긴 시간의 발표여서 더 떨렸던 것 같아요. 시간이 너무 길까 말도 너무 빨랐던 것 같고… 경험삼아 다음번엔 더 잘할 수 있겠죠?</p></blockquote><p><img src="https://velog.velcdn.com/images/vbghdl/post/e1fcbe2e-c1bb-4fcd-b83f-cbe4db63b0a1/image.png"></p><p>다른 분들의 발표 중에 특히 어승준님의 optimistic ui 와 pasimistic ui에 대한 발표는 정말 유익했습니다. 부트캠프의 장점! 동기생들과의 연결. 바로 DM을 드려 이야기를 나누고 발표자료들을 교환한 뒤 주말에 공부했습니다. 너무 너무 유익했습니다.</p><p>워크샵이 잘 마무리되고 상품도 잘 받았답니다. 아! 저는 ‘개발자의 글쓰기’라는 책을 선택해서 받았어요!</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/cc77e27b-9190-4f15-b536-5562542ea4cd/image.png"></p><h1 id="그룹스터디-멘토링"><a href="#그룹스터디-멘토링" class="headerlink" title="그룹스터디 멘토링"></a>그룹스터디 멘토링</h1><p><img src="https://velog.velcdn.com/images/vbghdl/post/883458f4-9840-4217-ad1e-43eeac5ec1f3/image.png"></p><p>패스트캠퍼스 X 야놀자 부트캠프의 큰 장점이라고 저번 포스팅에서 이야기 했던 멘토링입니다. 공부를 하면서 모르는 내용들 궁금한 내용들을 그때마다 요청서에 적어두면 현직 멘토님의 답변과 함께 일주일에 한번 있는 멘토링 시간에 이야기를 나눠볼 수 있었습니다.</p><blockquote><p>사실 처음에는 멘토링이라는 것이 이 정도로 좋을지 몰랐어요. 우리가 공부를 하다가 궁금한 것이 생기면 질문하고 답변을 기다리기 보다는 구글링등을 통해 바로바로 알고 해결하려고 하잖아요. 그런데 꼭 개발 지식에 관련된 내용이 아니더라도 직접 취업 후 경험을 통해 알 수있는 내용들이나 질문하기 어려운 추상적인 것들도 대화를 통해 충족시킬 수 있다는 점이 너무나도 좋았습니다.</p></blockquote><p>질문이 없을 때 이 귀중한 멘토링 시간을 어떻게 써야할지는 항상 고민이었습니다. 그래서 멘토님과의 이야기를 통해 남는 시간은 저희 면접 준비를 도와주시기로 하셨어요! 멘토님께서 직접 경험하셨던 면접 질문들이나 실제 팀원을 뽑으실 때 물어볼 것 같은 질문들을 저희에게 제시해주시고 답변을 들어주시며 교정해주시는데 너무나 유익한 것 같습니다.</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>패스트캠퍼스 X 야놀자 부트캠프를 진행하면서 부트캠프로 이곳을 선택한 것이 정말 확실한 선택이었다는 것을 요즘 계속해서 느끼고 있습니다. 과정 중 진행되는 앞서 소개한 여러가지들 중 도움이 되지 않는 것이 단 하나도 없는 것 같아요. 제가 쓰는 후기들이 국비지원이나 부트캠프를 고려하는 다른 학우분들께 도움이 되셨으면 좋겠습니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/10/13/fc-yanolja/workshop/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_그룹스터디</title>
      <link>https://namgungjongmin.github.io/2023/09/21/fc-yanolja/group-study/</link>
      <guid>https://namgungjongmin.github.io/2023/09/21/fc-yanolja/group-study/</guid>
      <pubDate>Thu, 21 Sep 2023 13:11:15 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/1e9ac916-94b3-4bd5-ba78-e69f4e3c0dad/image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;그룹스터디-팀-결성&quot;&gt;&lt;a href=&quot;#</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/1e9ac916-94b3-4bd5-ba78-e69f4e3c0dad/image.png"></p><h1 id="그룹스터디-팀-결성"><a href="#그룹스터디-팀-결성" class="headerlink" title="그룹스터디 팀 결성"></a>그룹스터디 팀 결성</h1><p>패스트캠퍼스 X 야놀자 부트캠프의 시작과 함께 그룹이 배정되었습니다!!. 성후님, 혜민님, 홍규님, 수연님, 영민님, 그리고 저 이렇게 6명의 그룹원들이 한팀이 되었어요. 그룹의 팀장은 성후님께서 맡아주시기로 결정되었습니다.</p><p>저희 팀이 7조라 팀명을 ‘마 니 개발좀7나’로 결정하였습니다. 재밌지 않나요?😂 이후엔 회의를 통해 앞으로 우리가 어떤 방식으로 그룹스터디를 운영해나갈지, 무엇을 공부할지에 대해 이야기를 나누었습니다.</p><h1 id="그룹스터디-운영"><a href="#그룹스터디-운영" class="headerlink" title="그룹스터디 운영"></a>그룹스터디 운영</h1><p>패스트캠퍼스 X 야놀자 부트캠프의 그룹스터디는 자유도가 매우 높은 스터디입니다. 그룹스터디 진행 방식과 목적, 목표 그리고 공부할 내용까지도 팀원과의 협의를 통해 결정하고 팀별로 알아서 이루어지게 됩니다.</p><p>그룹스터디의 진행사항은 노션을 통해 정리하게 되었습니다. 패스트캠퍼스 X 야놀자 부트캠프의 노션에 저희 그룹스터디 페이지가 생성이 되었네요!<br><img src="https://velog.velcdn.com/images/vbghdl/post/91ac3510-6a78-4dfc-977d-4f7f64b501e9/image.png"></p><p>저희가 그룹스터디를 통해 이루고자하는 목표는 두가지로 잡았습니다.</p><ol><li>코딩테스트에 합격할 수 있는 수준의 알고리즘 역량을 기른다.</li><li>JavaScript Deep Dive 책을 완독하고, 각 주제를 서로에게 설명해줄 수 있다.</li></ol><p>따라서 그룹스터디에서는 코딩테스트 준비로 알고리즘 공부와 Javascript 이론에 대한 공부가 함께 진행되기로 했습니다.</p><h2 id="1-알고리즘-공부-및-코딩테스트-준비"><a href="#1-알고리즘-공부-및-코딩테스트-준비" class="headerlink" title="1) 알고리즘 공부 및 코딩테스트 준비"></a>1) 알고리즘 공부 및 코딩테스트 준비</h2><p>코딩테스트 준비는 각 주마다 알고리즘 주제를 선정하고 해당 알고리즘을 사용하여 풀 수 있는 코딩테스트 문제를 백준에서 선택하여 풀어옵니다. 이후에는 사다리타기를 통해 문제별 발표자를 선정하고 해당 발표자가 어떻게 문제를 접근했고, 어떻게 풀어나갔는지를 설명합니다. 발표 이후에는 조원들끼리 서로의 풀이과정을 공유하며 코드 리뷰를 하는 시간을 갖게 됩니다.</p><p>Brute Force 알고리즘을 공부한 스터디 내용을 살펴볼까요?</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/dd8f702b-290d-4e62-932d-e8880b95a29f/image.png"></p><p>주제 알고리즘에 대한 설명과 관련된 코딩테스트 문제들, 그리고 문제들을 맡은 발표자들이 정리되어 있네요!</p><p>그 다음에는 해당 문제에 대한 담당자의 풀이와 그것을 비교한 팀원들의 코드리뷰 내용들이 정리되어있습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/61cf9ea4-e2ba-4b94-b4fe-4dd16723423e/image.png"><img src="https://velog.velcdn.com/images/vbghdl/post/2bc41f98-e233-4da6-acf4-7991466d3c25/image.png"></p><p>개인별 문제풀이 코드들을 팀원 모두가 함께 확인하고 자신의 코드와 비교하면서 다른 사람의 문제 접근 방식과 코드 구현 방식을 확인할 수 있었고, 이후 코드리뷰를 통한 토론을 통해 어떤 방식이 더 좋은 방식이고, 좋은 코드인지 이야기를 나눠보면서 JavaScript 코드의 구현 역량을 기를 수 있었습니다.</p><h2 id="2-JavaScript-Deep-Dive-스터디"><a href="#2-JavaScript-Deep-Dive-스터디" class="headerlink" title="2) JavaScript Deep Dive 스터디"></a>2) JavaScript Deep Dive 스터디</h2><p>JavaScript Deep Dive 스터디의 경우 러버덕 방식으로 진행하기로 결정되었습니다. 미리 정한 범위까지 책을 정독하고, 발표자를 선정하여 해당 주제에 대한 내용에 대해 발표하고, 즉각적으로 내용에 대한 이해 여부를 검증하면서 이해하지 못한 문장들에 대해서도 이야기를 나누었습니다. 이 방식을 통해 다음과 같은 이점들을 얻을 수 있었습니다.</p><ol><li>해당 주제에 대한 완벽한 이해</li></ol><blockquote><p>저희는 다른 사람에게 설명할 수 있어야 비로소 자신의 지식이라고 생각했습니다. 해당 주제에 대해 전체적으로 설명할 수 있어야 내가 완벽히 이해한 내용이고, 또한 그렇게 설명을 염두에두고 공부하는 과정에서 주제에 대해 깊이있는 공부가 가능할 것이라고 생각했습니다.</p></blockquote><ol start="2"><li>면접 준비</li></ol><blockquote><p>다른사람에게 설명하는 것을 염두에 둔 공부와 실제 발표는 해당 주제에 대해 자신감을 얻게 될 것이라 생각했습니다. 또한 내 지식을 다른 사람에게 말하는 것을 반복하게 되면서 자연스럽게 면접 준비가 되겠다고 생각했습니다.</p></blockquote><p>이렇게 러버덕을 통한 공부 이후에는 스터디 때 오간 내용들을 종합하여 정리된 내용을 토대로 블로그 포스팅을 통해 해당 주제에 대한 지식을 온전히 자신의 것으로 만들 수 있게 하였습니다.<br><img src="https://velog.velcdn.com/images/vbghdl/post/253e4570-fa3d-4cb8-9696-43f389de5b9c/image.png"><img src="https://velog.velcdn.com/images/vbghdl/post/ce0f8585-29bd-49b6-bf9d-8c0e448803cf/image.png"></p><h2 id="3-그룹스터디-멘토링"><a href="#3-그룹스터디-멘토링" class="headerlink" title="3) 그룹스터디 멘토링"></a>3) 그룹스터디 멘토링</h2><p>그룹스터디 진행이 서로의 의견 교환을 통해 이루어진다는 것은 스스로가 생각할 기회가 많다는 장점이 있지만, 한편으로는 팀원끼리의 소통만으로는 올바른 판단인지를 결정하기 힘들다는 단점이 있었습니다. 모두 공부하는 입장이기 때문에 오고간 이야기들을 객관적으로 검증할 방법이 필요했습니다.</p><p>이를 위해 패스트캠퍼스 X 야놀자 부트캠프에서는 주 1회 그룹별 멘토링 시간을 제공해주었습니다. 멘토님께 질문하면서 현재 스터디 방향이 맞는지 계속 확인하고, 팀원들끼리 판단하지 못했던 여러 주제들에 대해 멘토링을 받을 수 있었습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/86aa6ab8-995c-4a66-b1ff-79b4ed4564e8/image.png"><img src="https://velog.velcdn.com/images/vbghdl/post/6b1e1660-479e-43b0-b92d-4f00beeba51d/image.png"><img src="https://velog.velcdn.com/images/vbghdl/post/31975dc8-a5d2-4ea9-b9fe-7c8e3f278d38/image.png"></p><p>스터디를 진행하면서 궁금한 점들이 생길 때마다 멘토링 사전요청서에 작성하여 해당 질문에 대한 답들을 멘토님께 들을 수 있었고, 추가로 구글밋 등을 활용해 매주 멘토님과 직접 이야기하면서 궁금한 점들을 해결할 수 있었습니다.</p><h1 id="그룹스터디-후기"><a href="#그룹스터디-후기" class="headerlink" title="그룹스터디 후기"></a>그룹스터디 후기</h1><p>그룹스터디의 가장 큰 효과는 자기 자신을 객관화 할 수 있다는 점이었습니다. 내가 어느정도의 실력을 가지고 있는지, 스스로를 팀원들과 비교하면서 파악할 수 있었고 자신의 장점과 부족한점들 또한 배울 수 있는 기회가 되었습니다.</p><p>또한 혼자 공부를 진행해 가는 것은 매너리즘에 빠질 우려가 있습니다. 사람이 항상 의욕적일 수는 없고 어느 순간 나태해질 수 있는데, 확실한 목표 설정과 계획을 통해 강제적으로 공부해야되는 부분이 정해지다보니 항상 일정한 공부량을 채울 수 있게 되었고 하루에 공부하는 공부의 총량또한 늘어난 것이 느껴졌습니다.</p><p>기존에 다른 그룹스터디를 경험해보았지만 패스트캠퍼스 X 야놀자 부트캠프의 그룹스터디의 차별화 된 강점이 느껴진 부분은 지속적인 관리가 이루어진다는 점이었습니다. 그룹스터디 운영방식에 대해서는 자유를 부여하지만 멘토링 시스템의 도입과 운영진 분들의 진행사항 확인 등을 통해 각 그룹별 스터디가 잘 이루어지고 있는지를 지속적으로 검증할 수 있었고, 공부 방향에 대한 확신또한 얻을 수 있었습니다.</p><p>이대로 꾸준히 진행되었을 때 개발자로서의 역량을 키울 수 있다는 것에 확신이 생겼고, 부트캠프를 수료했을 때 얼마나 스스로가 성장해있을지를 기대하게 됩니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/09/21/fc-yanolja/group-study/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_OT</title>
      <link>https://namgungjongmin.github.io/2023/09/08/fc-yanolja/ot/</link>
      <guid>https://namgungjongmin.github.io/2023/09/08/fc-yanolja/ot/</guid>
      <pubDate>Fri, 08 Sep 2023 14:32:45 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/3d1bb5cf-a031-4139-a8ef-23586c7bd8e0/image.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;패스트캠퍼스 X 야놀자 프</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/3d1bb5cf-a031-4139-a8ef-23586c7bd8e0/image.png"></p><blockquote><p>패스트캠퍼스 X 야놀자 프론트엔드 과정의 ‘패스트러너’로 선발되었습니다. 🎺 (짝짝짝)<br>부트캠프의 처음 들어온 OT를 시작으로 앞으로 진행해나갈 주요 커리큘럼들의 후기들을 공유해보겠습니다. 해당 OT는 2023년 7월 10일 진행되었습니다.</p></blockquote><h1 id="야놀자-테크스쿨"><a href="#야놀자-테크스쿨" class="headerlink" title="야놀자 테크스쿨"></a>야놀자 테크스쿨</h1><p>‘아기다리고기다리’던 패스트캠퍼스X야놀자 부트캠프가 7월 10일 드디어 개강했습니다. 첫날이니 만큼 OT를 통해 앞으로의 부트캠프 진행에 대한 설명과 Q&amp;A, 그리고 이 기간동안 어떻게하면 개발자로서의 역량을 끌어올릴 수 있을지에 대한 멘토님들의 특강이 있었습니다.</p><p>저는 야놀자 테크스쿨 이전에 한번의 부트캠프를 이미 경험했었습니다. 시작은 노베이스의 사람들이 아예 기초부터 배울 수 있는 학원에 등록했었는데, 점점 개발에 흥미를 붙이고 컴퓨터 앞에 있는 시간이 늘어갈수록 눈에 보이는 변화가 나타났습니다. 코딩테스트 점수는 0.4점에서 만점을 받을 정도로 오르게 되었고, 여러 과제와 토이 프로젝트들도 성공적으로 마무리하여 우수수강생으로 선정되어 강남에서 오프라인 교육을 받을 수 있게 되었습니다.</p><p>특히 그곳에서는 ‘모던 자바스크립트 딥 다이브’의 저자인 이웅모 강사님께 자바스크립트 이론을 배웠는데 러버덕을 통해 내가 이해한 내용을 다른 사람에게 설명하는 방식의 공부법을 통해 내가 이해한 내용을 다른 사람에게 설명하는 방식의 공부법은 저에게 기초 지식에 대한 큰 자신감을 주었습니다. 여러 어플리케이션 구현과 한번의 팀 프로젝트를 경험한 뒤에 느낀 것은 성장했다는 기쁨과 그 이상의 갈증이었습니다.</p><p>‘내가 이전에 따라가기만에도 벅찼던 과정들을 성장한 나로서 다시 한번 경험해보고 싶다’</p><p>한번의 프로젝트는 너무나도 부족했습니다. 실제 현업에서 어떻게 프로젝트가 진행되는지를 간접적으로 느끼기에도 부족했고, ‘좀 더 준비된 상태의 나였다면 더 많은 것을 얻을 수 있지 않았을까?’라는 아쉬움도 크게 남았습니다. 결국 저는 다시 한번 부트캠프를 통해 개발자로서의 나를 더욱 성장시키고자 결심했습니다.</p><h2 id="다수의-프로젝트-경험을-제공하는-부트캠프"><a href="#다수의-프로젝트-경험을-제공하는-부트캠프" class="headerlink" title="다수의 프로젝트 경험을 제공하는 부트캠프"></a>다수의 프로젝트 경험을 제공하는 부트캠프</h2><p>여러 부트캠프 모집요강을 보면서 ‘패스트캠퍼스 X 야놀자 테크스쿨’은 프로젝트 기반으로 성장할 수 있는 기회를 마련해주는 부트캠프라는 생각이 들었습니다. 과정 중 지속적인 토이프로젝트와 팀 프로젝트 그리고 무엇보다 기업연계 &amp; 협업 프로젝트라는 것은 꼭 경험해보고 싶은 것이었습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/f9e14906-3380-49ab-b73e-59abd0922ee3/image.png"></p><p>또한 프로젝트에서 다양한 협업 관계자와 논의하며 프로젝트를 진행하는 경험을 제공한다는 특징또한 저의 마음을 사로잡았습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/14328d9a-885a-4f15-aa56-9f36f7f3780a/image.png"></p><p>이러한 이유들로 ‘패스트캠퍼스 X 야놀자 부트캠프’에 지원했고 자기소개서와 면접등을 치룬 뒤에 당당히 합격하게 되었습니다. 약 7개월 간의 여정 이후에 개발자로서 더욱 성장해있을 나를 기약하면서 하루하루 설렘속에 부트캠프를 이어나가고 있습니다.</p><hr><h1 id="Orientation"><a href="#Orientation" class="headerlink" title="Orientation"></a>Orientation</h1><p>OT에서 전체적인 커리큘럼 소개와 부트캠프 진행방식, 그리고 멘토님들의 특강이 진행되었습니다.</p><p>커리큘럼은 주어진 대로 학습을 이어나가기만 한다면 개발자로서의 역량을 충분히 단단하게 다질 수 있겠다는 생각이 들었습니다. 뿐만아니라 7개월이라는 긴 기간동안 부트캠프를 이어가다보면 매너리즘에 빠질 수 있고, 나태해지기 마련인데 운영자님들을 통한 지속적인 관리와 매주 있는 멘토님과의 멘토링을 통해 더욱 더 과정에 몰입할 수 있겠다는 생각을 했습니다.</p><h2 id="개발하면서의-Mind-Set"><a href="#개발하면서의-Mind-Set" class="headerlink" title="개발하면서의 Mind Set"></a>개발하면서의 Mind Set</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/a0e79f82-d09a-4ef0-b35d-1a2112abdc16/image.png"></p><p>특강의 주제로 앞으로 학습을 이어나가면서 가져야할 마인드 셋에 대하여 멘토님께서 알려주셨습니다. 어떻게 공부를 한 사람이 아웃풋을 높게 가져갔는지를 알려주시면서 개발 공부 중 지켜야 할 점들에 대해 설명해주셨습니다.</p><h2 id="무엇을-통해-성장할까"><a href="#무엇을-통해-성장할까" class="headerlink" title="무엇을 통해 성장할까?"></a>무엇을 통해 성장할까?</h2><h3 id="1-강의를-통한-성장"><a href="#1-강의를-통한-성장" class="headerlink" title="1) 강의를 통한 성장"></a>1) 강의를 통한 성장</h3><p><img src="https://velog.velcdn.com/images/vbghdl/post/8823fa25-a1c3-40f0-9f3a-89d0ab860018/image.png"></p><p>우선 강의만 들어서는 성장이 보장되지 않음을 강조하셨습니다. 실력 향상은 수강 시간에 비례하지 않고 <strong>고민의 총량</strong>에 비례한다는 것을 강조하셨습니다.</p><blockquote><p>강의의 예제코드를 그대로 따라치는 수강을 하지말 것<br>항상 ‘왜?’에 집중하여 고민하는 습관을 들이기<br>코드의 의미 새기기, 비판적으로 코드 바라보기, 다르게 구현해보기</p></blockquote><h3 id="2-오류를-통한-성장"><a href="#2-오류를-통한-성장" class="headerlink" title="2) 오류를 통한 성장"></a>2) 오류를 통한 성장</h3><p><img src="https://velog.velcdn.com/images/vbghdl/post/cf888eb8-e84a-41aa-819f-65ce60e0b36a/image.png"></p><p>오류 메시지의 원인과 해결을 기억하려는 습관 또한 성장하는 공부라고 하셨습니다. 왜 문제가 발생했고, 어떻게 해결했는지 기록하고, 시행착오를 반복하는 것으로 성장할 수 있다고 하셨습니다.</p><p>스스로 직면한 오류를 완전히 이해했는지에 대한 척도를 알려주셨습니다.</p><blockquote><ol><li>같은 오류 메세지를 발생시키는 다른 잘못된 코드를 작성 가능한가?(재현 가능한가)</li><li>다른 코드에서 같은 오류 메세지가 발생했을 때 해결 가능한가&gt;?</li><li>이 오류의 원인과 해결을 아무것도 참고하지 않은 상태에서 ‘설명’가능한가?</li></ol></blockquote><h3 id="3-TIL-x2F-블로그를-통한-성장-기록의-중요성"><a href="#3-TIL-x2F-블로그를-통한-성장-기록의-중요성" class="headerlink" title="3) TIL &#x2F; 블로그를 통한 성장 (기록의 중요성)"></a>3) TIL &#x2F; 블로그를 통한 성장 (기록의 중요성)</h3><p><img src="https://velog.velcdn.com/images/vbghdl/post/463030f2-8bd3-492b-a2b6-3518b1934cba/image.png"></p><p>채용 과정에서 과연 프로젝트의 코드만을 보여주는 것이 전부인지 물어보셨습니다. 그리고 채용 과정에서 우리가 보여줄려고 노력해야 하는 것은 <strong>성장, 성실함, 흡수력</strong>이라고 하셨습니다.</p><p>잘쓴 TIL과 블로그는 그 자체로 무기라고 표현하시고 꾸준한 글 작성을 통해 업무 성향, 성실도, 협업 가능성, 성장 과정을 보여줄 수 있다고 하셨습니다.</p><h4 id="TIL-x2F-블로그-작성-방법"><a href="#TIL-x2F-블로그-작성-방법" class="headerlink" title="TIL &#x2F; 블로그 작성 방법"></a>TIL &#x2F; 블로그 작성 방법</h4><p>추가로 모범적인 TIL과 블로그 작성 방법에 대해서도 조언해주셨는데 ‘문시해알’ 이라는 단어를 통해 설명해주셨습니다.</p><blockquote><p>문: 어떤 문제가 있었나<br>시: 내가 무얼 시도해봤지?<br>해: 어떻게 해결을 했나<br>알: 뭘 새롭게 알게 되었나</p></blockquote><h3 id="4-토이프로젝트를-통한-성장"><a href="#4-토이프로젝트를-통한-성장" class="headerlink" title="4) 토이프로젝트를 통한 성장"></a>4) 토이프로젝트를 통한 성장</h3><p>포트폴리오를 목적으로 한 토이 프로젝트는 기술적 개념을 다른 사람에게 설명할 수 있는 정도의 이해가 동반되어야 한다고 하셨습니다. 토이프로젝트를 구성하는 코드 중 어디를 가리키더라도 잘 설명할 수 있도록 스스로의 프로젝트에 대해 충분히 이해하면서 개발을 진행해야 한다고 하셨습니다.</p><h3 id="5-커밋-로그를-통한-성장"><a href="#5-커밋-로그를-통한-성장" class="headerlink" title="5) 커밋 로그를 통한 성장"></a>5) 커밋 로그를 통한 성장</h3><p>다른 사람의 코드와 커밋 메시지를 통해 다른 개발자들이 어떻게 코드를 쓰는지를 종종 확인하는 것도 스스로의 성장에 매우 큰 도움이 된다고 하셨습니다.</p><h2 id="어떻게-빠르게-성장할-수-있을까"><a href="#어떻게-빠르게-성장할-수-있을까" class="headerlink" title="어떻게 빠르게 성장할 수 있을까?"></a>어떻게 빠르게 성장할 수 있을까?</h2><p><img src="https://velog.velcdn.com/images/vbghdl/post/7537721b-de73-4884-844e-0829bcbd7f4d/image.png"></p><h3 id="1-시간-배분하기"><a href="#1-시간-배분하기" class="headerlink" title="1) 시간 배분하기"></a>1) 시간 배분하기</h3><p>강의 수강은 항상 자신의 코드로 복습하는 과정으로 이어져야 합니다. 반드시 하루 이내, 되도록 한 시간 이내로 실습하며 복습하는 해야 한다고 강조하셨습니다.</p><h3 id="2-질문을-활용하기"><a href="#2-질문을-활용하기" class="headerlink" title="2) 질문을 활용하기"></a>2) 질문을 활용하기</h3><p>패스트캠퍼스 X 야놀자 부트캠프의 경우는 항시 답변을 해주시는 멘토님이 배정됩니다. 따라서 충분한 고민 이후에 스스로 해결하지 못한 문제나 더 좋은 방안에 대한 질문을 멘토님에게 질문하면서 성장을 촉진할 수 있다고 하셨습니다.</p><p>여기서 중요한 점은 질문에도 좋은 질문과 나쁜 질문이 있다는 것입니다. 좋은 질문을 해야 성장에 도움이 된다고 하셨습니다.</p><h3 id="좋은-질문이란"><a href="#좋은-질문이란" class="headerlink" title="좋은 질문이란?"></a>좋은 질문이란?</h3><blockquote><ol><li>정돈된 질문 : 내가 무엇을 모르는지 어떠한 부분을 어떻게 모르는지 정확하게 아는 질문</li><li>충분한 고민이 반영된 질문</li><li>과거의 답변 &#x2F; 강의 &#x2F;구글링 &#x2F; 공식 문서를 통해서 해결하려고 했으나 실패한 질문</li></ol></blockquote><p>추가적으로 질문과 답변은 항시 기록하는 습관을 들여야 온전히 자신의 지식이 된다고 하셨습니다.</p><h1 id="OT-후기"><a href="#OT-후기" class="headerlink" title="OT 후기"></a>OT 후기</h1><p>오리엔테이션이 진행될수록 제가 ‘패스트캠퍼스 X 야놀자 부트캠프’를 고른 것이 정확한 선택이었음을 확신할 수 있었습니다. 각 커리큘럼에 대한 명확한 목적과 기대 효과를 저희에게 설명해주었고, 지속적인 수강생 관리와 일정한 간격으로 진행되는 멘토링, 그리고 언제나 자신의 고민들을 털어놓을 수 있는 환경임을 확인할 수 있었습니다.</p><p>OT에서 멘토님이 하셨던 말씀처럼 단지 이 커리큘럼을 온전하게 따라가는 것만으로도 내가 원하는 성장을 이룰 수 있겠구나라는 자신감을 불어넣어주는 부트캠프 소개였고, 스스로 마음을 다잡고 노력해나가야 겠다는 생각을 심어주는 시간이었습니다.</p><blockquote><p>현재 2023년 9월 8일, 이 글을 작성하는 시점에서 OT를 되돌아본다면 정말 OT에서 소개한 그대로 과정이 진행되고 있습니다. 지금까지 총 2개의 사이트 구현을 한 뒤 현재 팀빌딩 이후 토이프로젝트를 진행하고 있으며 각 과정마다 얻어가는 것들이 너무나도 많은 것 같습니다. 항상 저희들을 관리해주시고 매번 과정이나 강의가 끝날 때마다 의견을 여쭤보시며 향상된 부트캠프 경험을 제공하려고 노력하는 운영진분들 모두에게 감사의 말씀을 올립니다.</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/09/08/fc-yanolja/ot/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Ajax의 발전 과정</title>
      <link>https://namgungjongmin.github.io/2023/08/31/js/31_ajax%EB%B0%9C%EC%A0%84%EA%B3%BC%EC%A0%95/</link>
      <guid>https://namgungjongmin.github.io/2023/08/31/js/31_ajax%EB%B0%9C%EC%A0%84%EA%B3%BC%EC%A0%95/</guid>
      <pubDate>Thu, 31 Aug 2023 06:52:01 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/3e2bea4f-7465-4e21-a3e6-9992d35bfbbb/image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;AJAX는 자바스크립트를 사용하여 브라우저가 서버</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/3e2bea4f-7465-4e21-a3e6-9992d35bfbbb/image.png"></p><p>AJAX는 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식입니다.</p><p>전통적인 웹페이지는 html 태그로 시작하여 html로 끝나는 완전한 HTML 문서를 서버로부터 전송받아 웹페이지 전체를 처음부터 다시 렌더링하는 방식으로 동작했습니다. 따라서 화면이 전환되면 서버로부터 새로운 HTML 문서를 전송받아 웹페이지를 처음부터 다시 렌더링 했습니다.</p><hr><h1 id="전통적-웹페이지의-단점"><a href="#전통적-웹페이지의-단점" class="headerlink" title="전통적 웹페이지의 단점"></a>전통적 웹페이지의 단점</h1><ol><li><p>이전 웹페이지와 차이가 없어서 변경할 필요가 없는 부분들까지 새롭게 완전한 HTML을 전송받아야하기 때문에 불필요한 리소스가 발생합니다.</p></li><li><p>변경할 필요가 없는 부분을 처음부터 렌더링하기 때문에 페이지에 깜빡임 현상이 발생합니다.</p></li><li><p>클라이언트와 서버와의 통신이 동기 방식으로 동작하기 때문에 서버로부터 응답이 있을 때까지 추가적인 처리가 불가능합니다.</p></li></ol><p>AJAX의 등장으로 서버로부터 웹페이지에 변경이 필요한 부분만 데이터를 전송받아 렌더링하는 것이 가능해졌고, 이로 인해 데스크탑에서 애플리케이션과 유사한 빠른 퍼포먼스와 부드러운 화면 전환이 가능해졌습니다.</p><hr><h1 id="XMLHttpRequest-객체를-활용한-Http-요청"><a href="#XMLHttpRequest-객체를-활용한-Http-요청" class="headerlink" title="XMLHttpRequest 객체를 활용한 Http 요청"></a>XMLHttpRequest 객체를 활용한 Http 요청</h1><p>자바스크립트의 전통적인 Http 요청 방식은 XMLHttpRequest 객체를 이용한 방법이었습니다. XMLHttpRequest를 이용한 방식에서는 비동기 처리를 위한 패턴으로 콜백 함수를 사용해야 했습니다. 이러한 콜백 함수를 이용한 패턴은 콜백 헬로 인해 가독성이 나쁘고 비동기 처리 중 발생한 에러의 처리가 곤란하며, 여러 개의 비동기 처리를 한번에 처리하는 데에도 한계가 있었습니다.</p><p>아래 코드를 통해 전통적인 AJAX 이용에서 콜백 패턴이 필수적이었던 이유를 확인해보겠습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">url</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">  xhr.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">  xhr.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">response</span>));</span><br><span class="line">      todos = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">response</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(xhr.<span class="property">status</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">get</span>(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(todos); <span class="comment">// output: undefined</span></span><br></pre></td></tr></table></figure><p>서버로부터 응답이 도착하면 xhr 객체에서 load 이벤트가 발생합니다. 이때 xhr.onload 핸들러 프로퍼티에 바인딩한 이벤트 핸들러가 즉시 실행되지 않습니다. xhr.onload 이벤트 핸들러는 load 이벤트가 발생하면 일단 태스크큐에 저장되어 대기하다가, 콜 스택이 비면 이벤트 루프에 의해 콜 스택으로 푸쉬되어 실행됩니다.</p><p>따라서 기존 콜스택이 전부 비워져야만 우리가 원하는 코드 (todos에 값을 할당하는 코드)가 실행되기 때문에 기대한 대로 동작하지 않습니다.</p><p>이처럼 비동기 함수는 비동기 처리 결과를 외부에 반환할 수 없고, 상위 스코프의 변수에 할당할 수도 없습니다. 따라서 비동기 함수의 처리 결과에 대한 후속처리는 비동기 함수 내부에서 수행되어야 합니다. 이를 위해 비동기 함수 내부에 비동기 처리 결과에 대한 후석 처리를 수행하는 콜백 함수를 전달하는 것이 일반적입니다.</p><h1 id="전통적-Http-요청-방식의-문제점"><a href="#전통적-Http-요청-방식의-문제점" class="headerlink" title="전통적 Http 요청 방식의 문제점"></a>전통적 Http 요청 방식의 문제점</h1><h2 id="1-콜백-헬"><a href="#1-콜백-헬" class="headerlink" title="1) 콜백 헬"></a>1) 콜백 헬</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">url, callback</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> xhr  <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">  xhr.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">  xhr.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">response</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(xhr.<span class="property">status</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;https://jsonplaceholder.typicode.com&#x27;</span>;</span><br><span class="line"><span class="title function_">get</span>(<span class="string">`<span class="subst">$&#123;url&#125;</span>/post/1`</span>, <span class="function">(<span class="params">&#123;userId&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(userId); <span class="comment">// output: 1</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="string">`<span class="subst">$&#123;url&#125;</span>/users/<span class="subst">$&#123;userId&#125;</span>`</span>, <span class="function"><span class="params">userInfo</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo); <span class="comment">// output: &#123;id: 1, name: jongmin, username: Eric&#125;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>위 코드를 보면 GET요청을 통해 서버로부터 id가 1인 post를 취득하고 이 데이터를 사용하여 또 다시 GET 요청을 합니다. 이처럼 비동기 통신 내부에서 후속 처리를 위한 코드를 사용하는 콜백 패턴은 가독성을 저해하며 실수를 유발하는 원인이 됩니다.</p><p>만약 비동기 통신으로 취득한 단계적 데이터들에 의존한 코드가 몇겹씩 쌓이다보면 정말 말 그대로 지옥같은 코드가 생성됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="string">&#x27;step1&#x27;</span>, <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="string">`step2/<span class="subst">$&#123;a&#125;</span>`</span>, <span class="function"><span class="params">b</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="string">`step3/<span class="subst">$&#123;b&#125;</span>`</span>, <span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="title function_">get</span>(<span class="string">`step4/<span class="subst">$&#123;c&#125;</span>`</span>, <span class="function"><span class="params">d</span> =&gt;</span>&#123;</span><br><span class="line">         ...</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-에러-핸들링"><a href="#2-에러-핸들링" class="headerlink" title="2) 에러 핸들링"></a>2) 에러 핸들링</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(e); <span class="comment">// 에러 캐치 불가</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>전통적 Http 요청 방식에서 사용되는 콜백 패턴의 가장 큰 문제점은 에러처리가 곤란하다는 점입니다. 비동기 코드의 동작 원리를 다시 생각해보면 setTimeOut 함수의 콜백 함수는 런타임 환경에서 모든 코드가 실행된 이후 콜 스택이 완전히 비워진 이후에야 이벤트 루프를 통해 태스크 큐에서 콜 스택으로 푸쉬됩니다. 이 때 try catch 문은 종료된 시점이기 때문에 에러가 캐치되지 않습니다.</p><hr><h1 id="Promise의-등장"><a href="#Promise의-등장" class="headerlink" title="Promise의 등장"></a>Promise의 등장</h1><p>전통적 Http 요청을 위한 콜백 패턴은 콜백 헬이나 에러 처리의 문제가 있었습니다. 이를 극복하기위해 ES6에서 Promise가 도입되었습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">promiseGet</span> = url =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr  <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line"> xhr.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">  xhr.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">response</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(xhr.<span class="property">status</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">promiseGet</span>(<span class="string">&#x27;http://jsonplaceholder.typicode.com/posts/1&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v), <span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br></pre></td></tr></table></figure><p>Promise는 후속처리 메서드를 통해 에러 핸들링을 할 수 있습니다. then의 첫번 째 콜백 함수로 비동기 처리 결과가 성공했을 때의 후속 조치를 할 수 있고, 두 번째 콜백 함수로 비동기 처리 결과가 실패했을 때의 후속 조치도 가능합니다. 또한 catch메서드를 통해 전체적인 에러 핸들링또한 가능합니다.</p><p>또한 Promise는 체이닝을 통해 전통적 통신 방식에서의 콜백 헬도 해결이 가능합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">promiseGet</span>(<span class="string">`<span class="subst">$&#123;url&#125;</span>/posts/1`</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; userId &#125;</span>) =&gt;</span> <span class="title function_">promiseGet</span>(<span class="string">`<span class="subst">$&#123;url&#125;</span>/users/<span class="subst">$&#123;userId&#125;</span>`</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">userInfo</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(err));</span><br></pre></td></tr></table></figure><p>then, catch finally 후속 처리 메서드는 콜백 함수가 반환한 Promise를 반환합니다. 또한 콜백 함수가 Promise가 아닌 값을 반환하더라도 그 값을 암묵적으로 resolve 또는 reject하여 프로미스를 생성하여 반환합니다. 그렇게 반환한 Promise를 이용하여 체이닝을 통해 후속 처리를 하기 때문에 전통적 방식의 콜백 헬을 방지했다는 점은 긍정적이지만 결국 Promise도 콜백 패턴을 사용하기 때문에 가독성을 저해할 수 있다는 점에서 문제가 있습니다.</p><hr><h1 id="async-x2F-await를-이용한-후속-처리"><a href="#async-x2F-await를-이용한-후속-처리" class="headerlink" title="async &#x2F; await를 이용한 후속 처리"></a>async &#x2F; await를 이용한 후속 처리</h1><p>기존 콜백 패턴을 이용한 비동기 통신의 단점을 ES8에 도입된 async&#x2F;await를 통해 해결할 수 있습니다. async&#x2F;await를 사용하면 Promise의 후속 처리 메서드 없이 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; userId &#125; = <span class="keyword">await</span> <span class="title function_">promiseGet</span>(<span class="string">`<span class="subst">$&#123;url&#125;</span>/posts/1`</span>);</span><br><span class="line">    <span class="keyword">const</span> userInfo = <span class="keyword">await</span> <span class="title function_">promiseGet</span>(<span class="string">`<span class="subst">$&#123;url&#125;</span>/users/<span class="subst">$&#123;userId&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>async&#x2F;await는 Promise를 가독성 좋게 사용할 수 있는 방법입니다. 비동기 코드를 동기 코드 처럼 동작하도록 구현할 수 있습니다. 이것은 에러처리에서 기존 비동기적 특성 때문에 사용하지 못했던 try&#x2F;catch 문 또한 사용할 수 있다는 것을 의미합니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/JavaScript/">JavaScript</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/es6/">es6</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/Ajax/">Ajax</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/Promise/">Promise</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/XMLHttpRequest/">XMLHttpRequest</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/async-await/">async/await</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/08/31/js/31_ajax%EB%B0%9C%EC%A0%84%EA%B3%BC%EC%A0%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_JavaScript 과제 리팩토링</title>
      <link>https://namgungjongmin.github.io/2023/08/28/fc-yanolja/javascript-refactoring/</link>
      <guid>https://namgungjongmin.github.io/2023/08/28/fc-yanolja/javascript-refactoring/</guid>
      <pubDate>Mon, 28 Aug 2023 14:31:35 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/yanolja/2023-07-10-23-14-24.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;과제를-진행하며-느낀점&quot;&gt;&lt;a href=&quot;#과제를-진행하며-느낀점&quot; class=&quot;headerlink&quot; title=&quot;과제를 진행하며 </description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/yanolja/2023-07-10-23-14-24.png"></p><h1 id="과제를-진행하며-느낀점"><a href="#과제를-진행하며-느낀점" class="headerlink" title="과제를 진행하며 느낀점"></a>과제를 진행하며 느낀점</h1><p>지난 HTML&#x2F;CSS 과제가 우리가 눈으로 보는 페이지 디자인 자체를 만들어내는 것이 목적이었다면 이번<br>JavaScript 과제는 기능들을 동작하도록 하는 것이 중점이었다. 가장 크게 느꼈던 점은 기능이 동작하도록 하는 것에 있어서<br>수많은 방법들이 있다는 것이었다. 뿐만아니라 같은 기능이라도 유저의 입장에서 고민한다면 더욱 나은 방향으로 구현하는 것 또한<br>가능했다. 따라서 단지 실제 사이트와 같은 모습만을 만들면 되는 지난 과제보다 훨씬 어렵게 다가왔던 것 같다.</p><h2 id="1-Firebase을-처음으로-사용하면서"><a href="#1-Firebase을-처음으로-사용하면서" class="headerlink" title="1) Firebase을 처음으로 사용하면서"></a>1) Firebase을 처음으로 사용하면서</h2><p>이번 과제의 필수 요건 중 하나는 데이터를 따로 저장하여 관리할 수 있는 서비스인 AWS S3나 Firebase같은 기능을 이용하는 것이었다.<br>커리큘럼 내 강의에서 접해보지 못한 부분이었기 때문에 관련 정보들을 검색하고 공식 문서를 사용해 하나하나 익혀가면서 기능을 구현했다.<br>이 과정에서 두 가지의 긍정적인 경험을 할 수 있었다.</p><p>첫 째, 내가 처음 접하는 기술이라도 공식 문서를 통해 익혀가면서 문제들을 해결해나갈 수 있다는 자신감을 얻게 되었다. 강의로 배운 내용들이<br>아닌 내가 스스로 문서를 읽고 시행착오를 겪어가며 마주치는 문제들을 해결하다보니 이제는 어떻게 새로 기술들을 배울 때 문서들을 참고해야할지<br>경험할 수 있었고, 공식 문서의 내용이 내 생각 이상으로 자세하고 친절하다는 것을 깨달았다. 새로운 것을 배울 때 유튜브와 인프런 등의<br>강의들을 뒤지며 어떻게 배워나가야할까 고민하던 내가 이번 경험으로 강의만이 정답이 아니라는 것을 알았고, 문서를 통해 학습하는 것 또한<br>빠르게 기능을 구현할 수 있는 방법이라는 것을 알게되었다.</p><p>둘 째, 데이터를 어떤 방식으로 저장할지 어떻게 사용할지를 고민하게 되면서 그간 프론트엔드에서 경험할 수 없던 것들을 직접 경험할 수 있었다.<br>프론트엔드 과정의 특성 상 실제 유저들이 접하는 페이지와 UI들에 대해 고민하게 되는 경우는 많아도 실제로 어떻게 데이터를 줄 것인지, 어떻게<br>저장할 것인지 생각해볼 기회가 없었다. 하지만 이번에 과제에서는 그러한 것들을 직접 해봄으로써 실제 사이트들이 어떻게 돌아가고 있는지에 대한<br>감을 익힐 수 있었다.</p><h2 id="2-동작에만-집중하는-코드는-목표한-기능에-불필요한-동작을-추가시킬-수-있다"><a href="#2-동작에만-집중하는-코드는-목표한-기능에-불필요한-동작을-추가시킬-수-있다" class="headerlink" title="2) 동작에만 집중하는 코드는 목표한 기능에 불필요한 동작을 추가시킬 수 있다."></a>2) 동작에만 집중하는 코드는 목표한 기능에 불필요한 동작을 추가시킬 수 있다.</h2><p>구현하고자 하는 기능에 대해 정확히 뭐가 필요한지 그것을 해내려면 무엇을 알아야 할지 파악하고 그것을 바탕으로 작업을 해야된다는 것을 느꼈다.</p><p>자바스크립트는 자유로운 언어다. 그만큼 내가 원하는 것들을 다양한 방법으로 구현할 수 있고, 그 과정에서 꼭 필요하지 않은 작업을 하는 경우가 있었다.<br>멘토님께서 지적해주신 placeholder에 관한 부분이었는데, html의 input요소의 특성상 placeholder 속성에 값을 부여해주면 blur처리 될 때 input value에 따라 자동으로 placeholder를 다시 보여준다. 하지만 나는 ‘그렇게 동작해야지’ 라는 생각에만 사로잡혀 이미 그렇게 구현되어있는 기능들까지<br>하나하나 자바스크립트를 통해 동작을 제어하였다. 동작만에 생각이 매몰되어 정작 전체적인 그림을 보지 못했던 것이었다. 단순히 이런 동작을 하게<br>해야지에 집중하는 것이 아니라 전체적인 기능에 있어 내가 무엇을 제어해야되고, 어떤 것이 필요한지를 제대로 생각하고 코드를 작성해야겠다고<br>생각했다.</p><h2 id="3-여러-방법들-중에-선택한-이유가-있어야-한다"><a href="#3-여러-방법들-중에-선택한-이유가-있어야-한다" class="headerlink" title="3) 여러 방법들 중에 선택한 이유가 있어야 한다."></a>3) 여러 방법들 중에 선택한 이유가 있어야 한다.</h2><p>멘토님의 멘토링 과정에서 지속적인 함수호출에 관련하여 debounce라는 기능에 대해 설명을 들었고, 이번 과제에서 활용해보고자 하였다. 로그인 기능에서<br>이메일, 패스워드 입력값을 받아 validation 할 때, 매 input값의 변경마다 validation을 하는 것이 비효율적이라 느껴서 적용한 것이었는데 과연<br>내가 그 동작을 하도록 하는 방법에 대해 고민했는가를 생각해보았다. 분명 비슷한 동작을 하는 다른 방법들이 있었을 것이다. 그러나 고민이 없었기에<br>그저 사용하여 기능을 구현하고 만족했다.</p><p>리팩토링을 하면서 이에 대해 생각하면서 debounce를 고민할 때에는 비슷한 동작을 하는 throttle도 함께 고민했어야 한다고 생각했다. 결과적으로는<br>throttle보다 debounce를 통해 구현하는 것이 원래 목적에 맞았지만, 그저 결과적으로 옳은 방법을 선택한 것과 둘을 고민해서 왜 그게 옳은 것인지를<br>확인하고 넘어가는 것에는 큰 차이가 있다. 이제는 동작에 대해 고민할 때 가능한 여러 방법들을 생각하고 타당한 이유와 함께 선택하여 코드를 작성해야겠다.</p><h1 id="멘토님의-코드리뷰"><a href="#멘토님의-코드리뷰" class="headerlink" title="멘토님의 코드리뷰"></a>멘토님의 코드리뷰</h1><h2 id="1-비동기-코드에-대한-전반적인-이해와-예외처리의-부족"><a href="#1-비동기-코드에-대한-전반적인-이해와-예외처리의-부족" class="headerlink" title="1) 비동기 코드에 대한 전반적인 이해와 예외처리의 부족"></a>1) 비동기 코드에 대한 전반적인 이해와 예외처리의 부족</h2><p>분명 이론적으로 학습할 때에는 알고있다고 생각한 내용들이었지만 실제 과제에서 적용하면서 왜 이것들이 필요한지, 어떤 방식으로 사용해야 하는지에 대해<br>깊게 생각하지 않고, 이걸 적용해야 기능이 동작하네!라는 것에만 초점을 맞췄던 것 같다. 그러다보니 불필요한 async&#x2F;await 사용과 예외처리 부분에서<br>아쉬운 코드가 되었던 것 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;member-list&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">render</span> = <span class="keyword">async</span> (<span class="params">members, isSignin = <span class="literal">false</span></span>) =&gt; &#123;</span><br></pre></td></tr></table></figure><p>async&#x2F;await의 경우 비동기 함수를 마치 동기처럼 코드 내에서 처리하기 위한 방법이다. 따라서 비동기 코드들의 순서에 의존하는 코드들이 아니라면<br>굳이 사용할 필요가 없었다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존 코드</span></span><br><span class="line"><span class="keyword">const</span> [person, division, email, password, contact, picture] = $form;</span><br><span class="line"><span class="comment">// 사진 firebase 올리고 profileUrl 할당</span></span><br><span class="line"><span class="keyword">const</span> profileUrl = <span class="keyword">await</span> <span class="title function_">uploadImage</span>(email.<span class="property">value</span>, picture.<span class="property">files</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">addData</span>(person.<span class="property">value</span>, email.<span class="property">value</span>, contact.<span class="property">value</span>, division.<span class="property">value</span>, profileUrl);</span><br><span class="line"></span><br><span class="line">location.<span class="title function_">replace</span>(<span class="string">&#x27;main.html&#x27;</span>);</span><br></pre></td></tr></table></figure><p>위 코드를 보면 비동기 코드가 많은 것을 확인할 수 있다. 개발 시 에러가 발생했을 때 어떤 함수에서 문제가 있었는지를 수월하게 파악하기 위해서 try&#x2F;catch를 통해 예외처리 하는 것을 습관해야한다고 멘토님께서 말씀해 주셨다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 리팩토링 코드</span></span><br><span class="line"><span class="keyword">const</span> [person, division, email, password, contact, picture] = $form;</span><br><span class="line"><span class="comment">// 사진 firebase 올리고 profileUrl 할당</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">profileUrl</span> = email =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">uploadImage</span>(email.<span class="property">value</span>, picture.<span class="property">files</span>[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">addData</span>(person.<span class="property">value</span>, email.<span class="property">value</span>, contact.<span class="property">value</span>, division.<span class="property">value</span>, <span class="title function_">profileUrl</span>(email));</span><br><span class="line"></span><br><span class="line">location.<span class="title function_">replace</span>(<span class="string">&#x27;main.html&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="2-apikey를-환경변수로-관리"><a href="#2-apikey를-환경변수로-관리" class="headerlink" title="2) apikey를 환경변수로 관리"></a>2) apikey를 환경변수로 관리</h2><p>로컬에서 개발할 때와 서버에 배포할 때 DB연결, 포트 설정 등 관련된 부분을 매번 수정해서 배포하는 것은 쉽지 않다. 또한 유출되면 안되는 secret key<br>는 public으로 배포하면 안된다는 것을 다시 한번 상기하게 되었다. firebase를 사용하면서 내 데이터베이스에 접근할 수 있는 key들을 그대로 오픈해놨는데<br>지금처럼 학습용으로 작은 사이트를 만들 때에는 상관이 없더라도 기업에서 일을 할 때 매우 크게 잘못될 수 있으니 이러한 것들을 환경변수로 관리하는 것을<br>습관하해야겠다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존 firebase.js 안에 apikey를 노출</span></span><br><span class="line"><span class="keyword">const</span> firebaseConfig = &#123;</span><br><span class="line">  <span class="attr">apiKey</span>: <span class="string">&#x27;AIzaSyCy7QYDgKpkn-0eH42AmxAki6u4DH1oGZ0&#x27;</span>,</span><br><span class="line">  <span class="attr">authDomain</span>: <span class="string">&#x27;members-dev-d3512.firebaseapp.com&#x27;</span>,</span><br><span class="line">  <span class="attr">projectId</span>: <span class="string">&#x27;members-dev-d3512&#x27;</span>,</span><br><span class="line">  <span class="attr">storageBucket</span>: <span class="string">&#x27;members-dev-d3512.appspot.com&#x27;</span>,</span><br><span class="line">  <span class="attr">messagingSenderId</span>: <span class="string">&#x27;277572932709&#x27;</span>,</span><br><span class="line">  <span class="attr">appId</span>: <span class="string">&#x27;1:277572932709:web:070862b87f629ee329a28c&#x27;</span>,</span><br><span class="line">  <span class="attr">measurementId</span>: <span class="string">&#x27;G-3GBJM8LJ01&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// dotenv를 활용하여 환경변수로 관리</span><br><span class="line"># .env</span><br><span class="line">f_Apikey=AIzaSyCy7QYDgKpkn-0eH42AmxAki6u4DH1oGZ0</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;dotenv/config&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apiKey = process.<span class="property">env</span>.<span class="property">f_apikey</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firebaseConfig = &#123;</span><br><span class="line">  apiKey,</span><br><span class="line">  <span class="attr">authDomain</span>: <span class="string">&#x27;members-dev-d3512.firebaseapp.com&#x27;</span>,</span><br><span class="line">  <span class="attr">projectId</span>: <span class="string">&#x27;members-dev-d3512&#x27;</span>,</span><br><span class="line">  <span class="attr">storageBucket</span>: <span class="string">&#x27;members-dev-d3512.appspot.com&#x27;</span>,</span><br><span class="line">  <span class="attr">messagingSenderId</span>: <span class="string">&#x27;277572932709&#x27;</span>,</span><br><span class="line">  <span class="attr">appId</span>: <span class="string">&#x27;1:277572932709:web:070862b87f629ee329a28c&#x27;</span>,</span><br><span class="line">  <span class="attr">measurementId</span>: <span class="string">&#x27;G-3GBJM8LJ01&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-성능을-생각하여-코드를-구성"><a href="#3-성능을-생각하여-코드를-구성" class="headerlink" title="3) 성능을 생각하여 코드를 구성"></a>3) 성능을 생각하여 코드를 구성</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">async</span> e =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;isSignin&#x27;</span>)) === <span class="string">&#x27;null&#x27;</span>) &#123;</span><br><span class="line">    location.<span class="title function_">replace</span>(<span class="string">&#x27;signin.html&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">getAllMembers</span>(state.<span class="property">members</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">render</span>(state.<span class="property">members</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위 코드에서 페이지에 적용되는 render함수는 getAllMembers함수가 반드시 실행된 이후에 동작하게 된다. 처음 이렇게 코드를 구성한 이유는<br>데이터를 추가&#x2F;삭제 할 때 데이터베이스에 먼저 반영하고 그 데이터를 토대로 페이지에 렌더하려는 것이 목적이었다. 그러나 리스트를 삭제하고<br>추가할 때마다 데이터베이스를 먼저 거치고 페이지에 반영하는 것은 사용자 입장에서 더 느린 응답을 받는 결과로 이어진다는 것을 생각하지 못했다.</p><p>최초 데이터를 불러올 때에만 getAllMembers를 먼저 실행하여 페이지에 반영하고 그 이후에는 자바스크립트에서 미리 객체를 선언해서 동시에 관리하면<br>훨씬 빠른 응답을 줄 수 있을 것이라 생각하였다. 객체를 수정하여 먼저 페이지에 반영한 뒤에 그 결과를 데이터베이스에 전달하는 것이 사용자 경험에서<br>효율적일 것이라 생각했다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/">리팩토링</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/08/28/fc-yanolja/javascript-refactoring/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>이벤트 핸들러 프로퍼티와 addEventListener 메서드의 차이점</title>
      <link>https://namgungjongmin.github.io/2023/08/20/js/25_%EC%9D%B4%EB%B2%A4%ED%8A%B8%ED%95%B8%EB%93%A4%EB%A7%81%EB%B0%A9%EC%8B%9D/</link>
      <guid>https://namgungjongmin.github.io/2023/08/20/js/25_%EC%9D%B4%EB%B2%A4%ED%8A%B8%ED%95%B8%EB%93%A4%EB%A7%81%EB%B0%A9%EC%8B%9D/</guid>
      <pubDate>Sun, 20 Aug 2023 08:22:41 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/3e2bea4f-7465-4e21-a3e6-9992d35bfbbb/image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;이벤트 핸들러는 이벤트가 발생했을 때 브라우저에 </description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/3e2bea4f-7465-4e21-a3e6-9992d35bfbbb/image.png"></p><p>이벤트 핸들러는 이벤트가 발생했을 때 브라우저에 호출을 위임한 함수입니다. 이벤트가 발생하면 자바스크립트 엔진은 브라우저에게 이벤트 핸들러의 호출을 위임하게 하는 것을 이벤트 핸들러 등록이라고 합니다. 이벤트 핸들러를 등록하는 방법은 총 3가지입니다. ‘이벤트 핸들러 어트리뷰트 방식’, ‘이벤트 핸들러 프로퍼티 방식’, ‘addEventListener 방식’으로 이벤트 핸들러를 등록합니다.</p><p>이벤트 핸들러 어트리뷰트 방식은 오래된 코드에서 간혹 확인해볼 수 있기 때문에 이런 것이 있다고만 알아두는 것이 좋습니다. HTML과 자바스크립트는 마크업과 Interection이라는 서로 다른 관심사를 가지고 있기 때문에 혼재하는 것보다는 분리하는 것이 좋습니다. 이번 포스팅에서는 자바스크립트 내에서 핸들러를 등록하는 두가지 방식을 중점적으로 비교하겠습니다.</p><hr><h1 id="이벤트-핸들러-등록"><a href="#이벤트-핸들러-등록" class="headerlink" title="이벤트 핸들러 등록"></a>이벤트 핸들러 등록</h1><h2 id="이벤트-핸들러-어트리뷰트-방식"><a href="#이벤트-핸들러-어트리뷰트-방식" class="headerlink" title="이벤트 핸들러 어트리뷰트 방식"></a>이벤트 핸들러 어트리뷰트 방식</h2><p>위에 서술한대로 예전 DOM level0 때나 관심사의 분리를 통한 웹 구성을 하기 이전의 레거시 코드로 남아있는 경우가 많습니다. 그러나 모던 자바스크립트에서는 이벤트 핸들러 어트리뷰트 방식을 사용하는 경우가 있기 때문에 알아둘 필요는 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--<span class="title class_">Angular</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">&quot;handleClick($event)&quot;</span>&gt;</span>button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#123; <span class="comment">/* React */</span>&#125;</span><br><span class="line">&lt;button onClick=<span class="string">&quot;handleClick($event)&quot;</span>&gt;button&lt;/button&gt;</span><br></pre></td></tr></table></figure><h2 id="이벤트-핸들러-프로퍼티-방식"><a href="#이벤트-핸들러-프로퍼티-방식" class="headerlink" title="이벤트 핸들러 프로퍼티 방식"></a>이벤트 핸들러 프로퍼티 방식</h2><p>DOM 노드 객체는 이벤트에 대응하는 이벤트 핸들러 프로퍼티를 가지고 있으며, onclick과 같이 on 접두사와 이벤트의 종류를 나타내는 이벤트 타입으로 이루어져있습니다. 이벤트 핸들러를 등록하기 위해 이벤트를 발생시킬 대상 (이벤트 타깃)과 이벤트의 종류 (이벤트 타입) 그리고 이밴트 핸들러를 지정해주어야 합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$button.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="addEventListener-메서드-방식"><a href="#addEventListener-메서드-방식" class="headerlink" title="addEventListener 메서드 방식"></a>addEventListener 메서드 방식</h2><p>DOM Level 2에서 도입된 addEventListener 메서드 방식은 메서드를 사용하여 이벤트 핸들러를 등록할 수 있습니다. 첫번째 매개변수로 이벤트의 종류를 나타내는 이벤트 타입, 두번째 매개변수로 이벤트 핸들러를 전달합니다. 마지막 매개변수에는 이벤트를 캐치할 이벤트 전파단계를 지정합니다. 생략하거나 false를 지정하면 버블링 단계에서 이벤트를 캐치하고, true를 지정하면 캡처링 단계에서 이벤트를 캐치합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"></span><br><span class="line">$button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h1 id="이벤트-핸들러-프로퍼티와-addEventListener-메서드의-차이점"><a href="#이벤트-핸들러-프로퍼티와-addEventListener-메서드의-차이점" class="headerlink" title="이벤트 핸들러 프로퍼티와 addEventListener 메서드의 차이점"></a>이벤트 핸들러 프로퍼티와 addEventListener 메서드의 차이점</h1><p>스크립트 내에서 이벤트를 등록하는 두 방식에는 이벤트의 누적 여부, 이벤트 전파 정의 등의 차이가 있습니다.</p><h2 id="이벤트-누적-여부"><a href="#이벤트-누적-여부" class="headerlink" title="이벤트 누적 여부"></a>이벤트 누적 여부</h2><p>이벤트 핸들러 프로퍼티는 이벤트 객체를 하나만 등록 가능합니다. 만약 2개의 이벤트 핸들러를 등록하게 되면 가장 마지막에 추가한 이벤트 핸들러가 이전 이벤트 핸들러를 덮어쓰게 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $test = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func3</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$test.<span class="property">onclick</span> = func1;</span><br><span class="line">$test.<span class="property">onclick</span> = func2;</span><br><span class="line">$test.<span class="property">onclick</span> = func3;</span><br></pre></td></tr></table></figure><p><img src="https://velog.velcdn.com/images/vbghdl/post/a0c6baf0-96a5-4ea7-95e1-de6152a4fca2/image.png"></p><p>그러나 addEventListener 메서드 방식의 경우 이벤트 핸들러가 누적되어 이벤트가 모두 실행되는 것을 확인할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $test = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func3</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$test.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, func1);</span><br><span class="line">$test.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, func2);</span><br><span class="line">$test.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, func3);</span><br></pre></td></tr></table></figure><p><img src="https://velog.velcdn.com/images/vbghdl/post/270bbedb-7f54-4628-86db-e607728c1d02/image.png"></p><h2 id="이벤트-전파-정의"><a href="#이벤트-전파-정의" class="headerlink" title="이벤트 전파 정의"></a>이벤트 전파 정의</h2><p>이벤트 핸들러 프로퍼티 방식과 달리 addEventListener 메서드 방식은 세 번째 매개변수로 버블링으로 작동될지, 캡쳐링으로 작동될지의 여부를 지정할 수 있습니다. 세 번째 매개변수가 true일 경우 캡쳐링을 사용하고false일 경우 버블링을 사용합니다.</p><p>따라서 이벤트 핸들러 프로퍼티 방식은 기존 이벤트 타입별 기본 적용된 전파 방식을 그대로 따라야 하는 반면 addEventListener 방식은 필요에 따라 전파 방식을 지정하여 유연한 코드 작성이 가능합니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/JavaScript/">JavaScript</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/es6/">es6</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%9D%B4%EB%B2%A4%ED%8A%B8/">이벤트</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%9D%B4%EB%B2%A4%ED%8A%B8%ED%95%B8%EB%93%A4%EB%9F%AC/">이벤트핸들러</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/addEventListener/">addEventListener</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/08/20/js/25_%EC%9D%B4%EB%B2%A4%ED%8A%B8%ED%95%B8%EB%93%A4%EB%A7%81%EB%B0%A9%EC%8B%9D/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>배열과 HTMLCollection / NodeList 객체</title>
      <link>https://namgungjongmin.github.io/2023/08/19/js/24_innerHTML%EB%AC%B8%EC%A0%9C%EC%A0%90/</link>
      <guid>https://namgungjongmin.github.io/2023/08/19/js/24_innerHTML%EB%AC%B8%EC%A0%9C%EC%A0%90/</guid>
      <pubDate>Sat, 19 Aug 2023 12:32:31 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/3e2bea4f-7465-4e21-a3e6-9992d35bfbbb/image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;innerHTML&quot;&gt;&lt;a href=&quot;#i</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/3e2bea4f-7465-4e21-a3e6-9992d35bfbbb/image.png"></p><h1 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h1><p>Element.prototype.innerHTML 프로퍼티는 요소 노드의 HTML 마크업을 취득하거나 변경할 때 사용합니다. 요소 노드의 innerHTML 프로퍼티를 참조하면 요소 노드의 콘텐츠 영역 내의 모든 HTML 마크업을 문자열로 반환하게 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>temporal<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-class">.red</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-class">.blue</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">color</span>: blue;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>).<span class="property">innerHTML</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://velog.velcdn.com/images/vbghdl/post/224eb192-57ae-4acf-a38c-01553b3c11b9/image.png"></p><p>innerHTML 프로퍼티에 문자열을 할당하여 간단히 DOM 조작이 가능합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>temporal<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-class">.red</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-class">.blue</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">color</span>: blue;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">      document.getElementById(&#x27;list&#x27;).innerHTML =</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        &#x27;<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span>&#x27;;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://velog.velcdn.com/images/vbghdl/post/fe397d63-89b4-4f56-9992-fce69cb3417f/image.png"></p><hr><h1 id="innerHTML-사용의-위험성"><a href="#innerHTML-사용의-위험성" class="headerlink" title="innerHTML 사용의 위험성"></a>innerHTML 사용의 위험성</h1><p>요소 노드의 innerHTML 프로퍼티에 할당한 HTML 마크업 문자열을 자바스크립트 엔진에 의해 파싱되어 DOM에 반영됩니다. 문제는 사용자로부터 입력받은 데이터를 innerHTML 프로퍼티에 할당하는 경우 엔진이 해당 라인을 파싱할 때 코드가 실행될 수 있는 위험이 있다는 것입니다. 만약 악의적 목적의 사용자가 input 값으로 악성 코드를 포함시킨다면 엔진이 파싱하는 과정에서 해당 코드가 평가되면서 실행되게 됩니다.</p><p>이러한 공격을 크로스 사이트 스크립팅(XSS)라고 합니다.</p><h2 id="innerHTML-프로퍼티에-스크립트-태그를-삽입하는-예시"><a href="#innerHTML-프로퍼티에-스크립트-태그를-삽입하는-예시" class="headerlink" title="innerHTML 프로퍼티에 스크립트 태그를 삽입하는 예시"></a>innerHTML 프로퍼티에 스크립트 태그를 삽입하는 예시</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;testForm&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>결과 보기<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: 5px solid red; height: 40px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> $form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;testForm&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> $textArea = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> $result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> secretKey = <span class="string">&#x27;abcd1234ImportantKey&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  $form.<span class="title function_">addEventListener</span>(<span class="string">&#x27;submit&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    e.<span class="title function_">preventDefault</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $result.<span class="property">innerHTML</span> = e.<span class="property">target</span>.<span class="property">test</span>.<span class="property">value</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://velog.velcdn.com/images/vbghdl/post/ef0b07bd-318f-4413-acfd-804cf1aaba12/image.png"></p><hr><h1 id="innerHTML-사용-시-XSS-방어하는-방법"><a href="#innerHTML-사용-시-XSS-방어하는-방법" class="headerlink" title="innerHTML 사용 시 XSS 방어하는 방법"></a>innerHTML 사용 시 XSS 방어하는 방법</h1><p>HTML5는 innerHTML 프로퍼티로 삽입된 script 요소 내의 자바스크립트 코드를 실행하지 않습니다. 그러나 위 예시처럼 태그 안의 onerror 등의 프로퍼티를 통해 실행되는 코드들까지는 막을 수 없습니다.</p><p>innerHTML 프로퍼티는 DOM 조작을 간편하고 직관적으로 할 수 있다는 장점이 있지만 XSS에 취약한 단점을 가지고 있습니다. 이 단점을 해결하기 위해 HTML 새니티제이션을 사용할 수 있습니다.</p><p>HTML 새니티제이션은 사용자로부터 입력받은 데이터에 의해 발생할 수 있는 XSS 공격을 예방하기 위해 잠재적 위험을 제거하는 기능입니다. 보통 DOMpurify 라이브러리 기능 등을 이용해 간편하게 구현이 가능합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">DOMPurify</span>.<span class="title function_">sanitize</span>(<span class="string">&#x27;&lt;img src=&quot;/&quot; onerror=&quot;alert(document.cookie)&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// =&gt; &lt;img src=&quot;/&quot;&gt;</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/JavaScript/">JavaScript</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/es6/">es6</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B0%B0%EC%97%B4/">배열</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/HTMLCollection/">HTMLCollection</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/NodeList/">NodeList</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/08/19/js/24_innerHTML%EB%AC%B8%EC%A0%9C%EC%A0%90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>배열과 HTMLCollection / NodeList 객체</title>
      <link>https://namgungjongmin.github.io/2023/08/17/js/23_nodelist_%EB%B0%B0%EC%97%B4%EB%A9%94%EC%84%9C%EB%93%9C/</link>
      <guid>https://namgungjongmin.github.io/2023/08/17/js/23_nodelist_%EB%B0%B0%EC%97%B4%EB%A9%94%EC%84%9C%EB%93%9C/</guid>
      <pubDate>Thu, 17 Aug 2023 14:12:11 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/3e2bea4f-7465-4e21-a3e6-9992d35bfbbb/image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;DOM 컬렉션 객체인 HTMLCollection </description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/3e2bea4f-7465-4e21-a3e6-9992d35bfbbb/image.png"></p><p>DOM 컬렉션 객체인 HTMLCollection 객체와 NodeList 객체는 DOM API가 여러 개의 값을 반환하기위한 객체입니다. 둘다 유사배열 객체이면서 이터러블이므로 for…of문을 포함한 여러 방법으로 순회가 가능합니다. 또한 스프레드 문법을 사용하여 배열로 간단히 변환할 수 있습니다.</p><p>HTMLCollection과 NodeList는 노드 객체의 상태를 실시간으로 반영하는 살아있는 객체라는 것입니다. HTMLCollection 객체는 언제나 ‘live 객체’로 동작하지만 NodeList 객체는 기본적으로 실시간으로 반영하지 않고 과거의 상태를 유지하지면 경우에 따라서는 live 객체로 동작합니다.</p><h1 id="HTMLCollection-객체"><a href="#HTMLCollection-객체" class="headerlink" title="HTMLCollection 객체"></a>HTMLCollection 객체</h1><p>HTMLCollection 객체는 getElementsByTagName, getElementByClassName 메서가 반환하는 노드 객체입니다. HTMLCollection 객체는 노드 객체의 상태 변화를 실시간으로 반영하는 살아있는 DOM 컬렉션 객체로 ‘live 객체’라고 부르기도 합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>temporal<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-class">.red</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="selector-class">.blue</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">color</span>: blue;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> $elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;red&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>($elements); <span class="comment">// output: HTMLCollection(3) [li.red, li.red, li.red]</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; $elements.<span class="property">length</span>; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        $elements[i].<span class="property">className</span> = <span class="string">&#x27;blue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>($elements); <span class="comment">// output: HTMLCollection(1) [li.red]</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>위 코드에서 class 값이 ‘red’인 요소를 모두 취득하고 for문을 통해 모든 요소의 class 값을 ‘blue’로 변경하였습니다. 우리가 생각할 때 모든 li 요소의 class 값이 ‘blue’로 변경될 것이라고 생각하지만 예상대로 동작하지 않습니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/796a482a-63b4-4e9d-95a4-9bcd69875d04/image.png"></p><p>이것은 HTMLCollection 객체가 live 객체의 특성을 가지고 있기 때문입니다. for문을 돌면서 i &#x3D;&#x3D;&#x3D; 0 에서 첫번째 li의 class의 값을 ‘blue’로 변경합니다. 이 때 $elements가 참조하는 컬렉션 객체는 실시간으로 상태를 반영하여 HTMLCollection(2)[li.red, li.red] 상태가 됩니다. 따라서 i &#x3D;&#x3D;&#x3D; 1 에서 적용되는 대상은 첫 선언한 요소들 중 세번째 li가 됩니다. 따라서 HTMLCollection 객체를 반복문을 통해 순회할 때에는 주의가 필요합니다.</p><h1 id="NodeList-객체"><a href="#NodeList-객체" class="headerlink" title="NodeList 객체"></a>NodeList 객체</h1><p>HTMLCollection 객체의 부작용을 회피하기 위해 NodeList 객체를 이용하는 방법이 있습니다. querySellectorAll 메서드를 사용하면 DOM 컬렉션 객체인 NodeList를 반환합니다. 이 때 NodeList는 실시간으로 상태를 반영하지 않는 non-live 객체입니다. 그러나 childNodes 프로퍼티가 반환하는 NodeList객체는 live 객체로 동작합니다.</p><h1 id="안전하게-DOM-컬렉션-객체를-활용하는-방법"><a href="#안전하게-DOM-컬렉션-객체를-활용하는-방법" class="headerlink" title="안전하게 DOM 컬렉션 객체를 활용하는 방법"></a>안전하게 DOM 컬렉션 객체를 활용하는 방법</h1><p>HTMLCollection의 경우 live 객체의 특성 때문에 개발자가 예상치 못한 결과를 초래할 수 있다는 위험성이 있고, NodeList의 경우는 대부분 non-live 객체로 동작하지만 일부 상황에선 live-객체로 동작하는 위험성이 있습니다. 따라서 Dom 컬렉션 객체를 직접적으로 참조하는 것보다 배열로 변환하여 활용하는 방법을 추천합니다. ES6의 스프레드 문법을 통해 간단히 배열로 변환할 수 있습니다. 배열로 변환하게 되면 배열의 프로토타입을 상속받아 여러 메서드들도 사용할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $elements = [...<span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;red&quot;</span>)];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($elements); <span class="comment">// output: [li.red, li.red, li.red]</span></span><br><span class="line"></span><br><span class="line">$elements.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  el.<span class="property">className</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://velog.velcdn.com/images/vbghdl/post/a835d3fd-8389-43a6-bc4a-69fc34a4753a/image.png"></p><h1 id="forEach-메서드"><a href="#forEach-메서드" class="headerlink" title="forEach 메서드"></a>forEach 메서드</h1><p>HTMLCollection 객체는 forEach 메서드 사용이 불가능하고 NodeList 객체는 가능합니다. 보다 정확히 말하면 배열의 forEach 메서드는 배열만 사용이 가능하며 DOM 컬렉션 객체는 사용이 불가능합니다. 그 이유는 우리가 배열에서 사용하는 forEach 메서드가 Array.prototype의 프로퍼티를 상속받아 사용하고 있기 때문입니다. 따라서 비슷한 형태의 리스트 데이터지만 DOM 컬렉션 객체는 배열이 아니기 때문에 DOM을 조작하면서 기존의 배열의 문법들로 구현하는 것에는 한계가 있습니다.</p><p><code>NodeList는 forEach가 되는데요?</code></p><blockquote><p>NodeList도 기존에는 forEach 메서드를 사용한 순회가 불가능 했습니다. 하지만 사용성을 위해 Web API에 추가된 기능입니다. 따라서 NodeList의 forEach 메서드는 배열의 forEach 메서드와 같은 동작을 하는 다른 메서드입니다.</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/JavaScript/">JavaScript</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/es6/">es6</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B0%B0%EC%97%B4/">배열</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/HTMLCollection/">HTMLCollection</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/NodeList/">NodeList</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/08/17/js/23_nodelist_%EB%B0%B0%EC%97%B4%EB%A9%94%EC%84%9C%EB%93%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>패스트캠퍼스X야놀자 프론트엔드 개발 부트캠프_HTML/CSS 과제 리팩토링</title>
      <link>https://namgungjongmin.github.io/2023/08/08/fc-yanolja/html-css/</link>
      <guid>https://namgungjongmin.github.io/2023/08/08/fc-yanolja/html-css/</guid>
      <pubDate>Mon, 07 Aug 2023 15:12:35 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/yanolja/2023-07-10-23-14-24.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;과제를-진행하며-느낀점&quot;&gt;&lt;a href=&quot;#과제를-진행하며-느낀점&quot; class=&quot;headerlink&quot; title=&quot;과제를 진행하며 </description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/yanolja/2023-07-10-23-14-24.png"></p><h1 id="과제를-진행하며-느낀점"><a href="#과제를-진행하며-느낀점" class="headerlink" title="과제를 진행하며 느낀점"></a>과제를 진행하며 느낀점</h1><p>지금까지 배웠던 것들을 전부 사용해서 많은 것을 해보고 싶었는데 막상 구현에 들어가니 막히는 것이 많았다.<br>막힐 때마다 구글링을 통해 확인하고 여러 시행착오를 거치게 되고, 계획했던 그날의 계획들이 모조리 깨지는 것을 보면서 단순 강의를 보고 배우는 것과 실제로 내가 고민하고 코드를 작성하는 것이 얼마나 차이가 큰지 새삼 느끼게 되었다.</p><p>Sass를 사용하면서 mixin을 실제로 써보니 어떤 코드까지를 중복으로 판단해야 할지 몰라서 고민하며 시간을 보내기도 했고, html의 접근성을 공부하고 적용하기 위해 코드를 짤 때 항상 생각하고 작성했지만 실제 자동 감사 도구에서는 안좋은 점수를 맞기도 했다.</p><p>또한 sprite-image의 활용이나 기획에 기반한 style 작성 등 초기에 계획했던 것들과 실제 내가 행한 5일은 많은 차이가 있었다. sprite-image는 이해가 부족하여 충분히 활용하지 못했고, Media Query 같은 경우에도 처음 기획한 코드 구성과 거리가 너무 멀었다. 시간에 쫓기고 시행착오를 반복하다 보니 마음이 급해졌고, 코드 또한 기획가 달리 점점 난잡해져갔다.</p><p>의외로 시간을 많이 소모하게 된 것이 디렉터리 구조나 한&#x2F;영 font-face 구별과 같은 초기 세팅 관련한 부분이었는데, 처음엔 고생했지만, 다음 개발 시에는 훨씬 수월하게 할 수 있겠다는 자신감을 얻을 수 있었다.</p><p>결국 기획에서 중요한건 경험이고, 그것을 기반으로 좀더 현실적이고 완전하게 계획을 세워 코드 작성을 진행하는 것을 목표로 더욱 열심히 해나가야겠다.</p><h1 id="멘토님의-코드리뷰"><a href="#멘토님의-코드리뷰" class="headerlink" title="멘토님의 코드리뷰"></a>멘토님의 코드리뷰</h1><p>이번 개발에서 배웠던 기초에 더해 스스로 고민하고 찾아보면서 적용시킨 부분들이 있었다. 렌더링 성능에 대한 고민들이나 웹 접근성에서 스크린리더 사용자들을 최대한 고려한 코드를 작성한 것이 그것이다. 아직 초보자의 수박 겉핥기에 불과하겠지만, 멘토님은 그러한 고민을 한 것 자체에 대해 좋은 말씀을 해주셨다.</p><p>추가로 코드에서 개선할 점들을 짚어주셨다.</p><hr><h2 id="1-유지보수성을-생각하여-모달창의-마크업-위치를-변경"><a href="#1-유지보수성을-생각하여-모달창의-마크업-위치를-변경" class="headerlink" title="1) 유지보수성을 생각하여 모달창의 마크업 위치를 변경"></a>1) <strong>유지보수성</strong>을 생각하여 모달창의 마크업 위치를 변경</h2><p>페이지에 사용되는 공통 모달 배경은 추후 유지보수면에서 문서 상단에 위치시키면 추후 유지보수에 유리하다고 하셨다. 모달의 마크업을 쉽게 찾아갈 수 있을지에 대해 생각해본적이 없었는데 좋은 방향을 알게되었고, 바로 코드에 적용했다.</p><h2 id="2-중복되는-코드를-함수로-분리"><a href="#2-중복되는-코드를-함수로-분리" class="headerlink" title="2) 중복되는 코드를 함수로 분리"></a>2) <strong>중복되는 코드</strong>를 함수로 분리</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존 코드</span></span><br><span class="line">$prev.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (section2Order === <span class="number">0</span>) section2Order = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> section2Order = section2Order - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> innerWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line">  <span class="keyword">const</span> widthBase = innerWidth &lt; <span class="number">1200</span> ? <span class="variable language_">window</span>.<span class="property">innerWidth</span> : <span class="number">1200</span>;</span><br><span class="line">  <span class="keyword">const</span> moveWidth = widthBase === <span class="number">1200</span> ? <span class="string">`<span class="subst">$&#123;(section2Order * widthBase) / <span class="number">10</span>&#125;</span>rem`</span> : <span class="string">&#x27;100vw&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// console.log(section2Order, widthBase, moveWidth);</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.section2__container__flex&#x27;</span>).<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translate(-<span class="subst">$&#123;moveWidth&#125;</span>)`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$next.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (section2Order === <span class="number">6</span>) section2Order = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> section2Order = section2Order + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> innerWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line">  <span class="keyword">const</span> widthBase = innerWidth &lt; <span class="number">1200</span> ? <span class="variable language_">window</span>.<span class="property">innerWidth</span> : <span class="number">1200</span>;</span><br><span class="line">  <span class="keyword">const</span> moveWidth = widthBase === <span class="number">1200</span> ? <span class="string">`<span class="subst">$&#123;(section2Order * widthBase) / <span class="number">10</span>&#125;</span>rem`</span> : <span class="string">&#x27;100vw&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// console.log(section2Order, widthBase, moveWidth);</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.section2__container__flex&#x27;</span>).<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translate(-<span class="subst">$&#123;moveWidth&#125;</span>)`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>코드의 가독성이 나쁜 것도 짚어주셨는데 중복되는 코드들은 함수로 빼내어 관리하는 것을 권장하셨다. 기존 코드를 보면, 이벤트 리스너에서 코드가 반복되는 것을 볼 수 있는데, 이러한 경우 섹션이동 동작을 제어하는 함수로 분리하여 관리하고 함수가 어떻게 동작할지에 대한 값을 인수로 넘겨주게 만들었다. 실제로 반복되는 코드가 사라져 가독성이 높아졌고, 유지보수면에서 하나의 함수만을 수정하면 되기 때문에 훨씬 좋아보였다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 리팩토링 코드</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">moveSection</span> = increment =&gt; &#123;</span><br><span class="line">  section2Order = increment ? <span class="title class_">Math</span>.<span class="title function_">min</span>(section2Order + <span class="number">1</span>, <span class="number">6</span>) : <span class="title class_">Math</span>.<span class="title function_">max</span>(section2Order - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> innerWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line">  <span class="keyword">const</span> widthBase = innerWidth &lt; <span class="number">1200</span> ? innerWidth : <span class="number">1200</span>;</span><br><span class="line">  <span class="keyword">const</span> moveWidth = widthBase === <span class="number">1200</span> ? <span class="string">`<span class="subst">$&#123;(section2Order * widthBase) / <span class="number">10</span>&#125;</span>rem`</span> : <span class="string">&#x27;100vw&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.section2__container__flex&#x27;</span>).<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translate(-<span class="subst">$&#123;moveWidth&#125;</span>)`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$prev.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">moveSection</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$next.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">moveSection</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-웹성능을-최적화할-수-있는-코드를-작성"><a href="#3-웹성능을-최적화할-수-있는-코드를-작성" class="headerlink" title="3) 웹성능을 최적화할 수 있는 코드를 작성"></a>3) <strong>웹성능을 최적화</strong>할 수 있는 코드를 작성</h2><p>ascript에서 변수에 DOM요소를 할당할 때 내 코드에서는 querySelector를 사용했다. 하지만 멘토님께서는 성능상으로는 getElementById가 좋다고 하시며 페이지가 많아질 수록 성능 차이가 심해질 것이라고 하셨다. 당장 지금의 프로젝트에서는 페이지의 수가 한정되어 있기 때문에 큰 차이가 없으므로 리팩토링할 필요는 없지만 추후 프로젝트에서 웹성능을 감안한다면 querySelector보다는 id를 지정하여 getElementById를 사용하는 쪽으로 코드를 작성해야겠다.</p><p>사실 DOM요소를 불러오는 방법에 대해 처음 듣는 이야기는 아니었다. getElementById가 더 성능이 좋다는 것도 알고있었다. 그러나 querySelector가 보다 성능은 낮지만 jquery보다는 성능이 좋다는 것을 알고있었고, jquery로도 복잡한 사이트들을 현업에서 구현하는데 querySelector로 복잡하지 않게 그냥 통일해서 사용하면 안될까? 라는 마음이 있었던 것 같다.</p><p>그러나 확실히 웹성능 면에서 개선된 방식으로 코드를 작성하는 습관을 들이는 것이 좋다는 말씀에는 동의한다. 다음 프로젝트 개발시에는 id를 읽어오는 쪽으로 작성하겠다.</p><h1 id="Lighthouse"><a href="#Lighthouse" class="headerlink" title="Lighthouse"></a>Lighthouse</h1><p>Lighthouse를 통해 구현한 사이트를 검사해본 결과 예상 외로 웹 접근성 측면에서 기대보다 낮은 점수를 받았다. 솔직히 좀 충격이었다. 이번 과제에서 접근성을 지키기 위해 WCAG2.1을 읽고 accessibility hidden style이나 WAI-ARIA 등의 활용으로 스크린리더 환경까지 고려했기 때문이다.</p><p>그러나 예상치 못한 부분에서 접근성을 지키지 못한 경우들이 있었다. 바로 버튼이나 링크등에 이미지를 직접적으로 삽입하고 텍스트를 입력하지 않았을 때의 문제였다.</p><p>Lighthouse를 통해 알게 된 웹 접근성의 취약점들을 개선하려 노력했다. 추가로 성능 면에서도 내가 개선이 가능한 부분들을 찾아내어 수정했다.</p><h2 id="1-웹-접근성-취약점-개선"><a href="#1-웹-접근성-취약점-개선" class="headerlink" title="1) 웹 접근성 취약점 개선"></a>1) <strong>웹 접근성</strong> 취약점 개선</h2><p><img src="/images/yanolja/html-css/2023-08-28-23-00-44.png"></p><p>텍스트가 없는 버튼을 디자인적 요소로 활용하여 링크를 연결한 것에 대한 지적이 있었다. 스크린리더 사용자의 입장에서 이러한 디자인적인 요소를 파악할 수 없는데, 파악할 수 없는 요소에 중요한 링크가 걸려있으니 문제가 있었다. WCAG2.1에서 의도적으로 스크린리더 사용자에게 정보를 전달하는 기능인 aria-label 속성을 확인하고 적용하였다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aria-label 적용</span></span><br><span class="line">&lt;a href=<span class="string">&quot;/&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;content-box-arrow&quot;</span> aria-label=<span class="string">&quot;해당 페이지로 이동&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa-solid fa-arrow-right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aria-label 적용</span></span><br><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;carousel-btns&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;carousel-btns-item active&quot;</span> <span class="attr">data-num</span>=<span class="string">&quot;1&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;첫 번째 이미지로 이동&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;carousel-btns-item&quot;</span> <span class="attr">data-num</span>=<span class="string">&quot;2&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;두 번째 이미지로 이동&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;carousel-btns-item&quot;</span> <span class="attr">data-num</span>=<span class="string">&quot;3&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;세 번째 이미지로 이동&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="2-웹-성능-개선"><a href="#2-웹-성능-개선" class="headerlink" title="2) 웹 성능 개선"></a>2) <strong>웹 성능</strong> 개선</h2><p>사이트에서 애니메이션과 이미지들이 많이 사용되다 보니 성능적으로 많이 낮은 점수가 나오는 것 같았다. 우선적으로 코드 등의 수정 보다는 이미지 파일 자체의 크기들을 낮추는 것에 집중하였다.</p><p>이미지 최적화 프로그램을 통해 각 이미지들의 크기를 30% ~ 50% 낮춰주었고 유의미한 검사 결과의 차이를 얻었다. 추가로 Lazy Loding과 CDN을 활용한 이미지 최적화 방법들을 알게 되었는데 추후에 웹성능 개선을 위한 이미지 최적화 방식에 대해 제대로 알아보고 활용할 수 있게 하겠다고 다짐했다.</p><h2 id="Lighthouse-점수-변화"><a href="#Lighthouse-점수-변화" class="headerlink" title="Lighthouse 점수 변화"></a>Lighthouse 점수 변화</h2><p><img src="/images/yanolja/html-css/2023-08-28-23-09-41.png"></p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/%EC%95%BC%EB%86%80%EC%9E%90-%ED%85%8C%ED%81%AC%EC%8A%A4%EC%BF%A8/">야놀자 테크스쿨</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90%EC%B7%A8%EC%97%85/">국비지원취업</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4/">패스트캠퍼스</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84/">부트캠프</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C%EC%9E%90/">프론트엔드개발자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B5%AD%EB%B9%84%EC%A7%80%EC%9B%90/">국비지원</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/">리팩토링</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/08/08/fc-yanolja/html-css/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>프로토타입을 활용한 객체 지향 프로그래밍</title>
      <link>https://namgungjongmin.github.io/2023/08/01/js/14_%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</link>
      <guid>https://namgungjongmin.github.io/2023/08/01/js/14_%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</guid>
      <pubDate>Tue, 01 Aug 2023 12:42:31 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/3e2bea4f-7465-4e21-a3e6-9992d35bfbbb/image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트는 명령형, 함수형, 객체 지향 프로그</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/3e2bea4f-7465-4e21-a3e6-9992d35bfbbb/image.png"></p><p>자바스크립트는 명령형, 함수형, 객체 지향 프로그래밍을 지원하는 ‘멀티 패러다임’ 프로그래밍 언어입니다. 다른 클래스 기반 객체 지향 프로그래밍과는 달리 프로토타입 기반의 객체 지향 프로그래밍을 구현합니다.</p><p><code>자바스크립트도 클래스가 있는데 왜 클래스 기반의 객체 지향 프로그래밍이라 칭하지 않는가?</code></p><blockquote><p>ES6에 도입된 자바스크립트의 클래스는 함수이다. 따라서 생성자 함수와 동일하게 프로토타입 기반의 인스턴스를 생성한다. 기존 프로토타입 기반의 객체 지향을 구현하는 방식을 폐지하고 새로운 객체 지향 모델을 제공하는 것이 아니라 단지 기존 방식을 기존 클래스 문법 형태에 맞춘 ‘문법적 설탕’이라고 볼 수 있다.</p></blockquote><hr><h1 id="객체-지향-프로그래밍이란"><a href="#객체-지향-프로그래밍이란" class="headerlink" title="객체 지향 프로그래밍이란?"></a>객체 지향 프로그래밍이란?</h1><p>객체 지향 프로그래밍은 전통적 명령형 프로그래밍 방식의 <strong>‘절차지향적’</strong> 관점에서 벗어나 객체의 집합으로 프로그램을 표현하려는 방식입니다. 객체 지향 프로그래밍은 실세계의 실체(사물이나 개념)을 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작합니다. 실체는 특징이나 속성을 가지고 있고 이를 통해 실제를 인식하거나 구별할 수 있습니다.</p><p>예를 들어, 사람은 이름, 나이, 키, 체중, 직업, 학력 등 다양한 속성을 갖습니다. 우리는 속성을 통해 특정한 사람을 다른 사람과 구별하여 인식할 수 있습니다. 이러한 방식을 프로그래밍에 적용해보겠습니다. 만약 어떠한 사람의 이름과 나이, 직업에만 관심이 있다면 해당 속성만을 간추려내어 표현할 수 있습니다. 이것을 <strong>추상화</strong> 라고 합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;namgung jong min&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">  <span class="attr">job</span>: baeksu,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>개발자는 이름과 나이, 직업 속성으로 위 객체를 다른 객체와 구별하여 인식할 수 있습니다. 이처럼 속성을 통해 여러 값을 하나의 단위로 구성한 복합적 자료구조를 객체라고 합니다. 즉 객체 지향 프로그래밍은 독립적인 각 객체들의 그룹을 활용해 프로그래밍을 하는 방식입니다.</p><h1 id="상태와-동작을-나타내는-객체"><a href="#상태와-동작을-나타내는-객체" class="headerlink" title="상태와 동작을 나타내는 객체"></a>상태와 동작을 나타내는 객체</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circle = &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getDiameter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="variable language_">this</span>.<span class="property">radius</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getPerimeter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="variable language_">this</span>.<span class="property">radius</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>원이라는 개념을 객체로 만들어보았습니다. 원에는 반지름이라는 속성이 있습니다. 이 속성을 활용하여 지름과 둘레를 구할 수 있습니다. 이 때 반지름은 원의 상태를 나타내는 데이터이며, 원의 지름과 둘레를 구하는 것은 동작입니다.</p><p>이처럼 객체 지향 프로그래밍은 객체의 상태를 나타내는 데이터와 동작을 나타내는 데이터를 묶어서 생각합니다. 따라서 객체는 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조라고 할 수 있습니다.</p><hr><h1 id="프로토타입을-이용해-상속을-구현"><a href="#프로토타입을-이용해-상속을-구현" class="headerlink" title="프로토타입을 이용해 상속을 구현"></a>프로토타입을 이용해 상속을 구현</h1><p>상속은 객체 지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말합니다. 자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거합니다. 중복을 제거하는 것은 개발 비용을 줄일 수 있는 방법이기 때문에 중요합니다.</p><p>다음 생성자 함수를 살펴보겠습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getArea</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="variable language_">this</span>.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle1.<span class="property">getArea</span> === circle2.<span class="property">getArea</span>); <span class="comment">// output: false</span></span><br></pre></td></tr></table></figure><p>위에서 Circle 생성자 함수는 인스턴스를 생성할 때마다 동일한 동작을 하는 getArea 메서드를 중복 생성하며 모든 인스턴스가 중복 소유합니다. getArea 메서드는 Circle 생성자 함수만이 소유하며 생성된 인스턴스들은 해당 메서드를 공유하여 사용하는 것이 바람직합니다.</p><p>생성자 함수에 의해 생성된 모든 인스턴스가 동일한 메서드를 중복 소유하는 것은 메모리를 불필요하게 낭비합니다. 이번엔 상속을 통해 불필요한 중복을 제거해 보겠습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Circle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getArea</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="variable language_">this</span>.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle1.<span class="property">getArea</span> === circle2.<span class="property">getArea</span>); <span class="comment">// output: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드에서 생성한 인스턴스가 getArea 메서드를 공유해서 사용할 수 있도록 프로토타입에 추가했습니다. 모든 인스턴스들은 자신의 프로토타입, 즉 상위 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메서드를 상속받습니다. 즉 자신의 상태를 나타내는 radius 프로퍼티만 개별적으로 소유하고 내용이 동일한 메서드는 상속을 통해 공유하여 사용하는 것입니다.</p><hr><h1 id="생성자-함수-x2F-프로토타입-x2F-인스턴스의-관계"><a href="#생성자-함수-x2F-프로토타입-x2F-인스턴스의-관계" class="headerlink" title="생성자 함수 &#x2F; 프로토타입 &#x2F; 인스턴스의 관계"></a>생성자 함수 &#x2F; 프로토타입 &#x2F; 인스턴스의 관계</h1><p>프로토타입의 내부 동작을 이해하기 위해서 도표를 통해 생성자 함수와 프로토타입, 그리고 인스턴스의 관계를 살펴보겠습니다. 그 전에 내용의 이해를 위해 용어를 정리하고 가는 것이 필요합니다.</p><h2 id="프로토타입-객체-프로토타입"><a href="#프로토타입-객체-프로토타입" class="headerlink" title="프로토타입 객체 (프로토타입)"></a>프로토타입 객체 (프로토타입)</h2><p>프로토타입 객체는 상속을 구현하기 위해 사용됩니다. 프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체로서 다른 객체의 공유 프로퍼티를 제공합니다. 상위 객체의 프로퍼티를 공유받은 하위 객체는 상위 객체의 프로퍼티를 자유롭게 사용할 수 있습니다.</p><h2 id="프로토타입-내부-슬롯-Prototype"><a href="#프로토타입-내부-슬롯-Prototype" class="headerlink" title="프로토타입 내부 슬롯 ([[Prototype]])"></a>프로토타입 내부 슬롯 ([[Prototype]])</h2><p>모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값은 프로토타입의 참조입니다. 어떤 프로토타입이 저장될지는 객체 생성 방식에 의해 결정됩니다. 즉 객체 생성 방식에 따라 프로토타입이 결정되고 [[Prototype]]에 저장됩니다.</p><h2 id="proto-접근자-프로퍼티"><a href="#proto-접근자-프로퍼티" class="headerlink" title="__proto__ 접근자 프로퍼티"></a>__proto__ 접근자 프로퍼티</h2><p>모든 객체는 __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있습니다. 이 때 __proto__ 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아닙니다. __proto__접근자 프로퍼티는 프로토타입이 소유하며 인스턴스는 해당 프로퍼티를 상속을 통해 사용합니다.</p><p>프로토타입에 접근하기 위한 __proto__를 인스턴스가 아닌 프로토타입이 소유하는 이유는 단방향의 체인을 구성하기 위함입니다. 프로토타입 체인 상의 각 객체들은 __proto__ 접근자 프로퍼티를 상위 객체에서 상속받아 사용하며 이를 통해 프로토타입 체인을 구축합니다.</p><p>중요한 것은 객체의 프로퍼티 자체에 접근하는 것이 아니라 반드시 __proto__를 통해서만 객체에 접근하여 프로퍼티를 검색한다는 점입니다. 프로토타입 객체에 개발자가 직접 관여하는 것은 상호 참조의 비정상적인 체인 형성에 대한 위험이 있습니다. 이는 프로토타입이 순환 참조의 체인을 형성하여 무한루프에 빠질 수 있기 때문에 프로토타입 체인은 반드시 단방향 링크드 리스트로 구현되어야 합니다.</p><p>따라서 자바스크립트는 체크없이 객체에 직접 접근하여 프로토타입을 교체할 수 없도록 __proto__ 접근자 프로퍼티를 통해서만 프로토타입 객체에 접근할 수 있도록 구현되어 있습니다.</p><h2 id="프로토타입-프로퍼티"><a href="#프로토타입-프로퍼티" class="headerlink" title="프로토타입 프로퍼티"></a>프로토타입 프로퍼티</h2><p>프로토타입 프로퍼티는 함수 객체만이 소유하는 프로퍼티로 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킵니다. 따라서 prototype 프로퍼티는 생성자 함수로서 호출할 수 없는 함수, 즉 non-constructor인 화살표 함수와 ES6 메서드 축약 표현으로 정의한 메서드에서 존재하지 않습니다.</p><hr><h2 id="생성자-함수로-인스턴스-생성-시-프로토타입"><a href="#생성자-함수로-인스턴스-생성-시-프로토타입" class="headerlink" title="생성자 함수로 인스턴스 생성 시 프로토타입"></a>생성자 함수로 인스턴스 생성 시 프로토타입</h2><p>생성자 함수를 new 키워드를 통해 호출하면 [[Construct]] 내부 메서드가 호출되며 인스턴스가 생성됩니다. 이 때 생성자 함수가 생성될 때 함께 생성된 프로토타입과 인스턴스가 연결됩니다.</p><p>생성자 함수가 생성한 인스턴스는 생성자 함수의 프로토타입 프로퍼티에 저장된 프로토타입을 상속받습니다. 인스턴스 입장에서 __proto__ 접근자 프로퍼티를 통해 프로토타입에 접근할 수 있습니다.</p><p>모든 프로토타입은 constructor 프로퍼티를 갖습니다. 이 constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킵니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/23d30346-5f0d-479f-8daf-737bd8e706aa/image.png"></p><h2 id="리터럴로-생성한-객체의-생성자함수와-프로토타입"><a href="#리터럴로-생성한-객체의-생성자함수와-프로토타입" class="headerlink" title="리터럴로 생성한 객체의 생성자함수와 프로토타입"></a>리터럴로 생성한 객체의 생성자함수와 프로토타입</h2><p>위에서 살펴본 것과 같이 생성자 함수로 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결됩니다. 이 때 constructor 프로퍼티가 가리키는 생성자 함수는 인스턴스를 생성한 함수입니다.</p><p>그렇다면 리터럴 표기법에 의해 생성된 객체의 constructor 프로퍼티가 가리키는 대상은 무엇일까요? 리터럴 표기법에 의해 생성된 객체의 경우 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수는 아닙니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">// output: true</span></span><br><span class="line"></span><br><span class="line">cosnt obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">// output: true</span></span><br></pre></td></tr></table></figure><p>위 코드에서 obj2는 Object 생성자 함수로 생성된 것이 아닙니다. 그러나 constructor 프로퍼티는 Object를 가리킵니다. 그렇다면 사실 객체 리터럴로 생선한 객체도 내부적으로는 Object 생성자 함수를 사용하여 생성되는 것은 아닐까요?</p><p>ECMA Script 사양서에는 객체 리터럴이 평가될 때 추상 연산을 호출하여 빈 객체를 생성하고 프로퍼티를 추가하도록 정의되어있습니다. 그러나 Object 생성자 함수의 경우 undefined나 null을 인수로 전달하면서 호출할 때에만 추상 연산을 호출하여 객체를 생성합니다.</p><p>따라서 객체 리터럴에 의해 생성된 객체는 Object 생성자 함수가 생성한 객체가 아닙니다.</p><p>함수또한 마찬가지인데 함수 선언식으로 생성된 함수 객체는 Function 생성자 함수가 아니지만 객체의 프로토타입의 constructor 프로퍼티는 Function을 가리킵니다.</p><hr><p>생성자 함수가 아닌 리터럴 표기법에 의해 생성된 객체도 상속을 위해서는 프로토타입이 반드시 필요합니다. 따라서 자바스크립트는 리터럴 표기법으로 생성된 객체에도 가상적인 생성자 함수를 부여합니다. 프로토타입은 생성자 함수와 더불어 생성되며 prototype, constructor 프로퍼티에 의해 연결되어있기 때문입니다.</p><h1 id="프로토타입-체인"><a href="#프로토타입-체인" class="headerlink" title="프로토타입 체인"></a>프로토타입 체인</h1><p>자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색합니다. 이를 프로토타입 체인이라고 합니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/1375b18a-863f-48a3-9722-107ee34cf24f/image.png"></p><p>자바스크립트 엔진은 프로토타입 체인을 따라 프로퍼티와 메서드를 검색합니다. 즉 자바스크립트 엔진은 객체 간의 상속 관계로 이루어진 프로토타입의 계층적인 구조에서 객체의 프로퍼티를 검색하며 프로토타입 체인을 한마디로 말하자면 상속과 검색을 위한 매커니즘이라고 할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/JavaScript/">JavaScript</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/es6/">es6</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/">프로토타입</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">객체지향프로그래밍</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/08/01/js/14_%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>전역 변수의 문제점과 해결 방안</title>
      <link>https://namgungjongmin.github.io/2023/07/20/js/7_%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98%20%EB%AC%B8%EC%A0%9C%EC%A0%90/</link>
      <guid>https://namgungjongmin.github.io/2023/07/20/js/7_%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98%20%EB%AC%B8%EC%A0%9C%EC%A0%90/</guid>
      <pubDate>Thu, 20 Jul 2023 14:41:21 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/3e2bea4f-7465-4e21-a3e6-9992d35bfbbb/image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;전역 변수의 사용은 위험합니다. 따라서 반드시 전</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/3e2bea4f-7465-4e21-a3e6-9992d35bfbbb/image.png"></p><p>전역 변수의 사용은 위험합니다. 따라서 반드시 전역 변수를 사용해야 할 이유가 있는 것이 아니라면 지역 변수를 사용해야 합니다. 이번 주제에서 전역 변수의 사용이 왜 위험하며, 그러면 어떠한 방식으로 전역 변수의 사용을 최소화할 수 있는지 알아보겠습니다.</p><hr><h1 id="변수의-생명-주기"><a href="#변수의-생명-주기" class="headerlink" title="변수의 생명 주기"></a>변수의 생명 주기</h1><p>변수는 선언에 의해 생성되고 할당을 통해 값을 갖게 됩니다. 그리고 언젠가 소멸합니다. 즉 생물과 유사한, 생성되고 소멸되는 생명 주기가 있습니다. 전역 변수의 문제점을 알아보기에 앞서 내용의 이해와 공감을 위해 지역 변수와의 생명 주기를 비교해보겠습니다.</p><h1 id="지역-변수의-생명-주기"><a href="#지역-변수의-생명-주기" class="headerlink" title="지역 변수의 생명 주기"></a>지역 변수의 생명 주기</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  ---------------------------------- ①</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">&#x27;local&#x27;</span>; ----------------- ②</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">//output: &#x27;local&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">  ---------------------------------- ③</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// Reference Error</span></span><br></pre></td></tr></table></figure><p>지역 변수 x는 함수가 호출되기 이전까지는 생성되지 않습니다. foo 함수를 호출하지 않으면 함수 내부의 변수 선언문이 실행되지 않기 때문입니다. 변수 x의 선언은 함수가 호출되어 함수 몸체의 코드가 한 줄씩 실행되기 직전에 자바스크립트 엔진에 의해 실행됩니다.</p><p>위 코드의 경우 ①에서 x 변수가 선언되고 undefined로 초기화됩니다. 이후 함수 몸체를 구성하는 문들이 순차적으로 실행되면서 ②에서 변수에 값이 할당 됩니다. 그리고 함수 몸체의 모든 코드를 실행하고 (③) 함수가 종료되면 x 변수도 소멸되어 생명 주기가 종료됩니다.</p><p>따라서 함수 내부에서 선언된 지역 변수 x는 함수가 호출되어 실행되는 동안에만 유효하고 이는 지역 변수의 생명 주기가 함수의 생명 주기와 일치한다는 것을 말해줍니다.</p><p>또한 지역 변수의 선언은 스코프 단위로 동작하게 됩니다. 이는 각 함수가 실행되는 시점의 지역 변수의 식별자 이름이 같다 하더라도 서로를 간섭하지 않는다는 것을 의미합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;global&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">&quot;local&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">//output: &#x27;local&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">&quot;local2&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">//output: &#x27;local2&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">bar</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// Reference Error</span></span><br></pre></td></tr></table></figure><h1 id="전역-변수의-생명-주기"><a href="#전역-변수의-생명-주기" class="headerlink" title="전역 변수의 생명 주기"></a>전역 변수의 생명 주기</h1><p>함수와 달리 전역 코드는 명시적인 호출 없이 실행됩니다. 즉 전역 코드는 어떠한 진입점이 없고 코드가 로드되자마자 곧바로 해석되고 실행됩니다. 함수가 함수 몸체의 모든 문이 실행되거나 반환문이 실행 되면 종료되는 것에 반해 전역 코드는 자바스크립트의 모든 코드가 실행되어 더 이상 실행할 문이 없을 때 종료됩니다.</p><p>var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 됩니다. 이는 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치한다는 것을 말합니다. 또한 let과 const 키워드로 선언한 전역 변수가 저장된 렉시컬 환경이 전역 객체와 연결되어 있기 때문에 마찬가지로 전역 객체와 생명 주기가 같습니다.</p><p>브라우저 환경에서 전역 객체는 window이므로 전역 변수는 웹페이지를 닫을 때까지 유효합니다.</p><hr><h1 id="전역-변수의-문제점"><a href="#전역-변수의-문제점" class="headerlink" title="전역 변수의 문제점"></a>전역 변수의 문제점</h1><h2 id="암묵적-결합"><a href="#암묵적-결합" class="headerlink" title="암묵적 결합"></a>암묵적 결합</h2><p>전역 변수를 선언한 의도는 ‘코드 어디서든 참조하고 할당할 수 있는 변수를 사용하겠다.’ 라는 것입니다. 이는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 <strong>암묵적 결합</strong> 을 허용하는 것입니다. 변수의 유효 범위가 크면 클 수록 코드의 가독성은 나빠지고 의도치 않은 변수의 접근이나 변경이 일어날 위험성도 증가합니다.</p><h2 id="메모리-리소스의-증가"><a href="#메모리-리소스의-증가" class="headerlink" title="메모리 리소스의 증가"></a>메모리 리소스의 증가</h2><p>전역 변수는 생명주기가 깁니다. 웹페이지가 종료될 때까지 전역 변수의 정보를 메모리에 저장해두어야 합니다.</p><h2 id="느린-참조-속도"><a href="#느린-참조-속도" class="headerlink" title="느린 참조 속도"></a>느린 참조 속도</h2><p>자바스크립트는 식별자를 검색할 때 현재 실행중인 실행 컨텍스트 스택의 렉시컬 환경에서 상위 컨텍스트의 렉시컬 환경으로 스코프 체인을 따라 검색을 실행합니다. 따라서 전역 변수는 스코프 체인 상의 종점에 존재하기 때문에 변수를 참조하기 위한 검색 속도가 가장 느립니다.</p><h2 id="네임스페이스-오염"><a href="#네임스페이스-오염" class="headerlink" title="네임스페이스 오염"></a>네임스페이스 오염</h2><p>자바스크립트는 파일이 분리되어 있다 하더라도 전역 스코프를 공유합니다. 따라서 스크립트 파일들의 규모가 커지면 커질 수록 다른 파일들 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 위험이 있으며, 이로 인한 의도치 않은 결과를 가져올 수 있습니다.</p><h2 id="Injection-공격에-취약"><a href="#Injection-공격에-취약" class="headerlink" title="Injection 공격에 취약"></a>Injection 공격에 취약</h2><p>앞서 전역 변수의 생명 주기의 설명에서 전역 변수는 웹페이지를 닫을 때까지 유효하다고 했습니다. 이것은 웹페이지 내에서 여러 변수에 접근이 가능하다는 위험성을 내포합니다. 즉 XXS와 같은 Injection 공격에 취약합니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/ef0b07bd-318f-4413-acfd-804cf1aaba12/image.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;testForm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>결과 보기<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: 5px solid red; height: 40px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> $form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;testForm&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> $textArea = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> $result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;result&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> secretKey = <span class="string">&quot;abcd1234ImportantKey&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  $form.<span class="title function_">addEventListener</span>(<span class="string">&quot;submit&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    e.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">    $result.<span class="property">innerHTML</span> = e.<span class="property">target</span>.<span class="property">test</span>.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>위 예시는 XXS 공격을 통해 자바스크립트 변수에 액세스하는 상황을 구현해본 것입니다. 이처럼 전역 변수는 웹페이지가 닫힐 때까지 유효하기 때문에 중요한 정보를 저장해둔다면 여러 스크립트 공격에 의해 정보가 탈취될 수 있습니다.</p><hr><h1 id="전역-변수의-사용을-억제하는-방법"><a href="#전역-변수의-사용을-억제하는-방법" class="headerlink" title="전역 변수의 사용을 억제하는 방법"></a>전역 변수의 사용을 억제하는 방법</h1><p>앞서 말한 내용들을 통해 전역 변수의 사용을 지양해야 된다는 것을 확인해보았습니다. 전역 변수를 반드시 사용해야 할 이유가 없다면 지역 변수를 사용해야 합니다. 변수의 스코프는 좁을 수록 좋습니다. 전역 변수의 사용을 억제하고 생명 주기를 짧게 가져가는 몇 가지 방법에 대해 알아보겠습니다.</p><h2 id="즉시-실행-함수"><a href="#즉시-실행-함수" class="headerlink" title="즉시 실행 함수"></a>즉시 실행 함수</h2><p>즉시 실행 함수는 함수 정의와 동시에 런타임 내 단 한번만 호출되는 함수입니다. 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> foo = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// ... 생략</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>이 방법을 사용하면 추가적인 스크립트의 스코프를 전역 스코프에서 분리할 수 있습니다. 따라서 여러 스크립트 간 식별자의 충돌을 피하기 위해 라이브러리 등에서 자주 사용됩니다.</p><h2 id="모듈-패턴"><a href="#모듈-패턴" class="headerlink" title="모듈 패턴"></a>모듈 패턴</h2><p>모듈 패턴은 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만듭니다. 모듈 패턴은 클로저를 기반으로 동작합니다.</p><p>모듈 패턴을 사용하면 전역 변수의 사용을 억제할뿐만 아니라 캡슐화까지 구현할 수 있습니다. 캡슐화를 통해 코드 내에서 변수에 접근하는 것 자체를 차단할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> $counter = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.counter&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">increase</span>(<span class="params"></span>) &#123;</span><br><span class="line">      count += <span class="number">1</span>;</span><br><span class="line">      $counter.<span class="property">textContent</span> = count;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">decrease</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">0</span>) count -= <span class="number">1</span>;</span><br><span class="line">      $counter.<span class="property">textContent</span> = count;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.increase&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, counter.<span class="property">increase</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.decrease&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, counter.<span class="property">decrease</span>);</span><br></pre></td></tr></table></figure><h2 id="ES6-모듈"><a href="#ES6-모듈" class="headerlink" title="ES6 모듈"></a>ES6 모듈</h2><p>ES6 모듈을 사용하면 더는 전역 변수를 사용할 수 없습니다. ES6모듈은 파일 자체의 독자적인 모듈 스코프를 제공합니다. 따라서 모듈 내에서 선언한 변수들은 더 이상 전역 변수가 아니며 window 객체의 프로퍼티도 아닙니다.</p><p>모던 브라우저에서 ES6 모듈을 사용할 수 있는데 script 태그에 type&#x3D;”module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작합니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;app.mjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;lib.mjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/JavaScript/">JavaScript</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/es6/">es6</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98/">전역변수</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/07/20/js/7_%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98%20%EB%AC%B8%EC%A0%9C%EC%A0%90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>논리연산자를 활용한 단축 평가</title>
      <link>https://namgungjongmin.github.io/2023/07/18/js/6_%EB%85%BC%EB%A6%AC%EC%97%B0%EC%82%B0%EC%9E%90_%EB%8B%A8%EC%B6%95%ED%8F%89%EA%B0%80/</link>
      <guid>https://namgungjongmin.github.io/2023/07/18/js/6_%EB%85%BC%EB%A6%AC%EC%97%B0%EC%82%B0%EC%9E%90_%EB%8B%A8%EC%B6%95%ED%8F%89%EA%B0%80/</guid>
      <pubDate>Tue, 18 Jul 2023 04:01:50 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/3e2bea4f-7465-4e21-a3e6-9992d35bfbbb/image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;논리합-x2F-논리곱-연산자&quot;&gt;&lt;a hr</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/3e2bea4f-7465-4e21-a3e6-9992d35bfbbb/image.png"></p><h1 id="논리합-x2F-논리곱-연산자"><a href="#논리합-x2F-논리곱-연산자" class="headerlink" title="논리합 &#x2F; 논리곱 연산자"></a>논리합 &#x2F; 논리곱 연산자</h1><p>우리는 학창 시절 집합을 배우면서 합집합과 교집합을 통해 논리합과 논리곱에 대한 감을 잡았고, 이후 이산 수학을 통해 두 명제에 대한 논리 연산으로 이해를 확장시켰습니다.</p><ul><li><p>논리합 (A or B)<br>A와 B의 각 명제 중 하나라도 ‘참’일 경우 두 명제의 논리합은 ‘참’이 된다.<br>(두 명제 모두 ‘거짓’일 때만 논리합이 ‘거짓’이 된다.)</p></li><li><p>논리곱 (A and B)<br>A와 B의 각 명제가 모두 ‘참’일 때만 논리곱은 ‘참’이 된다.<br>(두 명제 중 하나라도 ‘거짓’일 경우 논리곱은 ‘거짓’이 된다.)</p></li></ul><p>자바스크립트의 논리 연산도 동일한 원리로 동작합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testTrue = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> testFalse = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(testTrue || testFalse); <span class="comment">// output: true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(testTrue &amp;&amp; testFalse); <span class="comment">// output: false</span></span><br></pre></td></tr></table></figure><hr><h1 id="논리합-x2F-논리곱을-사용한-단축-평가"><a href="#논리합-x2F-논리곱을-사용한-단축-평가" class="headerlink" title="논리합 &#x2F; 논리곱을 사용한 단축 평가"></a>논리합 &#x2F; 논리곱을 사용한 단축 평가</h1><p>자바스크립트 동작에서 우리가 주목할 특징은 <strong>“논리 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로만 평가된다.”</strong> 라는 점입니다. 그리고 논리 연산의 결과를 결정한 대상을 타입 변환없이 그대로 반환하게 됩니다.</p><p>이 때 평가의 결과가 확정되었다면, 나머지 평가 과정을 생략하게 되는데 이를 <strong>단축평가</strong> 라고 합니다.</p><h2 id="논리합-연산자의-평가-대상-A-B"><a href="#논리합-연산자의-평가-대상-A-B" class="headerlink" title="논리합 연산자의 평가 대상 (A || B)"></a>논리합 연산자의 평가 대상 (A || B)</h2><p>논리합 연산자는 두 피연사자 중 하나만 true여도 true를 반환합니다. 따라서 앞의 항 A의 값이 true라면 위에 말한 단축 평가의 동작 원리대로 나머지 평가 과정을 멈추고 A를 평가한 값을 그대로 반환하게 됩니다.<br><code>반환 결과: 평가된 A</code></p><p>만약 A의 값이 false라면 논리합의 결과를 알기 위해서는 B의 값을 평가해야 합니다. B가 false라면 false를 반환, B가 true라면 true를 반환하게 됩니다. 즉 논리 연산의 결과는 B의 값에 따라 결정됩니다.<br><code>반환 결과: 평가된 B</code></p><p>이를 활용하여 저희는 A의 평가 결과를 조건으로 반환 대상을 결정하는 코드를 if else문을 대체하여 표현식으로 사용할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react</span></span><br><span class="line">&#123;</span><br><span class="line">  !dirty || error ? <span class="language-xml"><span class="tag">&lt;<span class="name">small</span>&gt;</span>&#x27;Error&#x27;<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span> : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 dirty의 값이 ‘참’일 때만 error 여부를 판별하여 error가 ‘참’일 경우 ‘Error’ 문자열을 렌더링하는 코드입니다. dirty의 값이 ‘거짓’일 경우 error 여부와 관계없이 ‘Error’ 문자열을 렌더링합니다.</p><h3 id="null-병합-연산자-A-B"><a href="#null-병합-연산자-A-B" class="headerlink" title="*null 병합 연산자 (A ?? B)"></a>*null 병합 연산자 (A ?? B)</h3><p>논리합 연산자를 사용할 때 주의할 점은 연산자가 각 피연산자의 Truthy &#x2F; Falsy 값을 판단한다는 점입니다. 위 논리합 연산자의 예시에서 dirty값이 string 데이터 타입이라고 가정해봅시다.</p><p><strong>개발자가 빈 문자열 또한 dirty 값이 있다고 가정</strong> 한다해도 빈 문자열 ‘’은 Falsy 값으로 판단되어 자바스크립트는 B를 평가하게 됩니다. 이것은 개발자의 의도대로 동작한 것이 아닙니다.</p><p>Truty &#x2F; Falsy 값을 판별하는게 아니라 값 자체가 할당되지 않았거나(undefined) 명시적으로 빈 값이라고 표현된 요소(null)를 판단하고 싶다면 <strong>null 병합 연산자</strong> 를 사용할 수 있습니다. null 병합 연산자를 사용하면 피연산자가 null 또는 undefined인지 여부만을 판단하게 됩니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react</span></span><br><span class="line">&#123;</span><br><span class="line">  !dirty ?? error ? <span class="language-xml"><span class="tag">&lt;<span class="name">small</span>&gt;</span>&#x27;Error&#x27;<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span> : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="논리곱-연산자의-평가-대상-A-amp-amp-B"><a href="#논리곱-연산자의-평가-대상-A-amp-amp-B" class="headerlink" title="논리곱 연산자의 평가 대상 (A &amp;&amp; B)"></a>논리곱 연산자의 평가 대상 (A &amp;&amp; B)</h2><p>논리곱 연산자는 두 피연산자가 모두 true일 경우만 true를 반환합니다. 따라서 앞의 항의 값이 false라면 위에 말한 단축 평가의 동작 원리대로 나머지 평가 과정을 멈추고 A를 평가한 값을 그대로 반환하게 됩니다.<br><code>반환 결과: 평가된 A</code></p><p>만약 A의 값이 true라면 논리곱 연산자의 결과를 알기 위해서는 B의 값을 평가해야 합니다. B가 true라면 true를 반환 B가 false라면 false를 반환하게 됩니다. 즉 논리 연산의 결과는 B의 값에 따라 결정됩니다.<br><code>반환 결과: 평가된 B</code></p><p>논리합 연산자와 마찬가지로 A의 평가 결과를 조건으로 반환 대상을 결정하는 코드를 if else문을 대체하여 표현식으로 사용할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react</span></span><br><span class="line"><span class="comment">// dirty 값이 &#x27;참&#x27;일 경우에만 remove 버튼을 렌더링</span></span><br><span class="line">&#123;</span><br><span class="line">  dirty &amp;&amp; (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">className</span>=<span class="string">&#123;styles.removeBtn&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;resetEmail&#125;</span> <span class="attr">tabIndex</span>=<span class="string">&#123;-1&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">InputRemove</span> <span class="attr">className</span>=<span class="string">&#123;styles.removeBtn__icon&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="옵셔널-체이닝-연산자"><a href="#옵셔널-체이닝-연산자" class="headerlink" title="옵셔널 체이닝 연산자"></a>옵셔널 체이닝 연산자</h1><p>옵셔널 체이닝 연산자는 자바스크립트의 메서드 체이닝 여부를 대상 객체의 평가 결과에 따라 결정할 수 있는 방법입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react</span></span><br><span class="line"><span class="keyword">const</span> data = axios.<span class="title function_">get</span>(<span class="string">&#x27;http://test/posts.com&#x27;</span>) <span class="comment">// [element1,element2,...]</span></span><br><span class="line"><span class="comment">// ... 생략</span></span><br><span class="line">&#123;data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>)=&gt;</span> ...)&#125;</span><br></pre></td></tr></table></figure><p>위 코드의 경우 만약 http 요청으로 받아온 data의 값이 없을 경우 에러를 출력하여 페이지 렌더링이 불가능합니다. 만약 data가 있을 경우 해당 요소를 렌더링하고, 없다면 저 부분만을 제외한 상태로 정상적인 렌더링을 하기 위해 옵셔널 체이닝 연산자를 활용할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react</span></span><br><span class="line"><span class="keyword">const</span> data = axios.<span class="title function_">get</span>(<span class="string">&#x27;http://test/posts.com&#x27;</span>) <span class="comment">// null / undefined</span></span><br><span class="line"><span class="comment">// ... 생략</span></span><br><span class="line">&#123;data?.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>)=&gt;</span> ...)&#125;</span><br></pre></td></tr></table></figure><p>옵셔널 체이닝 연산자를 사용하면 data의 값이 null이나 undefined인 경우에는 forEach 메서드를 실행하지 않고, 평가를 종료합니다.</p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/JavaScript/">JavaScript</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/es6/">es6</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%85%BC%EB%A6%AC%EC%97%B0%EC%82%B0%EC%9E%90/">논리연산자</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/%EB%8B%A8%EC%B6%95%ED%8F%89%EA%B0%80/">단축평가</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/07/18/js/6_%EB%85%BC%EB%A6%AC%EC%97%B0%EC%82%B0%EC%9E%90_%EB%8B%A8%EC%B6%95%ED%8F%89%EA%B0%80/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Git / Github (3)</title>
      <link>https://namgungjongmin.github.io/2023/07/13/git3/</link>
      <guid>https://namgungjongmin.github.io/2023/07/13/git3/</guid>
      <pubDate>Thu, 13 Jul 2023 13:00:17 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/de3743e2-1a36-4b65-a97d-e6205280f31b/image.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Git-관리-전략&quot;&gt;&lt;a href=&quot;#G</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/de3743e2-1a36-4b65-a97d-e6205280f31b/image.png"></p><h2 id="Git-관리-전략"><a href="#Git-관리-전략" class="headerlink" title="Git 관리 전략"></a>Git 관리 전략</h2><p>기본적으로 하나의 중심 브랜치로만 관리하는 것을 <strong>trunk</strong> 라고 하고, 거기서 필요할 때만 브랜치를 분기하는 것을 <strong>trunk based flow</strong> 라고 표현합니다.</p><p>현업에서는 다양한 방식으로 브랜치를 관리하는데 가장 대표적인 방식으로 git flow, github flow, gitlab flow 세가지를 살펴보겠습니다.</p><h2 id="Git-flow"><a href="#Git-flow" class="headerlink" title="Git flow"></a>Git flow</h2><p><img src="/../images/230713/2023-07-13-16-06-53.png"></p><p>git flow는 총 5 종류의 브랜치를 활용해서 개발하는 깃 관리 전략입니다.</p><p>여기서 master, develop 브랜치는 영구적으로 존재하지만, hotfix, release, feature 브랜치의 경우는 필요할 때마다 브랜치를 만들고, merge가 되면 삭제하게 됩니다.</p><blockquote><p>merge시에 각 브랜치별 기록을 상세히 남기기 위해 항상 –no-ff 옵션을 붙입니다.</p></blockquote><p>전체적인 merge 순서 : feature -&gt; develop -&gt; release -&gt; master</p><h3 id="master-브랜치-main"><a href="#master-브랜치-main" class="headerlink" title="master 브랜치 (main)"></a>master 브랜치 (main)</h3><p>소비자가 사용하는 서비스 (배포된 코드)가 존재하는 브랜치 입니다. release 브랜치로부터 pr(pull request)를 받습니다.</p><h3 id="hotfix-브랜치"><a href="#hotfix-브랜치" class="headerlink" title="hotfix 브랜치"></a>hotfix 브랜치</h3><p>이미 <strong>배포 된</strong> 서비스에 대한 긴급 버그 수정을 진행하는 브랜치로 수정 완료 후 develop과 master 브랜치에 각각 pr을 날려 반영하게 됩니다.</p><h3 id="release-브랜치"><a href="#release-브랜치" class="headerlink" title="release 브랜치"></a>release 브랜치</h3><p>배포 전에 서비스를 테스트하는 브랜치입니다.</p><h3 id="develop-브랜치"><a href="#develop-브랜치" class="headerlink" title="develop 브랜치"></a>develop 브랜치</h3><p>개발 단계의 코드가 있는 개발 중심 브랜치입니다.<br>개발 자체는 feature 브랜치를 따로 분기해서 개발하여 develop브랜치에 병합시키는 작업을 반복하게 됩니다.</p><h3 id="feature-브랜치"><a href="#feature-브랜치" class="headerlink" title="feature 브랜치"></a>feature 브랜치</h3><p>특정한 <strong>단위 기능</strong>을 개발하는 브랜치 입니다. 기능 별로 개발 된 코드는 develop 브랜치로 pr을 보내게 됩니다.</p><h2 id="Github-flow"><a href="#Github-flow" class="headerlink" title="Github flow"></a>Github flow</h2><p><img src="/../images/230713/2023-07-13-16-16-41.png"></p><p>Github flow는 2 종류의 브랜치를 사용합니다. Git flow에 비해 작은 규모의 팀에서 빠른 개발과 업데이트가 중요한 서비스에서 효율적인 관리를 위해 사용합니다.</p><blockquote><p>반대로 Git flow는 큰 규모의 팀에서 안정성이 매우 중요한 서비스에서 사용됩니다.</p></blockquote><h3 id="master-브랜치-main-1"><a href="#master-브랜치-main-1" class="headerlink" title="master 브랜치 (main)"></a>master 브랜치 (main)</h3><p>소비자가 사용하는 서비스 (배포된 코드)가 존재하는 브랜치입니다.</p><h3 id="feature-브랜치-1"><a href="#feature-브랜치-1" class="headerlink" title="feature 브랜치"></a>feature 브랜치</h3><p>특정한 단위 기능을 구현하는 브랜치입니다.</p><blockquote><p>feature브랜치는 만들 때 Git flow보다 더 구체적으로, 상세하게 작업명을 작성하게 됩니다.</p></blockquote><h2 id="Gitlab-flow"><a href="#Gitlab-flow" class="headerlink" title="Gitlab flow"></a>Gitlab flow</h2><p><img src="/../images/230713/2023-07-13-16-18-57.png"></p><p>Git flow의 체계적인 관리와 Github flow의 단순함을 합쳐 절충적으로 관리하는 방식으로 4 종류의 브랜치를 사용합니다.</p><h3 id="production-브랜치"><a href="#production-브랜치" class="headerlink" title="production 브랜치"></a>production 브랜치</h3><p>소비자가 사용하는 서비스 (배포된 코드)가 존재하는 브랜치입니다.</p><h3 id="pre-production-브랜치"><a href="#pre-production-브랜치" class="headerlink" title="pre-production 브랜치"></a>pre-production 브랜치</h3><p>배포 전에 제품을 테스트하는 브랜치입니다.</p><h3 id="master-브랜치-main-2"><a href="#master-브랜치-main-2" class="headerlink" title="master 브랜치 (main)"></a>master 브랜치 (main)</h3><p>개발 단계의 코드가 있는 개발 중심 브랜치입니다.<br>Git flow의 develop 브랜치와 역할이 같습니다.</p><h3 id="feature-브랜치-2"><a href="#feature-브랜치-2" class="headerlink" title="feature 브랜치"></a>feature 브랜치</h3><p>특정한 단위 기능을 구현하는 브랜치로 브랜치 명은 Github flow처럼 자세하게 작성합니다.</p><hr><h2 id="Commit-convention"><a href="#Commit-convention" class="headerlink" title="Commit convention"></a>Commit convention</h2><p><img src="/../images/230713/2023-07-13-16-35-24.png"></p><p>커밋 메시지는 커밋을 할 때, 이 커밋이 어떤 개발에 해당되고, 어떤 변경사항이 있는지를 작성하는 것을 말합니다.</p><blockquote><p>커밋 메시지를 잘 작성하면, 우리는 단순히 커밋 이력만으로도 현재까지 어떤 개발이 진행되었는지, 어떤 문제가 발생했고 해결했는지를 알 수 있게 됩니다.</p></blockquote><h3 id="커밋-메시지-규칙"><a href="#커밋-메시지-규칙" class="headerlink" title="커밋 메시지 규칙"></a>커밋 메시지 규칙</h3><p>보통 아래와 같은 7가지 규칙을 지키게 됩니다.<br>(출처: <a href="https://cbea.ms/git-commit/">https://cbea.ms/git-commit/</a>)</p><ol><li>제목과 본문은 한 줄을 띄워서 작성한다.</li><li>제목은 영문 기준 50자 내외로 작성한다.</li><li>제목 첫 글자는 대문자로 작성한다.</li><li>제목 끝에 마침표(.)는 찍지 않는다</li><li>제목은 개조식으로 작성한다. (Update code, Fix bug 등으로만 작성)</li><li>본문은 영문 기준 72자마다 줄바꿈을 한다.</li><li>본문은 <strong>무엇을</strong>, <strong>왜</strong>에 맞춰서 작성한다.</li></ol><h4 id="타입-작성"><a href="#타입-작성" class="headerlink" title="타입 작성"></a>타입 작성</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Feat: &quot;로그인 함수 추가&quot;</span><br></pre></td></tr></table></figure><p>제목은 [타입: “내용”] 형식으로 작성합니다.</p><p>단순히 제목의 내용만 적는 것이 아니라 앞에 Feat: 이라는 단어가 붙어있는데요, 이는 해당 커밋의 타입을 명시하는 부분입니다.</p><ul><li>Feat : 새로운 기능 추가</li><li>Fix : 버그 수정</li><li>Env : 개발 환경 관련 설정</li><li>Style : 코드 스타일 수정 (세미 콜론, 인덴트 등의 스타일적인 부분만)</li><li>Refactor : 코드 리팩토링 (더 효율적인 코드로 변경 등)</li><li>Design : CSS 등 디자인 추가&#x2F;수정</li><li>Comment : 주석 추가&#x2F;수정</li><li>Docs : 내부 문서 추가&#x2F;수정</li><li>Test : 테스트 추가&#x2F;수정</li><li>Chore : 빌드 관련 코드 수정</li><li>Rename : 파일 및 폴더명 수정</li><li>Remove : 파일 삭제</li></ul><hr><h2 id="issue-pull-request-template"><a href="#issue-pull-request-template" class="headerlink" title="issue, pull request template"></a>issue, pull request template</h2><p><strong>template</strong>은 issue나 request를 작성하기 위한 틀을 말합니다.<br>우리가 issue나 pull request를 작성할 때 일일이 목차를 직접 작성하게 되면 시간이 오래 걸리게 됩니다. 또한 issue 나 pull request를 작성하는 팀원들 간의 양식을 지킬 수 있게 됩니다.</p><h3 id="vscode에서-template-설정해보기"><a href="#vscode에서-template-설정해보기" class="headerlink" title="vscode에서 template 설정해보기"></a>vscode에서 template 설정해보기</h3><p>git으로 관리되는 폴더 내부에 .github 폴더를 만든다.<br><img src="/../images/230713/2023-07-24-11-09-32.png"></p><p>main 브랜치로 push한 이후에 github내에서 이슈 생성으로 들어가보면 템플릿이 적용된 것을 확인할 수 있습니다.</p><p><img src="/../images/230713/2023-07-24-11-10-52.png"></p><blockquote><p>issue의 경우, 단순 작업 정리 용도가 아닌, 다양한 목적으로 생산될 수 있습니다.</p></blockquote><p>때문에 여러 개의 issue template를 만들 수 있는 github 자체 기능이 있습니다.</p><p>깃허브 레포지토리 설정에 들어가 General 메뉴에서 스크롤을 내리다보면 아래와 같이 setup templates 버튼이 보입니다.<br><img src="/../images/230713/2023-07-24-11-36-45.png"></p><p>기본적으로 깃허브에서 기본적으로 마크다운을 어느정도 작성해 놓은 템플릿을 추가할 수 있는데, preview and edit 버튼을 눌러서 수정도 가능합니다.<br><img src="/../images/230713/2023-07-24-11-37-06.png"></p><p><img src="/../images/230713/2023-07-24-11-38-12.png"></p><hr><h2 id="Branch-Protection"><a href="#Branch-Protection" class="headerlink" title="Branch Protection"></a>Branch Protection</h2><p>지금까지 예시에서는 main 브랜치에 바로 push를 했는데요, main 브랜치에 바로 push하는 행위는 위험합니다.</p><p>그게 바로 pull request를 사용해야 하는 이유인데요 주니어 개발자가 에러가 나는 코드를 잘못해서 바로 main 브랜치에 push를 하게 된다면 서비스 사용자는 갑자기 에러를 마주하게 될 것입니다.</p><p>때문에 실수를 방지하기 위해서 main 브랜치에 push하는 것을 원천적으로 차단해버려야 합니다.</p><p>우리는 github에서 branch protection이라는 방식으로 이를 해결할 수 있습니다.</p><hr><p>레포지토리 설정에 들어가서 왼쪽에서 브랜치를 선택하면 add rule 버튼을 확인할 수 있습니다.</p><p><img src="/../images/230713/2023-07-24-11-42-17.png"></p><p>여기에 보호하고자 하는 브랜치 이름을 적어주면 됩니다. 또한 여기서 pattern도 지정이 가능합니다.(feature*라고 작성하면 feature라는 접두어를 가진 모든 브랜치에 protection이 적용됩니다.)</p><p><img src="/../images/230713/2023-07-24-11-43-50.png"></p><p>이제 main 브랜치가 보호되었습니다. main 브랜치에 직접 push를 해보면, 보호된 브랜치라서 push가 불가능하다고 에러가 나오게 됩니다.</p><p><img src="/../images/230713/2023-07-24-11-44-55.png"></p><hr><h2 id="git사용-꿀팁-x2F-pull-오류를-만났을-때"><a href="#git사용-꿀팁-x2F-pull-오류를-만났을-때" class="headerlink" title="git사용 꿀팁 &#x2F; pull 오류를 만났을 때"></a>git사용 꿀팁 &#x2F; pull 오류를 만났을 때</h2><p><img src="/../images/230713/2023-07-24-12-00-33.png"></p><p>위 에러는 현재 가진 로컬 브랜치의 커밋 이력과, 리모트 브랜치의 커밋 이력이 충돌하는 경우입니다. 여러번의 push 요청이 오게되면 git 입장에서는 이력을 어떻게 합치는 것이 좋은지 선택하지 못하게됩니다.</p><p><strong>git pull의 근본적인 원리</strong>는 github쪽의 리모트 브랜치와 로컬 브랜치를 merge, rebase를 통해 합치는 것으로 이루어집니다. 그런데 해당 에러는 git이 pull을 할 때 정확히 merge, rebase 혹은 fast-forward merge 중에 무엇을 선택할지 모르겠으니 사용자에게 지정해달라고 하는 것입니다.</p><blockquote><p>main 브랜치에 대해서 직접 push하지 않고 pull request를 통해서만 merge를 하게 되면 이 에러가 발생하지 않을 것입니다.</p></blockquote><p>보통 개발 블로그에서 git config pull.rebase false 같은 명령어를 입력하라고 할텐데, 이렇게 git 절정 자체를 바꾸기 보단,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main --no-ff</span><br></pre></td></tr></table></figure><p>와 같이 내가 원하는 pull 형태가 어떤 것인지 지정해주는 것이 좋습니다.<br>이후에 conflict가 발생한 부분을 수정한 뒤에 commit까지 해주면 해결이 됩니다.</p><hr><h2 id="git으로-관리하지-않을-대상-설정"><a href="#git으로-관리하지-않을-대상-설정" class="headerlink" title="git으로 관리하지 않을 대상 설정"></a>git으로 관리하지 않을 대상 설정</h2><p>개발을 하다보면, 분명 암호 파일을 프로젝트 폴더 내부에서 관리하게 되는 경우가 발생합니다.</p><p>이 경우 github에 해당 파일을 올리게 되면 모두가 암호를 볼 수 있겠죠?<br><img src="/../images/230713/2023-07-24-12-13-57.png"></p><p>또한 로그, 컴파일 파일 같은 용량이 큰 파일: Java 컴파일 파일(.class), 모듈파일(vendor, node_modules)같은 파일들 또한 git으로 다 관리하기에 무리가 있습니다.</p><p>이런 경우 우리는 .gitignore을 이용할 수 있습니다.</p><p>프로젝트 폴더 내부에서 특정한 파일만 제외하고 싶을 때, .gitignore라는 파일을 만들고, 파일 내부에 제외하고자 하는 파일명 혹은 폴더명을 적어주시면 됩니다.</p><p><img src="/../images/230713/2023-07-24-12-19-53.png"></p><blockquote><p>vscode 상에서 해당 파일의 색깔이 회색으로 바뀌는 것을 확인할 수 있습니다.</p></blockquote><h3 id="이미-key-파일이-git으로-관리되고-있을-때"><a href="#이미-key-파일이-git으로-관리되고-있을-때" class="headerlink" title="이미 key 파일이 git으로 관리되고 있을 때"></a>이미 key 파일이 git으로 관리되고 있을 때</h3><p>git에서 이미 해당 파일을 add, commit까지 하여서 git이 대상 파일을 인지하고 있다면 파일이 cache (임시 저장소) 안에 남아있기 때문에, .gitignore 안에 파일명을 추가해도 제외되지 않습니다.</p><p>이미 git으로 관리되는 파일을 제외하기 위해서는 임시저장소의 파일을 삭제해주는 작업이 필요합니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br></pre></td></tr></table></figure><blockquote><p>git이 자체적으로 가지고있는 캐시들을 삭제하는 명령어입니다.</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Git-Github/">Git / Github</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/Git/">Git</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/Github/">Github</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/07/13/git3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Git / Github (2)</title>
      <link>https://namgungjongmin.github.io/2023/07/12/git2/</link>
      <guid>https://namgungjongmin.github.io/2023/07/12/git2/</guid>
      <pubDate>Wed, 12 Jul 2023 13:37:02 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/de3743e2-1a36-4b65-a97d-e6205280f31b/image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Branch&quot;&gt;&lt;a href=&quot;#Bran</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/de3743e2-1a36-4b65-a97d-e6205280f31b/image.png"></p><h1 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h1><p>git에는 branch라는 개념이 있습니다. branch는 분기라는 뜻을 가지고 있는데요, 말그대로 버전 관리의 분기점을 만드는 기능입니다.<br>버전 관리를 분기한다는 것은 현재 작업중인 상태(파일, 커밋기록) 그대로, 아예 별도로 관리되는 새로운 폴더를 하나 더 만드는 것입니다.</p><p><img src="https://velog.velcdn.com/images/vbghdl/post/b2201dd7-cf63-478a-9002-21e2ede127eb/image.png"></p><p>기업별 자기소개서를 쓴다고 한다면 각 기업에 맞는 특화된 자기소개서를 준비해야 하겠지요? 여기서 자기소개서라는 뿌리는 같지만 분기별로 나누어 각각의 새로운 관리 대상을 버전관리하게 되는데 이것이 브랜치 입니다. 브랜치를 통해 우리는 원할 때마다 브랜치를 옮겨다니면서 작업을 할 수 있게 됩니다.</p><p>개발에 있어서는 개발 절차 상의 안전성 때문에 사용하게 됩니다.</p><p><img src="/../images/230712/2023-07-12-14-44-27.png"></p><ul><li>현재 작업 중인 내용을 유지하면서, 파일과 커밋 기록을 별도로 관리하고자 할 때 브랜치를 분기하게 됩니다.</li><li>브랜치를 분기하게 되면, 그때부터는 파일과 커밋 기록이 완전히 별도로 관리됩니다.</li><li>브랜치는 얼마든지 추가로 더 만들 수 있는데, 항상 원본 브랜치가 있어야 분기할 수 있습니다.</li></ul><h2 id="branch-생성"><a href="#branch-생성" class="headerlink" title="branch 생성"></a>branch 생성</h2><p>branch 라는 폴더를 만들고 hello.txt 파일을 만들어 안녕하세요 라는 텍스트를 입력하겠습니다.</p><p><img src="/../images/230712/2023-07-12-14-15-25.png"></p><p>그상태로 git init을 사용해 git으로 폴더를 관리해줍니다.</p><p><img src="/../images/230712/2023-07-12-14-15-59.png"></p><blockquote><p>main 이라는 브랜치 명을 쓰게 된 것은 2020년의 흑인 운동의 일환으로 master &#x2F; slave 등의 용어에 대한 정화의 필요하다는 의식이 생기게 되면서 Github에서 기본 브랜치 명을 master에서 main 으로 변경되게 되었고 git 자체적으로도 main 브랜치를 기본 이름으로 쓰도록 권장되고 있습니다.</p></blockquote><p>git init을 할 때 브랜치 명이 master로 기본 설정 되어있다면 아래 명령어를 통해 main으로 바꿀 수 있습니다.</p><p><img src="/../images/230712/2023-07-12-14-18-32.png"></p><p>이제 add commit을 해서 현재 파일 상태를 기록해주겠습니다.</p><p><img src="/../images/230712/2023-07-12-14-19-20.png"></p><p>분기를 해보겠습니다. 브랜치를 전환할 때는 git switch 명령어를 통해 브랜치를 전환할 수 있습니다. 이 때 새로운 브랜치를 만들면서 전환하고 싶다면 -c 옵션을 같이 입력해주시면 됩니다. (브랜치를 만들기만하고 이동하고 싶지 않을 때는 git branch [브랜치명] 명령어를 이용하면 됩니다.)</p><p><img src="/../images/230712/2023-07-12-14-21-25.png"></p><p>git branch –list 명령어를 통해 현재 보유하고있는 브랜치들을 확인할 수 있습니다.</p><p><img src="/../images/230712/2023-07-12-14-22-32.png"></p><p>이제 develop 브랜치에서 파일에 ‘수고하세요’라는 텍스트를 입력하고 커밋해보겠습니다.</p><p><img src="/../images/230712/2023-07-12-14-23-45.png"></p><p>develop 브랜치에서는 새로운 커밋이 생겼는데 main 브랜치에선 어떨까요?<br>main 브랜치를 옮겨가서 로그를 확인해봅시다.</p><p><img src="/../images/230712/2023-07-12-14-24-32.png"></p><p>develop 브랜치와 main 브랜치의 커밋이 별도로 관리된다는 것을 확인할 수 있습니다.</p><p>develop 브랜치로 돌아가 다시 분기해보겠습니다. test 브랜치를 새로 만들어 주겠습니다. 그리고 텍스트도 추가해주겠습니다.</p><p><img src="/../images/230712/2023-07-12-22-44-43.png"></p><h2 id="브랜치-삭제"><a href="#브랜치-삭제" class="headerlink" title="브랜치 삭제"></a>브랜치 삭제</h2><p>이제 만든 test 브랜치를 삭제해보겠습니다.<br>삭제에는 git branch -D (브랜치명) 명령어를 사용합니다. 삭제하려는 브랜치를 제외한 다른 브랜치로 옮겨서 명령어를 입력해줍니다.<br>git branch –list로 결과도 확인해보겠습니다.</p><p><img src="/../images/230712/2023-07-12-14-28-51.png"></p><h2 id="브랜치-병합"><a href="#브랜치-병합" class="headerlink" title="브랜치 병합"></a>브랜치 병합</h2><p>git merge 명령어는 서로 다른 branch의 작업 내용을 하나의 branch 로 통합하기 위한 명령어 입니다.</p><p><img src="/../images/230712/2023-07-12-14-45-14.png"></p><p>이 때 통합하는 merge 행위 자체가 하나의 커밋으로서 남게 됩니다.</p><p>새로운 폴더를 생성해서 실습해보겠습니다. hello.txt를 생성해서 다음과 같은 텍스트를 입력해주고 git init을 통해 관리하게 하겠습니다.</p><p><img src="/../images/230712/2023-07-12-14-48-53.png"></p><hr><p>이후에는 develop 브랜치를 만들어서 텍스트를 추가하고 다시 커밋까지 해주겠습니다.<br><img src="/../images/230712/2023-07-12-14-53-54.png"><br><img src="/../images/230712/2023-07-12-14-53-42.png"></p><p>다시 main 브랜치로 전환해서 텍스트를 또 추가하고 커밋을 해주겠습니다.</p><p><img src="/../images/230712/2023-07-12-14-55-51.png"></p><hr><p>이제 merge 명령어를 통해 main브랜치에서 develop브랜치를 병합해보겠습니다.<br>‘메인브랜치로 가서 -&gt; develop 을 병합한다’</p><p><img src="/../images/230712/2023-07-12-14-58-49.png"><br><img src="/../images/230712/2023-07-12-14-59-01.png"></p><p>두 브랜치에서 각각 작성된 텍스트가 main 브랜치에서 병합되어 전부 나타나는 것을 확인했습니다.</p><p>아래 명령어를 통해서 커밋 기록이 어떤식으로 이루어져있는지를 좀 더 직관적으로 확인할 수 있습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --decorate --oneline</span><br></pre></td></tr></table></figure><p><img src="/../images/230712/2023-07-12-15-02-45.png"></p><p>위에 설명한 그림처럼 커밋 기록이 이루어진 것을 확인할 수 있습니다.</p><h2 id="merge-conflict"><a href="#merge-conflict" class="headerlink" title="merge conflict"></a>merge conflict</h2><p>바로 위 예시에서 왜 중간 공간을 띄어놓고 각각 2번줄 4번줄에 텍스트를 추가했을까요?</p><p>두 브랜치를 병합할 때 만약 각 브랜치에서 서로 같은 부분을 수정했다면 git의 입장에서 어떤 브랜치를 우선해야할지 결정할 수 없게 됩니다.</p><p>이 때 사용자에게 둘중 어떤 것을 기준하여 확정할지를 정해달라고 하는 말을 건네는 것이 바로 merge conflict 입니다!</p><p>(merge conflict 예시)<br><img src="/../images/230712/2023-07-12-15-13-17.png"></p><p>여기서 accept current change를 선택하면 현재 우리가 있는 main브랜치의 내용을 따르게 되고, accept incoming change를 누르면 병합하는 develop 브랜치를 따르게 됩니다. 또는 직접 내용을 수정해서 merge하는 것도 가능합니다.</p><blockquote><p>Git으로 협업할 때 중요한 부분을 배울 수 있습니다. 여러 사람이 동시에 한 파일의 같은 부분을 작업해서는 안된다는 것입니다. 애초에 작업을 분담해 서로 다른 파일&#x2F; 다른 부분을 작업하도록 분담하는 것이 conflict를 방지하기 위한 방법입니다.</p></blockquote><hr><h2 id="fast-forward"><a href="#fast-forward" class="headerlink" title="fast-forward"></a>fast-forward</h2><p>main 브랜치에서 develop 브랜치로 분기를 하고 main 브랜치를 건드리지는 않은 상태에서 develop 브랜치만을 수정하고 merge하는 경우를 상상해봅시다.</p><p><img src="/../images/230712/2023-07-12-15-23-25.png"></p><p>병합을 시도하면 fast-forword라는 문구가 뜨게되는데요, 위 상황같은 경우에는 merge conflict가 날 상황도 생기지 않고 그저 main에서 계속 작업을 했을 때와 같은 상황으로 보여지는데 이 경우를 fast-forward라고 합니다.</p><p>이 경우에는 따로 merge 커밋이 생기지도 않고 그저 develop 브랜치의 커밋이 main 브랜치에 병합되면서 아래와 같은 커밋 기록이 만들어지게 됩니다.</p><p><img src="/../images/230712/2023-07-12-15-25-41.png"></p><p>만약 기존처럼 줄기가 나눠진 형태로 커밋 기록을 남기고 싶다면 –no-ff를 붙여 merge명령어를 입력하면 됩니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge develop --no--ff</span><br></pre></td></tr></table></figure><h3 id="fast-forward의-장단점"><a href="#fast-forward의-장단점" class="headerlink" title="fast-forward의 장단점"></a>fast-forward의 장단점</h3><ul><li>장점: 분기점이 남지 않기 때문에 커밋 기록을 더 직관적으로 볼 수 있다.</li><li>단점: merge했다는 기록도 없고, 분기점도 없다.</li></ul><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>rebase는 특정 브랜치를 기준으로 놓고 커밋 이력을 정렬하는 명령어입니다. non-fast-forward를 fast-forward로 만드는 명령어라고 생각하시면 됩니다.</p><p>아래와 같은 형태로 브랜치가 나눠져 있다면<br><img src="/../images/230712/2023-07-12-15-47-42.png"></p><p>줄기가 나뉘지 않고 fast-forward로 커밋 이력이 정리되게 됩니다.<br><img src="/../images/230712/2023-07-12-15-48-29.png"><br><img src="/../images/230712/2023-07-12-15-48-43.png"></p><h1 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h1><p>pull request는 ‘나의 담당 브랜치에서 작업이 완료되었으니, 이 브랜치의 코드를 가져가서 병합해주세요’라는 요청을 보내는 것입니다.</p><p>pull request를 하는 이유는</p><ol><li>내가 작성한 코드가 바로 적용되었을 때 발생할 수 있는 문제를 미리 방지</li><li>현재 코드에 대한 코드 리뷰를 진행</li><li>프로젝트에 대한 진행 상황을 관리<br>등이 있습니다.</li></ol><h2 id="pull-request-사용한-병합"><a href="#pull-request-사용한-병합" class="headerlink" title="pull request 사용한 병합"></a>pull request 사용한 병합</h2><p>intro.txt 파일을 만들어서 텍스트를 입력해주고 git init &gt; add &gt; commit 해주겠습니다.</p><p>또 각 목차별로 branch를 만들어서 각 내용을 작성하고 이를 main 브랜치로 병합하겠습니다.</p><p><img src="/../images/230712/2023-07-12-16-10-23.png"><br><img src="/../images/230712/2023-07-12-16-10-32.png"></p><hr><p>이후에는 github에서 레포지토리를 새로 만들어 로컬저장소와 연결해주겠습니다.</p><p><img src="/../images/230712/2023-07-12-16-14-13.png"><br><img src="/../images/230712/2023-07-12-16-14-27.png"></p><p>git push –all 명령어를 이용해 모든 브랜치와 commit 내역을 github로 올리겠습니다.</p><p>그러면 github에서 각 브랜치들을 확인할 수 있고 main을 기반으로 각 브랜치를 머지해 달라는 메시지도 확인할 수 있습니다.</p><p><img src="/../images/230712/2023-07-12-16-16-13.png"></p><p>github에서 pull request 요청을 보내 main에 각 브랜치의 내용을 병합할 수 있습니다.</p><p><img src="/../images/230712/2023-07-12-16-16-55.png"></p><p>보통 pull request를 작성할 때에는 해당 부분을 왜 작성했고, 이전에 비해 어떤 것이 바뀌었는지, 그리고 코드리뷰 관련 요청사항등을 작성하게 됩니다.</p><p><img src="/../images/230712/2023-07-12-16-19-16.png"></p><p>그러면 pull request 페이지가 생성되고 그 페이지에서 개발자들간 코멘트를 주거나 코드리뷰를 하는 등 활동을 할 수 있습니다.</p><p><img src="/../images/230712/2023-07-12-16-20-47.png"><br><img src="/../images/230712/2023-07-12-16-21-12.png"></p><hr><p>Confirm merge 버튼을 누르게 되면 main에 name 브랜치가 merge 되는 것을 확인할 수 있습니다.</p><p>또한 브랜치를 merge하여 브랜치의 사용이유가 사라졌으니 삭제해 달라는 메시지가 뜨는 것도 확인할 수 있습니다. 버튼을 눌러 삭제해주겠습니다.</p><p><img src="/../images/230712/2023-07-12-16-28-21.png"></p><p>main 에 병합된 name 브랜치의 내용들을 확인할 수 있습니다.<br><img src="/../images/230712/2023-07-12-16-24-07.png"><br><img src="/../images/230712/2023-07-12-16-25-12.png"></p><hr><h2 id="github-수정사항-가져오기"><a href="#github-수정사항-가져오기" class="headerlink" title="github 수정사항 가져오기"></a>github 수정사항 가져오기</h2><p>원격저장소인 github의 수정사항을 로컬 저장소에도 반영해야겠죠?<br>이 때 사용하는 명령어는 git pull 입니다.</p><p><img src="/../images/230712/2023-07-12-16-32-38.png"></p><p>다만 여기서 원격 저장소에서 삭제한 브랜치는 로컬 저장소에 반영이 되지 않기 때문에 수동적으로 지워주셔야 합니다.</p><p>git branch -D 명령어를 이용합니다.<br><img src="/../images/230712/2023-07-12-16-34-26.png"></p>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Git-Github/">Git / Github</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/Git/">Git</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/Github/">Github</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/07/12/git2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Git / Github (1)</title>
      <link>https://namgungjongmin.github.io/2023/07/11/git1/</link>
      <guid>https://namgungjongmin.github.io/2023/07/11/git1/</guid>
      <pubDate>Tue, 11 Jul 2023 14:11:55 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/vbghdl/post/de3743e2-1a36-4b65-a97d-e6205280f31b/image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;cli와-gui의-차이&quot;&gt;&lt;a href=</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://velog.velcdn.com/images/vbghdl/post/de3743e2-1a36-4b65-a97d-e6205280f31b/image.png"></p><h1 id="cli와-gui의-차이"><a href="#cli와-gui의-차이" class="headerlink" title="cli와 gui의 차이"></a>cli와 gui의 차이</h1><p>cli: command line &#x2F; 시각적인 요소가 아닌 명령어를 통해 컴퓨터와 상호작용하는 방식입니다.</p><p>gui: graphic user interface &#x2F; 평소에 폴더를 클릭하고, 그 폴더 안의 파일을 클릭해서 컴퓨터를 활용하는 방식입니다.</p><blockquote><p>글로만 이루어진 화면을 토대로 어떤 폴더에 들어와있는지 구별할 줄 알고, 어떤 명령어를 입력했을 때 어떤 동작이 수행되는 지를 알아야 합니다.</p></blockquote><h1 id="기본-명령어"><a href="#기본-명령어" class="headerlink" title="기본 명령어"></a>기본 명령어</h1><p>ls : 현재 경로의 모든 파일&#x2F;폴더들을 리스팅<br><img src="/../images/2023-07-11-14-20-10.png"></p><p>cd (경로) : 경로로 이동 &#x2F; cd .. : 이전 경로로 이동</p><p><img src="/../images/2023-07-11-14-24-34.png"></p><p>절대경로 vs 상대경로</p><p>절대경로 : 내가 위치한 곳과 상관없이, 특정한 폴더&#x2F;파일이 위치한 경로의 전체 주소를 말합니다.<br>절대 경로는 앞에 ‘&#x2F;‘를 붙습니다.</p><p>상대경로 : 내가 위치한 곳에서의 본 특정한 폴더&#x2F;파일의 경로를 말합니다.</p><p>mkdir (폴더명) : 새 폴더 생성<br><img src="/../images/2023-07-11-14-28-47.png"></p><p>mv 이동 &#x2F; rm 삭제 &#x2F; cp 복사 등의 여러 명령어가 있습니다.</p><blockquote><p>깃관련 오류가 생겼을 때 현재 자신이 있는 경로가 잘못되어있는 경우가 많다. 항상 자신의 경로를 먼저 확인하도록 한다.</p></blockquote><h1 id="Git이란"><a href="#Git이란" class="headerlink" title="Git이란"></a>Git이란</h1><p>버전 관리를 위한 프로그램입니다.<br>버전 관리라는건 특정한 프로젝트 등을 진행할 때, 진행 상황을 수시로 기록하면서, 필요할 때는 이전 상황으로 돌아갈 수 있게 해주는 등 종합적으로 폴더&#x2F;파일의 수정 사항을 관리하는 것을 말합니다. 만약 자기소개서를 작성한다 가정해보겠습니다.</p><p>[1차 완]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">안녕하세요</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[2차 완]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">안녕하세요. 제이름은</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[최종]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">안녕하세요. 제이름은남궁종민 입니다.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[찐 최종]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">안녕하세요. 제 이름은 남궁종민 입니다.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이런식으로 수정의 수정을 거듭하면서 작성을 하게 되는데 이렇게 각각의 수정 사항을 원할 때마다 수시로 기록하면서 이전 수정 상태로 돌아갈 수 있도록 하는 기능이 바로 Git입니다!</p><h1 id="Git-사용해보기"><a href="#Git-사용해보기" class="headerlink" title="Git 사용해보기"></a>Git 사용해보기</h1><h2 id="git-사용-개괄적으로-살펴보기"><a href="#git-사용-개괄적으로-살펴보기" class="headerlink" title="git 사용 개괄적으로 살펴보기"></a>git 사용 개괄적으로 살펴보기</h2><p>git add 명령어를 통해 어떤 파일을 관리할지 지정하고,<br>git commit 명령어로 현재 관리중인 파일을 하나의 버전으로 저장</p><p><img src="/../images/2023-07-11-15-05-05.png"></p><p>git은 아직 git add 를 통해 관리되기 전 파일을 untracked file 이라고 말하고, 관리되는 파일을 tracked file이라고 말합니다.<br>commit이 되기 전 상태를 staged 상태라고 말합니다.</p><h2 id="버전-관리-시작"><a href="#버전-관리-시작" class="headerlink" title="버전 관리 시작"></a>버전 관리 시작</h2><p>우선 vscode를 실행하여 hello.txt라는 파일을 하나 만들고 ‘안녕하세요’라는 텍스트를 입력합니다.</p><p><img src="/../images/2023-07-11-15-09-21.png"></p><hr><h2 id="git-폴더-설정"><a href="#git-폴더-설정" class="headerlink" title="git 폴더 설정"></a>git 폴더 설정</h2><p>git init 명령어를 통해 git 저장소를 처음으로 만들어줍니다.</p><p>현재 폴더 자체를 git이 관리하고 있는 상태지만 아직 untracked 상태로 파일을 지켜보고 있지는 않은 상태입니다.</p><p><img src="/../images/2023-07-11-15-14-10.png"></p><hr><p>git으로 폴더를 관리하는 순간 .git이라는 숨김 파일이 생성되고 git 관련 버전등이 파일 안에서 관리되게 됩니다.</p><p><img src="/../images/2023-07-11-15-15-55.png"></p><hr><h2 id="git-상태-확인하기-x2F-추가하기"><a href="#git-상태-확인하기-x2F-추가하기" class="headerlink" title="git 상태 확인하기&#x2F;추가하기"></a>git 상태 확인하기&#x2F;추가하기</h2><p>git status 명령어를 통해 보면 폴더 내 파일들이 어떤 상태인지 확인할 수 있다. untracked 상태의 hello.txt 파일을 add하여 깃이 바라보게 해봅시다.</p><p><img src="/../images/2023-07-11-15-19-35.png"></p><blockquote><p>git 으로 staged 상태로 올려야 할 파일이 많을 때 git add . 을 입력하면 폴더 내 모든 파일을 관리하게 할 수 있지만, 각각의 기능 별로 add commit을 하는 실무의 특성상 좋은 습관은 아니다.</p></blockquote><hr><h2 id="git-상태-되돌리기"><a href="#git-상태-되돌리기" class="headerlink" title="git 상태 되돌리기"></a>git 상태 되돌리기</h2><p>git reset 명령어를 사용하면 staged 상태의 파일을 untracked 상태로 되돌릴 수 있습니다.</p><p><img src="/../images/2023-07-11-15-24-32.png"></p><hr><h2 id="git-commit-하기"><a href="#git-commit-하기" class="headerlink" title="git commit 하기"></a>git commit 하기</h2><p>이후에는 git commit 명령어를 통해 버전으로 저장합니다.</p><p><img src="/../images/2023-07-11-15-30-18.png"></p><p><img src="/../images/2023-07-11-15-31-57.png"></p><p>제 경우에는 git 에디터 기본으로 vim으로 설정되어 있기 때문에 vim창이 떴지만 일반 유저 분들은 git commit -m “{커밋 메시지}” 를 적어주시면 됩니다.</p><p><img src="/../images/2023-07-11-15-36-40.png"></p><p>commit이 정상적으로 진행 되었다는 메시지를 확인할 수 있습니다.</p><blockquote><p>commit 관련해서도 지켜야할 규칙이나 컨벤션이 존재하지만 이는 기업 컨벤션마다 다르고 일반적인 규칙 등은 차후 다루겠습니다.</p></blockquote><h2 id="git-commit-메시지-수정하기"><a href="#git-commit-메시지-수정하기" class="headerlink" title="git commit 메시지 수정하기"></a>git commit 메시지 수정하기</h2><p>git commit –amend 명령어를 통해 수정할 수 있습니다.</p><p><img src="/../images/2023-07-11-15-40-50.png"></p><p>가장 최근 커밋을 불러와 내가 원하는 방식으로 바꿀 수 있습니다.</p><p><img src="/../images/2023-07-11-15-41-42.png"></p><hr><h2 id="추가-커밋하고-버전-확인하기"><a href="#추가-커밋하고-버전-확인하기" class="headerlink" title="추가 커밋하고 버전 확인하기"></a>추가 커밋하고 버전 확인하기</h2><p>text 내용을 바꾸고 추가로 add 후 commit을 해주었습니다.</p><p><img src="/../images/2023-07-11-15-44-31.png"></p><p>추가로 커밋한 버전이 로그에 잘 올라와있나 확인해봅시다.</p><p><img src="/../images/2023-07-11-15-45-16.png"></p><p>변경한 텍스트의 버전과 변경하기 전 텍스트 버전이 둘다 로그에 남아있는 것을 확인할 수 있습니다. 업데이트 하기 전 버전으로 돌아가고 싶다면 로그에 나와있는 커밋 정보를 활용해 명령어를 사용하면 되겠죠?</p><hr><blockquote><p>커밋은 기능단위로 하는 것이 원칙입니다!! 여러가지 파일이 있다면 각 파일의 기능 단위로 add와 commit을 진행해야 합니다.</p></blockquote><blockquote><p>모든 수정사항을 하나의 커밋으로 저장하게 된다면 커밋에 여러 기능에 대한 업데이트가 혼재하는 상황이 발생하게 됩니다. 이것은 추후 작업의 진행사항을 파악하고, 버그를 찾아내는 것에 큰 걸림돌이 될 수 있습니다.</p></blockquote><h2 id="버전-되돌리기"><a href="#버전-되돌리기" class="headerlink" title="버전 되돌리기"></a>버전 되돌리기</h2><p>우선 커밋 버전으로 돌아가려면 각 커밋 버전을 지칭하는 대상을 알아야 합니다.<br><img src="/../images/2023-07-11-16-10-40.png"><br>로그를 통해 커밋의 고유 번호를 확인할 수 있습니다.</p><p>2가지 방식이 있습니다.</p><h3 id="revert-현재까지의-commit-기록을-유지하면서-특정한-commit-이전으로-되돌리는-명령어입니다"><a href="#revert-현재까지의-commit-기록을-유지하면서-특정한-commit-이전으로-되돌리는-명령어입니다" class="headerlink" title="revert - 현재까지의 commit 기록을 유지하면서, 특정한 commit 이전으로 되돌리는 명령어입니다."></a>revert - 현재까지의 commit 기록을 유지하면서, 특정한 commit 이전으로 되돌리는 명령어입니다.</h3><p><img src="/../images/2023-07-11-16-12-39.png"></p><p>“추가수정사항” 이라는 텍스트를 추가하고 커밋했습니다. 세번째 줄이 없던 버전으로 돌아가고 싶다면</p><p><img src="/../images/2023-07-11-16-13-19.png"><br>로그의 가장 최근 커밋이 없었던 때로 돌아가야 합니다.</p><p>git revert [해당 커밋 고유번호] 를 입력하면 최근 수정사항의 커밋이 없던 때로 돌아가기 때문에 세번째 텍스트가 사라지게 됩니다.</p><p><img src="/../images/2023-07-11-16-16-57.png"></p><p>로그를 살펴보면 어떤 커밋을 없던 상태로 되돌렸는지 있었던 커밋, 되돌린 커밋 또한 로그에서 확인할 수 있습니다.</p><p><img src="/../images/2023-07-11-16-19-57.png"></p><h3 id="reset-특정-커밋으로-돌아가면서-그-커밋-이후의-커밋-기록을-삭제하는-명령어입니다-마치-그-이후의-커밋이-없었던-것처럼-만들어주는-것입니다"><a href="#reset-특정-커밋으로-돌아가면서-그-커밋-이후의-커밋-기록을-삭제하는-명령어입니다-마치-그-이후의-커밋이-없었던-것처럼-만들어주는-것입니다" class="headerlink" title="reset - 특정 커밋으로 돌아가면서, 그 커밋 이후의 커밋 기록을 삭제하는 명령어입니다. 마치 그 이후의 커밋이 없었던 것처럼 만들어주는 것입니다"></a>reset - 특정 커밋으로 돌아가면서, 그 커밋 이후의 커밋 기록을 삭제하는 명령어입니다. 마치 그 이후의 커밋이 없었던 것처럼 만들어주는 것입니다</h3><p>soft &#x2F; hard &#x2F; mixed 세가지의 옵션이 있습니다.</p><p>soft - 파일은 그대로 두면서 커밋 기록만 되돌아갑니다. 수정 사항은 staged 상태가 됩니다.</p><p>hard - 파일도 함께 되돌아갑니다.</p><p>mixed - 파일을 그대로 두면서 커밋 기록이 돌아가는데 수정사항을 staged 상태가 아닌 untracked 상태로 둡니다.</p><hr><h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><p>git을 통해 관리하는 컴퓨터 내의 저장소를 local저장소라 합니다.</p><p><img src="/../images/2023-07-11-17-01-54.png"></p><p>github 사이트를 통해 관리하는 곳을 원격저장소 remote 저장소라고 합니다. github 사이트에서 새로운 레포지토리를 만들었습니다.</p><h2 id="원격저장소와-연결하기"><a href="#원격저장소와-연결하기" class="headerlink" title="원격저장소와 연결하기"></a>원격저장소와 연결하기</h2><p>git remote add origin [깃허브 클론주소] 명령어를 입력하여 github와 연동시켜줍니다.</p><p><img src="/../images/2023-07-11-17-07-07.png"></p><p><img src="/../images/2023-07-11-17-07-28.png"></p><hr><p>연결 후에 git push origin main 명령어를 통해 원격 저장소의 main 브랜치에 연동된 local 저장소를 푸시해봅니다.</p><p><img src="/../images/2023-07-11-17-22-26.png"></p><p>원격 저장소에 로컬 저장소의 파일들이 업로드 된 것을 확인할 수 있습니다.</p><hr><p>마크다운 관련 수업</p><p>(배지 찾기 사이트)<br><a href="https://github.com/alexandresanlim/Badges4-README.md-Profile">https://github.com/alexandresanlim/Badges4-README.md-Profile</a></p><hr><h2 id="원격-저장소의-버전을-로컬로-가져오기"><a href="#원격-저장소의-버전을-로컬로-가져오기" class="headerlink" title="원격 저장소의 버전을 로컬로 가져오기"></a>원격 저장소의 버전을 로컬로 가져오기</h2><p>md파일을 원격 저장소에서 수정해봅시다.</p><p><img src="/../images/2023-07-11-17-45-36.png"></p><p>수정된 원격 저장소의 버전과 로컬 저장소의 버전이 다르기 때문에 동기화를 시켜주기 위해서는 pull시켜 주어야 합니다.</p><p>명령어 git pull origin main을 통해 동기화 시켜줍니다.</p><p><img src="/../images/2023-07-11-17-46-40.png"></p><p>로컬 저장소의 상태가 원격 저장소와 완전히 같아졌습니다!</p><hr><h2 id="github로-협업하기"><a href="#github로-협업하기" class="headerlink" title="github로 협업하기"></a>github로 협업하기</h2><p>clone &#x2F; fork 두가지 방법</p><h2 id="clone-하나의-레포지토리로-여러명이서-작업합니다-원격-저장소-1개에-같이-작업할-사람을-collaborator-로-추가하여-함께-작업합니다"><a href="#clone-하나의-레포지토리로-여러명이서-작업합니다-원격-저장소-1개에-같이-작업할-사람을-collaborator-로-추가하여-함께-작업합니다" class="headerlink" title="clone : 하나의 레포지토리로 여러명이서 작업합니다. 원격 저장소 1개에 같이 작업할 사람을 collaborator 로 추가하여 함께 작업합니다."></a>clone : 하나의 레포지토리로 여러명이서 작업합니다. 원격 저장소 1개에 같이 작업할 사람을 collaborator 로 추가하여 함께 작업합니다.</h2><p>git clone은 깃허브에 있는 저장소를 그대로 내 컴퓨터로 가져오고 싶을 때 쓰는 명령어입니다.</p><p>단순히 파일 다운로드만을 하는 것이 아니라 commit 기록과 역사까지 전부 가져오기 때문에 이전 기록으로 돌아갈 수도 있고, pull &#x2F; push 등을 통해 실제 저장소에 반영할 수도 있습니다.</p><p><img src="/../images/2023-07-11-18-18-41.png"></p><p>원격 저장소를 클론했습니다. 그리고 원격 저장소에서 수정을 거친 뒤 pull을 받아보겠습니다.</p><p>git pull origin main 명령어를 수행하면</p><p><img src="/../images/2023-07-11-18-19-58.png"></p><p>수정된 사항이 로컬 저장소에도 적용되는 것을 볼 수 있습니다.</p><p>개발단위가 작은 소규모 개발팀 등에서 사용하는 방식입니다.</p><h2 id="fork-하나의-레포지토리를-각자가-복사하여-자기-레포지토리에서-작업하고-원본-레포지토리에-요청을-보내-합쳐가면서-작업합니다"><a href="#fork-하나의-레포지토리를-각자가-복사하여-자기-레포지토리에서-작업하고-원본-레포지토리에-요청을-보내-합쳐가면서-작업합니다" class="headerlink" title="fork : 하나의 레포지토리를 각자가 복사하여 자기 레포지토리에서 작업하고 원본 레포지토리에 요청을 보내 합쳐가면서 작업합니다."></a>fork : 하나의 레포지토리를 각자가 복사하여 자기 레포지토리에서 작업하고 원본 레포지토리에 요청을 보내 합쳐가면서 작업합니다.</h2>]]></content:encoded>
      
      
      <category domain="https://NamgungJongMin.github.io/categories/Git-Github/">Git / Github</category>
      
      
      <category domain="https://NamgungJongMin.github.io/tags/Git/">Git</category>
      
      <category domain="https://NamgungJongMin.github.io/tags/Github/">Github</category>
      
      
      <comments>https://namgungjongmin.github.io/2023/07/11/git1/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
